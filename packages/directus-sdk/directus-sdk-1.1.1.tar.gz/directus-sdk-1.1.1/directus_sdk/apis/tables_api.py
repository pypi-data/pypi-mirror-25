# coding: utf-8

"""
    directus.io

    API for directus.io

    OpenAPI spec version: 1.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class TablesApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_column(self, table_id, **kwargs):
        """
        Create a column in a given table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_column(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str table_name: Name of table to add
        :param str column_name: The unique name of the column to create
        :param str type: The datatype of the column, eg: INT
        :param str ui: The Directus Interface to use for this column
        :param bool hidden_input: Whether the column will be hidden (globally) on the Edit Item page
        :param bool hidden_list: Whether the column will be hidden (globally) on the Item Listing page
        :param bool required: Whether the column is required. If required, the interface's validation function will be triggered
        :param int sort: The sort order of the column used to override the column order in the schema
        :param str comment: A helpful note to users for this column
        :param str relationship_type: The column's relationship type (only used when storing relational data) eg: ONETOMANY, MANYTOMANY or MANYTOONE
        :param str related_table: The table name this column is related to (only used when storing relational data)
        :param str junction_table: The pivot/junction table that joins the column's table with the related table (only used when storing relational data)
        :param str junction_key_left: The column name in junction that is related to the column's table (only used when storing relational data)
        :param str junction_key_right: The column name in junction that is related to the related table (only used when storing relational data)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_column_with_http_info(table_id, **kwargs)
        else:
            (data) = self.add_column_with_http_info(table_id, **kwargs)
            return data

    def add_column_with_http_info(self, table_id, **kwargs):
        """
        Create a column in a given table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_column_with_http_info(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str table_name: Name of table to add
        :param str column_name: The unique name of the column to create
        :param str type: The datatype of the column, eg: INT
        :param str ui: The Directus Interface to use for this column
        :param bool hidden_input: Whether the column will be hidden (globally) on the Edit Item page
        :param bool hidden_list: Whether the column will be hidden (globally) on the Item Listing page
        :param bool required: Whether the column is required. If required, the interface's validation function will be triggered
        :param int sort: The sort order of the column used to override the column order in the schema
        :param str comment: A helpful note to users for this column
        :param str relationship_type: The column's relationship type (only used when storing relational data) eg: ONETOMANY, MANYTOMANY or MANYTOONE
        :param str related_table: The table name this column is related to (only used when storing relational data)
        :param str junction_table: The pivot/junction table that joins the column's table with the related table (only used when storing relational data)
        :param str junction_key_left: The column name in junction that is related to the column's table (only used when storing relational data)
        :param str junction_key_right: The column name in junction that is related to the related table (only used when storing relational data)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'table_name', 'column_name', 'type', 'ui', 'hidden_input', 'hidden_list', 'required', 'sort', 'comment', 'relationship_type', 'related_table', 'junction_table', 'junction_key_left', 'junction_key_right']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_column" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `add_column`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'table_name' in params:
            form_params.append(('table_name', params['table_name']))
        if 'column_name' in params:
            form_params.append(('column_name', params['column_name']))
        if 'type' in params:
            form_params.append(('type', params['type']))
        if 'ui' in params:
            form_params.append(('ui', params['ui']))
        if 'hidden_input' in params:
            form_params.append(('hidden_input', params['hidden_input']))
        if 'hidden_list' in params:
            form_params.append(('hidden_list', params['hidden_list']))
        if 'required' in params:
            form_params.append(('required', params['required']))
        if 'sort' in params:
            form_params.append(('sort', params['sort']))
        if 'comment' in params:
            form_params.append(('comment', params['comment']))
        if 'relationship_type' in params:
            form_params.append(('relationship_type', params['relationship_type']))
        if 'related_table' in params:
            form_params.append(('related_table', params['related_table']))
        if 'junction_table' in params:
            form_params.append(('junction_table', params['junction_table']))
        if 'junction_key_left' in params:
            form_params.append(('junction_key_left', params['junction_key_left']))
        if 'junction_key_right' in params:
            form_params.append(('junction_key_right', params['junction_key_right']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/columns', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def add_row(self, table_id, custom_data, **kwargs):
        """
        Add a new row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_row(table_id, custom_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str custom_data: Data based on your specific schema eg: active=1&title=LoremIpsum (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_row_with_http_info(table_id, custom_data, **kwargs)
        else:
            (data) = self.add_row_with_http_info(table_id, custom_data, **kwargs)
            return data

    def add_row_with_http_info(self, table_id, custom_data, **kwargs):
        """
        Add a new row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_row_with_http_info(table_id, custom_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str custom_data: Data based on your specific schema eg: active=1&title=LoremIpsum (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'custom_data']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_row" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `add_row`")
        # verify the required parameter 'custom_data' is set
        if ('custom_data' not in params) or (params['custom_data'] is None):
            raise ValueError("Missing the required parameter `custom_data` when calling `add_row`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'custom_data' in params:
            body_params = params['custom_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/rows', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def add_table(self, **kwargs):
        """
        Add a new table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_table(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Name of table to add
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_table_with_http_info(**kwargs)
        else:
            (data) = self.add_table_with_http_info(**kwargs)
            return data

    def add_table_with_http_info(self, **kwargs):
        """
        Add a new table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_table_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Name of table to add
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_table" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_column(self, table_id, column_name, **kwargs):
        """
        Delete row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_column(table_id, column_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str column_name: Name of column to return (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_column_with_http_info(table_id, column_name, **kwargs)
        else:
            (data) = self.delete_column_with_http_info(table_id, column_name, **kwargs)
            return data

    def delete_column_with_http_info(self, table_id, column_name, **kwargs):
        """
        Delete row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_column_with_http_info(table_id, column_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str column_name: Name of column to return (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'column_name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_column" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `delete_column`")
        # verify the required parameter 'column_name' is set
        if ('column_name' not in params) or (params['column_name'] is None):
            raise ValueError("Missing the required parameter `column_name` when calling `delete_column`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']
        if 'column_name' in params:
            path_params['columnName'] = params['column_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/columns/{columnName}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_row(self, table_id, row_id, **kwargs):
        """
        Delete row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_row(table_id, row_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param int row_id: ID of row to return from rows (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_row_with_http_info(table_id, row_id, **kwargs)
        else:
            (data) = self.delete_row_with_http_info(table_id, row_id, **kwargs)
            return data

    def delete_row_with_http_info(self, table_id, row_id, **kwargs):
        """
        Delete row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_row_with_http_info(table_id, row_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param int row_id: ID of row to return from rows (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'row_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_row" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `delete_row`")
        # verify the required parameter 'row_id' is set
        if ('row_id' not in params) or (params['row_id'] is None):
            raise ValueError("Missing the required parameter `row_id` when calling `delete_row`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']
        if 'row_id' in params:
            path_params['rowId'] = params['row_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/rows/{rowId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_table(self, table_id, **kwargs):
        """
        Delete Table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_table(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_table_with_http_info(table_id, **kwargs)
        else:
            (data) = self.delete_table_with_http_info(table_id, **kwargs)
            return data

    def delete_table_with_http_info(self, table_id, **kwargs):
        """
        Delete Table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_table_with_http_info(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `delete_table`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_table(self, table_id, **kwargs):
        """
        Returns specific table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :return: GetTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_table_with_http_info(table_id, **kwargs)
        else:
            (data) = self.get_table_with_http_info(table_id, **kwargs)
            return data

    def get_table_with_http_info(self, table_id, **kwargs):
        """
        Returns specific table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_with_http_info(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :return: GetTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `get_table`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GetTable',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_table_column(self, table_id, column_name, **kwargs):
        """
        Returns specific table column
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_column(table_id, column_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str column_name: Name of column to return (required)
        :return: GetTableColumn
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_table_column_with_http_info(table_id, column_name, **kwargs)
        else:
            (data) = self.get_table_column_with_http_info(table_id, column_name, **kwargs)
            return data

    def get_table_column_with_http_info(self, table_id, column_name, **kwargs):
        """
        Returns specific table column
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_column_with_http_info(table_id, column_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str column_name: Name of column to return (required)
        :return: GetTableColumn
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'column_name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_table_column" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `get_table_column`")
        # verify the required parameter 'column_name' is set
        if ('column_name' not in params) or (params['column_name'] is None):
            raise ValueError("Missing the required parameter `column_name` when calling `get_table_column`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']
        if 'column_name' in params:
            path_params['columnName'] = params['column_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/columns/{columnName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GetTableColumn',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_table_columns(self, table_id, **kwargs):
        """
        Returns table columns
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_columns(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :return: GetTableColumns
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_table_columns_with_http_info(table_id, **kwargs)
        else:
            (data) = self.get_table_columns_with_http_info(table_id, **kwargs)
            return data

    def get_table_columns_with_http_info(self, table_id, **kwargs):
        """
        Returns table columns
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_columns_with_http_info(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :return: GetTableColumns
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_table_columns" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `get_table_columns`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/columns', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GetTableColumns',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_table_row(self, table_id, row_id, **kwargs):
        """
        Returns specific table row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_row(table_id, row_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param int row_id: ID of row to return from rows (required)
        :return: GetTableRow
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_table_row_with_http_info(table_id, row_id, **kwargs)
        else:
            (data) = self.get_table_row_with_http_info(table_id, row_id, **kwargs)
            return data

    def get_table_row_with_http_info(self, table_id, row_id, **kwargs):
        """
        Returns specific table row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_row_with_http_info(table_id, row_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param int row_id: ID of row to return from rows (required)
        :return: GetTableRow
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'row_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_table_row" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `get_table_row`")
        # verify the required parameter 'row_id' is set
        if ('row_id' not in params) or (params['row_id'] is None):
            raise ValueError("Missing the required parameter `row_id` when calling `get_table_row`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']
        if 'row_id' in params:
            path_params['rowId'] = params['row_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/rows/{rowId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GetTableRow',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_table_rows(self, table_id, **kwargs):
        """
        Returns table rows
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_rows(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :return: GetTableRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_table_rows_with_http_info(table_id, **kwargs)
        else:
            (data) = self.get_table_rows_with_http_info(table_id, **kwargs)
            return data

    def get_table_rows_with_http_info(self, table_id, **kwargs):
        """
        Returns table rows
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_table_rows_with_http_info(table_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :return: GetTableRows
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_table_rows" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `get_table_rows`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/rows', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GetTableRows',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_tables(self, **kwargs):
        """
        Returns tables
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_tables(async=True)
        >>> result = thread.get()

        :param async bool
        :return: GetTables
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_tables_with_http_info(**kwargs)
        else:
            (data) = self.get_tables_with_http_info(**kwargs)
            return data

    def get_tables_with_http_info(self, **kwargs):
        """
        Returns tables
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_tables_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: GetTables
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tables" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GetTables',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_column(self, table_id, column_name, **kwargs):
        """
        Update column
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_column(table_id, column_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str column_name: Name of column to return (required)
        :param str data_type: The datatype of the column, eg: INT
        :param str ui: The Directus Interface to use for this column
        :param bool hidden_input: Whether the column will be hidden (globally) on the Edit Item page
        :param bool hidden_list: Whether the column will be hidden (globally) on the Item Listing page
        :param bool required: Whether the column is required. If required, the interface's validation function will be triggered
        :param int sort: The sort order of the column used to override the column order in the schema
        :param str comment: A helpful note to users for this column
        :param str relationship_type: The column's relationship type (only used when storing relational data) eg: ONETOMANY, MANYTOMANY or MANYTOONE
        :param str related_table: The table name this column is related to (only used when storing relational data)
        :param str junction_table: The pivot/junction table that joins the column's table with the related table (only used when storing relational data)
        :param str junction_key_left: The column name in junction that is related to the column's table (only used when storing relational data)
        :param str junction_key_right: The column name in junction that is related to the related table (only used when storing relational data)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_column_with_http_info(table_id, column_name, **kwargs)
        else:
            (data) = self.update_column_with_http_info(table_id, column_name, **kwargs)
            return data

    def update_column_with_http_info(self, table_id, column_name, **kwargs):
        """
        Update column
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_column_with_http_info(table_id, column_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param str column_name: Name of column to return (required)
        :param str data_type: The datatype of the column, eg: INT
        :param str ui: The Directus Interface to use for this column
        :param bool hidden_input: Whether the column will be hidden (globally) on the Edit Item page
        :param bool hidden_list: Whether the column will be hidden (globally) on the Item Listing page
        :param bool required: Whether the column is required. If required, the interface's validation function will be triggered
        :param int sort: The sort order of the column used to override the column order in the schema
        :param str comment: A helpful note to users for this column
        :param str relationship_type: The column's relationship type (only used when storing relational data) eg: ONETOMANY, MANYTOMANY or MANYTOONE
        :param str related_table: The table name this column is related to (only used when storing relational data)
        :param str junction_table: The pivot/junction table that joins the column's table with the related table (only used when storing relational data)
        :param str junction_key_left: The column name in junction that is related to the column's table (only used when storing relational data)
        :param str junction_key_right: The column name in junction that is related to the related table (only used when storing relational data)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'column_name', 'data_type', 'ui', 'hidden_input', 'hidden_list', 'required', 'sort', 'comment', 'relationship_type', 'related_table', 'junction_table', 'junction_key_left', 'junction_key_right']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_column" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `update_column`")
        # verify the required parameter 'column_name' is set
        if ('column_name' not in params) or (params['column_name'] is None):
            raise ValueError("Missing the required parameter `column_name` when calling `update_column`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']
        if 'column_name' in params:
            path_params['columnName'] = params['column_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'data_type' in params:
            form_params.append(('data_type', params['data_type']))
        if 'ui' in params:
            form_params.append(('ui', params['ui']))
        if 'hidden_input' in params:
            form_params.append(('hidden_input', params['hidden_input']))
        if 'hidden_list' in params:
            form_params.append(('hidden_list', params['hidden_list']))
        if 'required' in params:
            form_params.append(('required', params['required']))
        if 'sort' in params:
            form_params.append(('sort', params['sort']))
        if 'comment' in params:
            form_params.append(('comment', params['comment']))
        if 'relationship_type' in params:
            form_params.append(('relationship_type', params['relationship_type']))
        if 'related_table' in params:
            form_params.append(('related_table', params['related_table']))
        if 'junction_table' in params:
            form_params.append(('junction_table', params['junction_table']))
        if 'junction_key_left' in params:
            form_params.append(('junction_key_left', params['junction_key_left']))
        if 'junction_key_right' in params:
            form_params.append(('junction_key_right', params['junction_key_right']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/columns/{columnName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_row(self, table_id, row_id, custom_data, **kwargs):
        """
        Update row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_row(table_id, row_id, custom_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param int row_id: ID of row to return from rows (required)
        :param str custom_data: Data based on your specific schema eg: active=1&title=LoremIpsum (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_row_with_http_info(table_id, row_id, custom_data, **kwargs)
        else:
            (data) = self.update_row_with_http_info(table_id, row_id, custom_data, **kwargs)
            return data

    def update_row_with_http_info(self, table_id, row_id, custom_data, **kwargs):
        """
        Update row
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_row_with_http_info(table_id, row_id, custom_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_id: ID of table to return rows from (required)
        :param int row_id: ID of row to return from rows (required)
        :param str custom_data: Data based on your specific schema eg: active=1&title=LoremIpsum (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'row_id', 'custom_data']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_row" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `update_row`")
        # verify the required parameter 'row_id' is set
        if ('row_id' not in params) or (params['row_id'] is None):
            raise ValueError("Missing the required parameter `row_id` when calling `update_row`")
        # verify the required parameter 'custom_data' is set
        if ('custom_data' not in params) or (params['custom_data'] is None):
            raise ValueError("Missing the required parameter `custom_data` when calling `update_row`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']
        if 'row_id' in params:
            path_params['rowId'] = params['row_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'custom_data' in params:
            body_params = params['custom_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/tables/{tableId}/rows/{rowId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
