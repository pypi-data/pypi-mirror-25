from thrift.transport.TSocket import TSocket
from thrift.transport.TTransport import TFramedTransport
from thrift.protocol.TCompactProtocol import TCompactProtocolAccelerated
from thrift.transport.TTransport import TTransportException
from time import sleep
import logging

LOG = logging.getLogger(__name__)


class TClient:
    """
    Client for connecting to services started with the tconnect.TServer.

    If non-default settings where used for the transport or protocol of the sever the
    same settings have to be used here.
    This Client can generally not be used to connect to Thrift servers that were started outside
    of the tconnect.TServer as assumptions are made about the naming of multiplexed services.

    The service_module should come directly from the python code generated by thrift.
    So if you create a service TestService in the namespace thrift_test the
    correct argument would be thrift_test.TestService here.

    :param url: the url under which the server is running
    :param port: the port on which the server is running
    :param service_module: the generated module of the service to connect to
    :param timeout: the timeout to use for connections (in milliseconds)
    :param protocol_class: the thrift protocol class to use
    :param transport_class: the thrift transport class to use
    """

    _redirect = []

    def __init__(self, url: str, port: int, service_module,
                 timeout: int=45000,
                 protocol_class=TCompactProtocolAccelerated,
                 transport_class=TFramedTransport):
        """"""
        self._url = url
        self._port = port
        self._service_module = service_module
        self._timeout = timeout
        self._protocol_class = protocol_class
        self._transport_class = transport_class

        self._refresh_connection()
        self._setup_redirect()
        self._connect_with_timeout()

    def _refresh_connection(self):
        LOG.debug("Connecting to %s:%d" % (self._url, self._port))
        socket = TSocket(self._url, self._port)
        socket.setTimeout(self._timeout)

        self._transport = self._transport_class(socket)
        protocol = self._protocol_class(self._transport)

        self._client = self._service_module.Client(protocol)

    def _connect_with_timeout(self):
        for _ in range(self._timeout // 10):
            try:
                self._transport.open()
                return
            except TTransportException:
                sleep(0.1)
        raise TimeoutError("Couldn't connect to host %s:%d" % (self._url, self._port))

    def _setup_redirect(self):
        """Redirect method calls intended for _client"""
        self._redirect = [method for method in dir(self._client) if not method.startswith('_')]

    def __getattribute__(self, item):
        if item in object.__getattribute__(self, '_redirect'):
            return object.__getattribute__(self, '_client').__getattribute__(item)
        else:
            return object.__getattribute__(self, item)

