import json
import logging
from git import Repo
from git.repo import fun
import os
import subprocess

class ExploitManager(object):
    def __init__(self, exploit_path,
                       exploits_repo,
                       subfolder='/exploits'):
        if exploit_path is None:
            self.exploit_path = os.path.dirname(os.path.realpath(__file__)) + \
            '/exploits'
        else:
            self.exploit_path = exploit_path
        self.exploit_path = os.path.relpath(self.exploit_path)
        self.exploits_repo = exploits_repo
        self.exploits = {}
        self.console_logger = logging.getLogger('console')
        self.subfolder = subfolder

    def load_exploit_info(self):
        self.exploit_file_names = [f for f in os.listdir(self.exploit_path + self.subfolder)
                                   if os.path.isfile(os.path.join(self.exploit_path + self.subfolder, f)) and
                                   os.path.join(os.path.join(self.exploit_path + self.subfolder, f)).endswith(".json")]

        for exploit_file_name in self.exploit_file_names:
            self.read(os.path.join(self.exploit_path + self.subfolder, exploit_file_name))

    def refresh_exploits_repository(self):
        self.console_logger.info("Refreshing Exploits Repository")
        repo = None
        origin = None
        if fun.is_git_dir(self.exploit_path):
            repo = Repo(self.exploit_path)
        else:
            repo = Repo.init(self.exploit_path)

        try:
            origin = repo.remote('origin')
        except ValueError:
            origin = repo.create_remote('origin', self.exploits_repo)
        origin.fetch()

        if 'master' not in repo.heads:
            repo.create_head('master', origin.refs.master)
        repo.heads.master.set_tracking_branch(origin.refs.master)
        repo.heads.master.checkout()
        origin.pull()
        self.console_logger.info("Finished Refreshing Exploits Repository")

    def write(self, edbid):
        file_name = self.exploit_path + self.subfolder + '/' + edbid + '.json'
        with open(file_name, 'w') as exploit_file:
            json.dump(self.exploits[edbid], exploit_file)

    def read(self, file_name):
        with open(file_name, 'r') as exploit_file:
            root = os.path.splitext(file_name)[0]
            edbid = root.replace(self.exploit_path + self.subfolder + '/', "")
            self.exploits[edbid] = json.load(exploit_file)

    def affects_el(self, edbid):
        try:
            for cveid in self.exploits[edbid]['cves'].keys():
                if 'windows' in self.exploits[edbid]['filename']:
                    return False
                if self.exploits[edbid]['cves'][cveid]['rhapi']:
                    return True
        except KeyError:
            pass
        return False

    def exploits_by_cve(self, cveid):
        edbids = []

        for edbid in self.exploits.keys():
            if cveid in self.exploits[edbid]['cves'] and \
                    'windows' not in self.exploits[edbid]['filename']:
                edbids.append(edbid)

        return edbids

    def score(self, edbid, version, score_kind, score):
        if 'scores' not in self.exploits[edbid].keys():
            self.exploits[edbid]['scores'] = dict()

        if version not in self.exploits[edbid]['scores'].keys():
            self.exploits[edbid]['scores'][version] = dict()

        if score_kind not in \
                self.exploits[edbid]['scores'][version].keys():
            self.exploits[edbid]['scores'][version][score_kind] = dict()

        self.exploits[edbid]['scores'][version][score_kind] = score

    def set_stage_info(self, edbid, stage_info):
        self.exploits[edbid]['staging'] = stage_info

    def stage(self, edbid, destination):
        if 'staging' not in self.exploits[edbid]:
            return False, "No staging information available."

        try:
            command = self.exploits[edbid]['staging'].split(' ')
            p = subprocess.Popen(command,
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE,
                                 cwd=destination)
            out, err = p.communicate()
            lines = out.split('\n')
            error_lines = err.split('\n')
        except OSError:
            self.logger.error("Command %s cannot be run on this host." %
                              self.exploits[edbid]['staging'])
            sys.exit(1)
        if p.returncode != 0:
            return False, ','.join(error_lines)
        return True, lines

    def get_exploit_strings(self, edbid):
        strings = []
        if 'scores' not in self.exploits[edbid].keys():
            for cve in self.exploits[edbid]['cves']:
                string = edbid
                string += ","
                string += self.exploits[edbid]['filename']
                string += ","
                if 'staging' in self.exploits[edbid].keys():
                    string += self.exploits[edbid]['staging']
                    string += ","
                string += cve
                strings.append(string)
        else:
            for ver in self.exploits[edbid]['scores'].keys():
                for kind in self.exploits[edbid]['scores'][ver].keys():
                    for cve in self.exploits[edbid]['cves']:
                        string = edbid
                        string += ","
                        string += self.exploits[edbid]['filename']
                        string += ","
                        if 'staging' in self.exploits[edbid].keys():
                            string += self.exploits[edbid]['staging']
                            string += ","
                        string += cve
                        string += ","
                        string += ver
                        string += ","
                        string += kind
                        string += ','
                        string += self.exploits[edbid]['scores'][ver][kind]
                        strings.append(string)

        return strings
