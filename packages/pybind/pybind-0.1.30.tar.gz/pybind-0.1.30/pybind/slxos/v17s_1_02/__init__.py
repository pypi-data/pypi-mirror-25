
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class brocade_ospfv3(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ospfv3 - based on the path /brocade-ospfv3. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage OSPF Version 3 Protocol.
  """
  _pyangbind_elements = {}

  

import arp_entry
import host_table
class brocade_arp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-arp - based on the path /brocade-arp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
ARPD Daemon
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__arp_entry','__host_table',)

  _yang_name = 'brocade-arp'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__host_table = YANGDynClass(base=host_table.host_table, is_container='container', presence=False, yang_name="host-table", rest_name="host-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Hardware host-table (IPV4 and IPV6)', u'callpoint': u'ArpConversational', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='container', is_config=True)
    self.__arp_entry = YANGDynClass(base=YANGListType("arp_ip_address",arp_entry.arp_entry, yang_name="arp-entry", rest_name="arp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='arp-ip-address', extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}), is_container='list', yang_name="arp-entry", rest_name="arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_arp_entry(self):
    """
    Getter method for arp_entry, mapped from YANG variable /arp_entry (list)
    """
    return self.__arp_entry
      
  def _set_arp_entry(self, v, load=False):
    """
    Setter method for arp_entry, mapped from YANG variable /arp_entry (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_arp_entry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_arp_entry() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("arp_ip_address",arp_entry.arp_entry, yang_name="arp-entry", rest_name="arp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='arp-ip-address', extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}), is_container='list', yang_name="arp-entry", rest_name="arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """arp_entry must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("arp_ip_address",arp_entry.arp_entry, yang_name="arp-entry", rest_name="arp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='arp-ip-address', extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}), is_container='list', yang_name="arp-entry", rest_name="arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='list', is_config=True)""",
        })

    self.__arp_entry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_arp_entry(self):
    self.__arp_entry = YANGDynClass(base=YANGListType("arp_ip_address",arp_entry.arp_entry, yang_name="arp-entry", rest_name="arp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='arp-ip-address', extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}), is_container='list', yang_name="arp-entry", rest_name="arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='list', is_config=True)


  def _get_host_table(self):
    """
    Getter method for host_table, mapped from YANG variable /host_table (container)
    """
    return self.__host_table
      
  def _set_host_table(self, v, load=False):
    """
    Setter method for host_table, mapped from YANG variable /host_table (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_table is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_table() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=host_table.host_table, is_container='container', presence=False, yang_name="host-table", rest_name="host-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Hardware host-table (IPV4 and IPV6)', u'callpoint': u'ArpConversational', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_table must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=host_table.host_table, is_container='container', presence=False, yang_name="host-table", rest_name="host-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Hardware host-table (IPV4 and IPV6)', u'callpoint': u'ArpConversational', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='container', is_config=True)""",
        })

    self.__host_table = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_table(self):
    self.__host_table = YANGDynClass(base=host_table.host_table, is_container='container', presence=False, yang_name="host-table", rest_name="host-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Hardware host-table (IPV4 and IPV6)', u'callpoint': u'ArpConversational', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='container', is_config=True)

  arp_entry = __builtin__.property(_get_arp_entry, _set_arp_entry)
  host_table = __builtin__.property(_get_host_table, _set_host_table)


  _pyangbind_elements = {'arp_entry': arp_entry, 'host_table': host_table, }


import mpls_config
class brocade_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /brocade-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
mpls protocol.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mpls_config',)

  _yang_name = 'brocade-mpls'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mpls_config = YANGDynClass(base=mpls_config.mpls_config, is_container='container', presence=False, yang_name="mpls-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'147'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mpls_config(self):
    """
    Getter method for mpls_config, mapped from YANG variable /mpls_config (container)
    """
    return self.__mpls_config
      
  def _set_mpls_config(self, v, load=False):
    """
    Setter method for mpls_config, mapped from YANG variable /mpls_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls_config.mpls_config, is_container='container', presence=False, yang_name="mpls-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'147'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls_config.mpls_config, is_container='container', presence=False, yang_name="mpls-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'147'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__mpls_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_config(self):
    self.__mpls_config = YANGDynClass(base=mpls_config.mpls_config, is_container='container', presence=False, yang_name="mpls-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'147'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)

  mpls_config = __builtin__.property(_get_mpls_config, _set_mpls_config)


  _pyangbind_elements = {'mpls_config': mpls_config, }


import protocol_vrrp
class brocade_vrrp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vrrp - based on the path /brocade-vrrp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Virtual Router Redundancy Protocol
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__protocol_vrrp',)

  _yang_name = 'brocade-vrrp'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__protocol_vrrp = YANGDynClass(base=protocol_vrrp.protocol_vrrp, is_container='container', presence=False, yang_name="protocol-vrrp", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-vrrp', defining_module='brocade-vrrp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_protocol_vrrp(self):
    """
    Getter method for protocol_vrrp, mapped from YANG variable /protocol_vrrp (container)

    YANG Description: An intermediary node that separates the protocol vrrp from other protocols.
    """
    return self.__protocol_vrrp
      
  def _set_protocol_vrrp(self, v, load=False):
    """
    Setter method for protocol_vrrp, mapped from YANG variable /protocol_vrrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_vrrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_vrrp() directly.

    YANG Description: An intermediary node that separates the protocol vrrp from other protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol_vrrp.protocol_vrrp, is_container='container', presence=False, yang_name="protocol-vrrp", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-vrrp', defining_module='brocade-vrrp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_vrrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol_vrrp.protocol_vrrp, is_container='container', presence=False, yang_name="protocol-vrrp", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-vrrp', defining_module='brocade-vrrp', yang_type='container', is_config=True)""",
        })

    self.__protocol_vrrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_vrrp(self):
    self.__protocol_vrrp = YANGDynClass(base=protocol_vrrp.protocol_vrrp, is_container='container', presence=False, yang_name="protocol-vrrp", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-vrrp', defining_module='brocade-vrrp', yang_type='container', is_config=True)

  protocol_vrrp = __builtin__.property(_get_protocol_vrrp, _set_protocol_vrrp)


  _pyangbind_elements = {'protocol_vrrp': protocol_vrrp, }


import hide_filter_change_update_delay_holder
class brocade_ip_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-policy - based on the path /brocade-ip-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
different IP routing protocols.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__hide_filter_change_update_delay_holder',)

  _yang_name = 'brocade-ip-policy'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__hide_filter_change_update_delay_holder = YANGDynClass(base=hide_filter_change_update_delay_holder.hide_filter_change_update_delay_holder, is_container='container', presence=False, yang_name="hide-filter-change-update-delay-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-ip-policy', defining_module='brocade-ip-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_hide_filter_change_update_delay_holder(self):
    """
    Getter method for hide_filter_change_update_delay_holder, mapped from YANG variable /hide_filter_change_update_delay_holder (container)
    """
    return self.__hide_filter_change_update_delay_holder
      
  def _set_hide_filter_change_update_delay_holder(self, v, load=False):
    """
    Setter method for hide_filter_change_update_delay_holder, mapped from YANG variable /hide_filter_change_update_delay_holder (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hide_filter_change_update_delay_holder is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hide_filter_change_update_delay_holder() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hide_filter_change_update_delay_holder.hide_filter_change_update_delay_holder, is_container='container', presence=False, yang_name="hide-filter-change-update-delay-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-ip-policy', defining_module='brocade-ip-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hide_filter_change_update_delay_holder must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hide_filter_change_update_delay_holder.hide_filter_change_update_delay_holder, is_container='container', presence=False, yang_name="hide-filter-change-update-delay-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-ip-policy', defining_module='brocade-ip-policy', yang_type='container', is_config=True)""",
        })

    self.__hide_filter_change_update_delay_holder = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hide_filter_change_update_delay_holder(self):
    self.__hide_filter_change_update_delay_holder = YANGDynClass(base=hide_filter_change_update_delay_holder.hide_filter_change_update_delay_holder, is_container='container', presence=False, yang_name="hide-filter-change-update-delay-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-ip-policy', defining_module='brocade-ip-policy', yang_type='container', is_config=True)

  hide_filter_change_update_delay_holder = __builtin__.property(_get_hide_filter_change_update_delay_holder, _set_hide_filter_change_update_delay_holder)


  _pyangbind_elements = {'hide_filter_change_update_delay_holder': hide_filter_change_update_delay_holder, }


class brocade_ip_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-config - based on the path /brocade-ip-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  _pyangbind_elements = {}

  

import cee_map
import nas
class brocade_qos_cee(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-cee - based on the path /brocade-qos-cee. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management submodule is an instrumentation to 
manage cee-map feature.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cee_map','__nas',)

  _yang_name = 'brocade-qos-cee'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cee_map = YANGDynClass(base=YANGListType("name",cee_map.cee_map, yang_name="cee-map", rest_name="cee-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}), is_container='list', yang_name="cee-map", rest_name="cee-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='list', is_config=True)
    self.__nas = YANGDynClass(base=nas.nas, is_container='container', presence=False, yang_name="nas", rest_name="nas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Network Attached Storage', u'sort-priority': u'37', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_cee_map(self):
    """
    Getter method for cee_map, mapped from YANG variable /cee_map (list)
    """
    return self.__cee_map
      
  def _set_cee_map(self, v, load=False):
    """
    Setter method for cee_map, mapped from YANG variable /cee_map (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cee_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cee_map() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",cee_map.cee_map, yang_name="cee-map", rest_name="cee-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}), is_container='list', yang_name="cee-map", rest_name="cee-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cee_map must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",cee_map.cee_map, yang_name="cee-map", rest_name="cee-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}), is_container='list', yang_name="cee-map", rest_name="cee-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='list', is_config=True)""",
        })

    self.__cee_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cee_map(self):
    self.__cee_map = YANGDynClass(base=YANGListType("name",cee_map.cee_map, yang_name="cee-map", rest_name="cee-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}), is_container='list', yang_name="cee-map", rest_name="cee-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='list', is_config=True)


  def _get_nas(self):
    """
    Getter method for nas, mapped from YANG variable /nas (container)
    """
    return self.__nas
      
  def _set_nas(self, v, load=False):
    """
    Setter method for nas, mapped from YANG variable /nas (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nas() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=nas.nas, is_container='container', presence=False, yang_name="nas", rest_name="nas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Network Attached Storage', u'sort-priority': u'37', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nas must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=nas.nas, is_container='container', presence=False, yang_name="nas", rest_name="nas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Network Attached Storage', u'sort-priority': u'37', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='container', is_config=True)""",
        })

    self.__nas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nas(self):
    self.__nas = YANGDynClass(base=nas.nas, is_container='container', presence=False, yang_name="nas", rest_name="nas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Network Attached Storage', u'sort-priority': u'37', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='container', is_config=True)

  cee_map = __builtin__.property(_get_cee_map, _set_cee_map)
  nas = __builtin__.property(_get_nas, _set_nas)


  _pyangbind_elements = {'cee_map': cee_map, 'nas': nas, }


import show
import clear
import ip
import ipv6
import router
import routing_system
class brocade_common_def(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-common-def - based on the path /brocade-common-def. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module contains collection of most commonly 
used derived YANG data types within the 'Broacde' name-space.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__show','__clear','__ip','__ipv6','__router','__routing_system',)

  _yang_name = 'brocade-common-def'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__show = YANGDynClass(base=show.show, is_container='container', presence=False, yang_name="show", rest_name="show", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__ip = YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L3_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__clear = YANGDynClass(base=clear.clear, is_container='container', presence=False, yang_name="clear", rest_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=ipv6.ipv6, is_container='container', presence=False, yang_name="ipv6", rest_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IPv6).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_IPV6_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__routing_system = YANGDynClass(base=routing_system.routing_system, is_container='container', presence=False, yang_name="routing-system", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE'}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__router = YANGDynClass(base=router.router, is_container='container', presence=False, yang_name="router", rest_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Router', u'cli-incomplete-no': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_show(self):
    """
    Getter method for show, mapped from YANG variable /show (container)
    """
    return self.__show
      
  def _set_show(self, v, load=False):
    """
    Setter method for show, mapped from YANG variable /show (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_show is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_show() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=show.show, is_container='container', presence=False, yang_name="show", rest_name="show", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """show must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=show.show, is_container='container', presence=False, yang_name="show", rest_name="show", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__show = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_show(self):
    self.__show = YANGDynClass(base=show.show, is_container='container', presence=False, yang_name="show", rest_name="show", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /clear (container)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /clear (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=clear.clear, is_container='container', presence=False, yang_name="clear", rest_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clear.clear, is_container='container', presence=False, yang_name="clear", rest_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=clear.clear, is_container='container', presence=False, yang_name="clear", rest_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ip (container)
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ip (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L3_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L3_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L3_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /ipv6 (container)
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ipv6.ipv6, is_container='container', presence=False, yang_name="ipv6", rest_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IPv6).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_IPV6_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipv6.ipv6, is_container='container', presence=False, yang_name="ipv6", rest_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IPv6).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_IPV6_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=ipv6.ipv6, is_container='container', presence=False, yang_name="ipv6", rest_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IPv6).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_IPV6_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_router(self):
    """
    Getter method for router, mapped from YANG variable /router (container)

    YANG Description: The routing system.
    """
    return self.__router
      
  def _set_router(self, v, load=False):
    """
    Setter method for router, mapped from YANG variable /router (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router() directly.

    YANG Description: The routing system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=router.router, is_container='container', presence=False, yang_name="router", rest_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Router', u'cli-incomplete-no': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=router.router, is_container='container', presence=False, yang_name="router", rest_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Router', u'cli-incomplete-no': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router(self):
    self.__router = YANGDynClass(base=router.router, is_container='container', presence=False, yang_name="router", rest_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Router', u'cli-incomplete-no': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_routing_system(self):
    """
    Getter method for routing_system, mapped from YANG variable /routing_system (container)
    """
    return self.__routing_system
      
  def _set_routing_system(self, v, load=False):
    """
    Setter method for routing_system, mapped from YANG variable /routing_system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_system() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=routing_system.routing_system, is_container='container', presence=False, yang_name="routing-system", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE'}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=routing_system.routing_system, is_container='container', presence=False, yang_name="routing-system", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE'}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__routing_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_system(self):
    self.__routing_system = YANGDynClass(base=routing_system.routing_system, is_container='container', presence=False, yang_name="routing-system", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE'}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)

  show = __builtin__.property(_get_show, _set_show)
  clear = __builtin__.property(_get_clear, _set_clear)
  ip = __builtin__.property(_get_ip, _set_ip)
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6)
  router = __builtin__.property(_get_router, _set_router)
  routing_system = __builtin__.property(_get_routing_system, _set_routing_system)


  _pyangbind_elements = {'show': show, 'clear': clear, 'ip': ip, 'ipv6': ipv6, 'router': router, 'routing_system': routing_system, }


import node_id
class brocade_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-node - based on the path /brocade-node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
node-id feature.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__node_id',)

  _yang_name = 'brocade-node'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__node_id = YANGDynClass(base=YANGListType("node_id",node_id.node_id, yang_name="node-id", rest_name="node-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions={u'tailf-common': {u'info': u'Node Id for Node Specific configuration', u'callpoint': u'mgmtclusternodespecificcallpoint', u'cli-suppress-no': None}}), is_container='list', yang_name="node-id", rest_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Node Id for Node Specific configuration', u'callpoint': u'mgmtclusternodespecificcallpoint', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-node', defining_module='brocade-node', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_node_id(self):
    """
    Getter method for node_id, mapped from YANG variable /node_id (list)
    """
    return self.__node_id
      
  def _set_node_id(self, v, load=False):
    """
    Setter method for node_id, mapped from YANG variable /node_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("node_id",node_id.node_id, yang_name="node-id", rest_name="node-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions={u'tailf-common': {u'info': u'Node Id for Node Specific configuration', u'callpoint': u'mgmtclusternodespecificcallpoint', u'cli-suppress-no': None}}), is_container='list', yang_name="node-id", rest_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Node Id for Node Specific configuration', u'callpoint': u'mgmtclusternodespecificcallpoint', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-node', defining_module='brocade-node', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_id must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("node_id",node_id.node_id, yang_name="node-id", rest_name="node-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions={u'tailf-common': {u'info': u'Node Id for Node Specific configuration', u'callpoint': u'mgmtclusternodespecificcallpoint', u'cli-suppress-no': None}}), is_container='list', yang_name="node-id", rest_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Node Id for Node Specific configuration', u'callpoint': u'mgmtclusternodespecificcallpoint', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-node', defining_module='brocade-node', yang_type='list', is_config=True)""",
        })

    self.__node_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_id(self):
    self.__node_id = YANGDynClass(base=YANGListType("node_id",node_id.node_id, yang_name="node-id", rest_name="node-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions={u'tailf-common': {u'info': u'Node Id for Node Specific configuration', u'callpoint': u'mgmtclusternodespecificcallpoint', u'cli-suppress-no': None}}), is_container='list', yang_name="node-id", rest_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Node Id for Node Specific configuration', u'callpoint': u'mgmtclusternodespecificcallpoint', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-node', defining_module='brocade-node', yang_type='list', is_config=True)

  node_id = __builtin__.property(_get_node_id, _set_node_id)


  _pyangbind_elements = {'node_id': node_id, }


import firmware
import dhcp
class brocade_firmware(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-firmware - based on the path /brocade-firmware. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to firmware level
level commands
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__firmware','__dhcp',)

  _yang_name = 'brocade-firmware'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__dhcp = YANGDynClass(base=dhcp.dhcp, is_container='container', presence=False, yang_name="dhcp", rest_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage DHCP auto-deployment'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)
    self.__firmware = YANGDynClass(base=firmware.firmware, is_container='container', presence=False, yang_name="firmware", rest_name="firmware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'firmware operations', u'action': u'recover'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_firmware(self):
    """
    Getter method for firmware, mapped from YANG variable /firmware (container)
    """
    return self.__firmware
      
  def _set_firmware(self, v, load=False):
    """
    Setter method for firmware, mapped from YANG variable /firmware (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firmware is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firmware() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=firmware.firmware, is_container='container', presence=False, yang_name="firmware", rest_name="firmware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'firmware operations', u'action': u'recover'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firmware must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=firmware.firmware, is_container='container', presence=False, yang_name="firmware", rest_name="firmware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'firmware operations', u'action': u'recover'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)""",
        })

    self.__firmware = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firmware(self):
    self.__firmware = YANGDynClass(base=firmware.firmware, is_container='container', presence=False, yang_name="firmware", rest_name="firmware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'firmware operations', u'action': u'recover'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)


  def _get_dhcp(self):
    """
    Getter method for dhcp, mapped from YANG variable /dhcp (container)
    """
    return self.__dhcp
      
  def _set_dhcp(self, v, load=False):
    """
    Setter method for dhcp, mapped from YANG variable /dhcp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=dhcp.dhcp, is_container='container', presence=False, yang_name="dhcp", rest_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage DHCP auto-deployment'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dhcp.dhcp, is_container='container', presence=False, yang_name="dhcp", rest_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage DHCP auto-deployment'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)""",
        })

    self.__dhcp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp(self):
    self.__dhcp = YANGDynClass(base=dhcp.dhcp, is_container='container', presence=False, yang_name="dhcp", rest_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage DHCP auto-deployment'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)

  firmware = __builtin__.property(_get_firmware, _set_firmware)
  dhcp = __builtin__.property(_get_dhcp, _set_dhcp)


  _pyangbind_elements = {'firmware': firmware, 'dhcp': dhcp, }


class brocade_ip_forward(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-forward - based on the path /brocade-ip-forward. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentationfor the management
of CIDR multipath IP Routes. Multipath IP routes have the
same network  number but differing network masks.
  """
  _pyangbind_elements = {}

  

class brocade_firmware_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-firmware-ext - based on the path /brocade-firmware-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub module defines Firmware information.
Copyright (c) 2010-2011 by Brocade Communications Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

import ipv6_acl
class brocade_ipv6_access_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ipv6-access-list - based on the path /brocade-ipv6-access-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for IP Access-list.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ipv6_acl',)

  _yang_name = 'brocade-ipv6-access-list'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__ipv6_acl = YANGDynClass(base=ipv6_acl.ipv6_acl, is_container='container', presence=False, yang_name="ipv6-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_IP6_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-access-list', defining_module='brocade-ipv6-access-list', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_ipv6_acl(self):
    """
    Getter method for ipv6_acl, mapped from YANG variable /ipv6_acl (container)
    """
    return self.__ipv6_acl
      
  def _set_ipv6_acl(self, v, load=False):
    """
    Setter method for ipv6_acl, mapped from YANG variable /ipv6_acl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_acl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_acl() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ipv6_acl.ipv6_acl, is_container='container', presence=False, yang_name="ipv6-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_IP6_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-access-list', defining_module='brocade-ipv6-access-list', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_acl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipv6_acl.ipv6_acl, is_container='container', presence=False, yang_name="ipv6-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_IP6_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-access-list', defining_module='brocade-ipv6-access-list', yang_type='container', is_config=True)""",
        })

    self.__ipv6_acl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_acl(self):
    self.__ipv6_acl = YANGDynClass(base=ipv6_acl.ipv6_acl, is_container='container', presence=False, yang_name="ipv6-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_IP6_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-access-list', defining_module='brocade-ipv6-access-list', yang_type='container', is_config=True)

  ipv6_acl = __builtin__.property(_get_ipv6_acl, _set_ipv6_acl)


  _pyangbind_elements = {'ipv6_acl': ipv6_acl, }


import tvf_domain
class brocade_tvf_domain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-tvf-domain - based on the path /brocade-tvf-domain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule manages TVF Domain related CLIs.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__tvf_domain',)

  _yang_name = 'brocade-tvf-domain'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__tvf_domain = YANGDynClass(base=YANGListType("name",tvf_domain.tvf_domain, yang_name="tvf-domain", rest_name="tvf-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Tvf domain commands', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_TVF_DOMAIN_CLASS', u'cli-suppress-list-no': None, u'cli-custom-range-actionpoint': u'NsmRangeCliActionpoint', u'cli-custom-range-enumerator': u'NsmRangeCliActionpoint', u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'tvf_domain_cp'}}), is_container='list', yang_name="tvf-domain", rest_name="tvf-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Tvf domain commands', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_TVF_DOMAIN_CLASS', u'cli-suppress-list-no': None, u'cli-custom-range-actionpoint': u'NsmRangeCliActionpoint', u'cli-custom-range-enumerator': u'NsmRangeCliActionpoint', u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'tvf_domain_cp'}}, namespace='urn:brocade.com:mgmt:brocade-tvf-domain', defining_module='brocade-tvf-domain', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_tvf_domain(self):
    """
    Getter method for tvf_domain, mapped from YANG variable /tvf_domain (list)

    YANG Description: The list of TVF Domains in the managed device. Each row 
represents a TVF Domain. User can create/delete an entry in 
to this list.
    """
    return self.__tvf_domain
      
  def _set_tvf_domain(self, v, load=False):
    """
    Setter method for tvf_domain, mapped from YANG variable /tvf_domain (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tvf_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tvf_domain() directly.

    YANG Description: The list of TVF Domains in the managed device. Each row 
represents a TVF Domain. User can create/delete an entry in 
to this list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",tvf_domain.tvf_domain, yang_name="tvf-domain", rest_name="tvf-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Tvf domain commands', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_TVF_DOMAIN_CLASS', u'cli-suppress-list-no': None, u'cli-custom-range-actionpoint': u'NsmRangeCliActionpoint', u'cli-custom-range-enumerator': u'NsmRangeCliActionpoint', u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'tvf_domain_cp'}}), is_container='list', yang_name="tvf-domain", rest_name="tvf-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Tvf domain commands', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_TVF_DOMAIN_CLASS', u'cli-suppress-list-no': None, u'cli-custom-range-actionpoint': u'NsmRangeCliActionpoint', u'cli-custom-range-enumerator': u'NsmRangeCliActionpoint', u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'tvf_domain_cp'}}, namespace='urn:brocade.com:mgmt:brocade-tvf-domain', defining_module='brocade-tvf-domain', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tvf_domain must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",tvf_domain.tvf_domain, yang_name="tvf-domain", rest_name="tvf-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Tvf domain commands', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_TVF_DOMAIN_CLASS', u'cli-suppress-list-no': None, u'cli-custom-range-actionpoint': u'NsmRangeCliActionpoint', u'cli-custom-range-enumerator': u'NsmRangeCliActionpoint', u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'tvf_domain_cp'}}), is_container='list', yang_name="tvf-domain", rest_name="tvf-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Tvf domain commands', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_TVF_DOMAIN_CLASS', u'cli-suppress-list-no': None, u'cli-custom-range-actionpoint': u'NsmRangeCliActionpoint', u'cli-custom-range-enumerator': u'NsmRangeCliActionpoint', u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'tvf_domain_cp'}}, namespace='urn:brocade.com:mgmt:brocade-tvf-domain', defining_module='brocade-tvf-domain', yang_type='list', is_config=True)""",
        })

    self.__tvf_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tvf_domain(self):
    self.__tvf_domain = YANGDynClass(base=YANGListType("name",tvf_domain.tvf_domain, yang_name="tvf-domain", rest_name="tvf-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Tvf domain commands', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_TVF_DOMAIN_CLASS', u'cli-suppress-list-no': None, u'cli-custom-range-actionpoint': u'NsmRangeCliActionpoint', u'cli-custom-range-enumerator': u'NsmRangeCliActionpoint', u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'tvf_domain_cp'}}), is_container='list', yang_name="tvf-domain", rest_name="tvf-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Tvf domain commands', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_TVF_DOMAIN_CLASS', u'cli-suppress-list-no': None, u'cli-custom-range-actionpoint': u'NsmRangeCliActionpoint', u'cli-custom-range-enumerator': u'NsmRangeCliActionpoint', u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'tvf_domain_cp'}}, namespace='urn:brocade.com:mgmt:brocade-tvf-domain', defining_module='brocade-tvf-domain', yang_type='list', is_config=True)

  tvf_domain = __builtin__.property(_get_tvf_domain, _set_tvf_domain)


  _pyangbind_elements = {'tvf_domain': tvf_domain, }


import qos_mpls
class brocade_qos_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-mpls - based on the path /brocade-qos-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages MPLS Quality Of Service (QOS)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__qos_mpls',)

  _yang_name = 'brocade-qos-mpls'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__qos_mpls = YANGDynClass(base=qos_mpls.qos_mpls, is_container='container', presence=False, yang_name="qos-mpls", rest_name="qos-mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS Quality of Service (QoS)', u'sort-priority': u'51'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mpls', defining_module='brocade-qos-mpls', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_qos_mpls(self):
    """
    Getter method for qos_mpls, mapped from YANG variable /qos_mpls (container)
    """
    return self.__qos_mpls
      
  def _set_qos_mpls(self, v, load=False):
    """
    Setter method for qos_mpls, mapped from YANG variable /qos_mpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_mpls() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos_mpls.qos_mpls, is_container='container', presence=False, yang_name="qos-mpls", rest_name="qos-mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS Quality of Service (QoS)', u'sort-priority': u'51'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mpls', defining_module='brocade-qos-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_mpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos_mpls.qos_mpls, is_container='container', presence=False, yang_name="qos-mpls", rest_name="qos-mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS Quality of Service (QoS)', u'sort-priority': u'51'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mpls', defining_module='brocade-qos-mpls', yang_type='container', is_config=True)""",
        })

    self.__qos_mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_mpls(self):
    self.__qos_mpls = YANGDynClass(base=qos_mpls.qos_mpls, is_container='container', presence=False, yang_name="qos-mpls", rest_name="qos-mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS Quality of Service (QoS)', u'sort-priority': u'51'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mpls', defining_module='brocade-qos-mpls', yang_type='container', is_config=True)

  qos_mpls = __builtin__.property(_get_qos_mpls, _set_qos_mpls)


  _pyangbind_elements = {'qos_mpls': qos_mpls, }


import mctd_client_state_state
import show_client_id_df_info_state
class brocade_mct_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mct-operational - based on the path /brocade-mct-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage mct
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mctd_client_state_state','__show_client_id_df_info_state',)

  _yang_name = 'brocade-mct-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__show_client_id_df_info_state = YANGDynClass(base=YANGListType("cluster_id client_id",show_client_id_df_info_state.show_client_id_df_info_state, yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)
    self.__mctd_client_state_state = YANGDynClass(base=mctd_client_state_state.mctd_client_state_state, is_container='container', presence=False, yang_name="mctd-client-state-state", rest_name="mctd-client-state-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-mctd-client-state', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mctd_client_state_state(self):
    """
    Getter method for mctd_client_state_state, mapped from YANG variable /mctd_client_state_state (container)

    YANG Description: MCT Client Operational Information
    """
    return self.__mctd_client_state_state
      
  def _set_mctd_client_state_state(self, v, load=False):
    """
    Setter method for mctd_client_state_state, mapped from YANG variable /mctd_client_state_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mctd_client_state_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mctd_client_state_state() directly.

    YANG Description: MCT Client Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mctd_client_state_state.mctd_client_state_state, is_container='container', presence=False, yang_name="mctd-client-state-state", rest_name="mctd-client-state-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-mctd-client-state', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mctd_client_state_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mctd_client_state_state.mctd_client_state_state, is_container='container', presence=False, yang_name="mctd-client-state-state", rest_name="mctd-client-state-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-mctd-client-state', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='container', is_config=True)""",
        })

    self.__mctd_client_state_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mctd_client_state_state(self):
    self.__mctd_client_state_state = YANGDynClass(base=mctd_client_state_state.mctd_client_state_state, is_container='container', presence=False, yang_name="mctd-client-state-state", rest_name="mctd-client-state-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-mctd-client-state', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='container', is_config=True)


  def _get_show_client_id_df_info_state(self):
    """
    Getter method for show_client_id_df_info_state, mapped from YANG variable /show_client_id_df_info_state (list)

    YANG Description: VLANs elected as designated forwarder
    """
    return self.__show_client_id_df_info_state
      
  def _set_show_client_id_df_info_state(self, v, load=False):
    """
    Setter method for show_client_id_df_info_state, mapped from YANG variable /show_client_id_df_info_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_show_client_id_df_info_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_show_client_id_df_info_state() directly.

    YANG Description: VLANs elected as designated forwarder
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cluster_id client_id",show_client_id_df_info_state.show_client_id_df_info_state, yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """show_client_id_df_info_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cluster_id client_id",show_client_id_df_info_state.show_client_id_df_info_state, yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)""",
        })

    self.__show_client_id_df_info_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_show_client_id_df_info_state(self):
    self.__show_client_id_df_info_state = YANGDynClass(base=YANGListType("cluster_id client_id",show_client_id_df_info_state.show_client_id_df_info_state, yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)

  mctd_client_state_state = __builtin__.property(_get_mctd_client_state_state, _set_mctd_client_state_state)
  show_client_id_df_info_state = __builtin__.property(_get_show_client_id_df_info_state, _set_show_client_id_df_info_state)


  _pyangbind_elements = {'mctd_client_state_state': mctd_client_state_state, 'show_client_id_df_info_state': show_client_id_df_info_state, }


import police_remark_profile
import class_map
import policy_map
import system_qos
class brocade_qos_mqc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-mqc - based on the path /brocade-qos-mqc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Modular Quality of Service
(Modular QoS)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__police_remark_profile','__class_map','__policy_map','__system_qos',)

  _yang_name = 'brocade-qos-mqc'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__class_map = YANGDynClass(base=YANGListType("name",class_map.class_map, yang_name="class-map", rest_name="class-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}), is_container='list', yang_name="class-map", rest_name="class-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)
    self.__system_qos = YANGDynClass(base=system_qos.system_qos, is_container='container', presence=False, yang_name="system-qos", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'76'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='container', is_config=True)
    self.__police_remark_profile = YANGDynClass(base=YANGListType("profile_name",police_remark_profile.police_remark_profile, yang_name="police-remark-profile", rest_name="police-remark-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Configure police remark profile', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'police_remark_profile', u'cli-mode-name': u'police-remark-profile-$(profile-name)'}}), is_container='list', yang_name="police-remark-profile", rest_name="police-remark-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure police remark profile', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'police_remark_profile', u'cli-mode-name': u'police-remark-profile-$(profile-name)'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)
    self.__policy_map = YANGDynClass(base=YANGListType("name",policy_map.policy_map, yang_name="policy-map", rest_name="policy-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}), is_container='list', yang_name="policy-map", rest_name="policy-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_police_remark_profile(self):
    """
    Getter method for police_remark_profile, mapped from YANG variable /police_remark_profile (list)
    """
    return self.__police_remark_profile
      
  def _set_police_remark_profile(self, v, load=False):
    """
    Setter method for police_remark_profile, mapped from YANG variable /police_remark_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_police_remark_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_police_remark_profile() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("profile_name",police_remark_profile.police_remark_profile, yang_name="police-remark-profile", rest_name="police-remark-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Configure police remark profile', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'police_remark_profile', u'cli-mode-name': u'police-remark-profile-$(profile-name)'}}), is_container='list', yang_name="police-remark-profile", rest_name="police-remark-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure police remark profile', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'police_remark_profile', u'cli-mode-name': u'police-remark-profile-$(profile-name)'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """police_remark_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("profile_name",police_remark_profile.police_remark_profile, yang_name="police-remark-profile", rest_name="police-remark-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Configure police remark profile', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'police_remark_profile', u'cli-mode-name': u'police-remark-profile-$(profile-name)'}}), is_container='list', yang_name="police-remark-profile", rest_name="police-remark-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure police remark profile', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'police_remark_profile', u'cli-mode-name': u'police-remark-profile-$(profile-name)'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)""",
        })

    self.__police_remark_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_police_remark_profile(self):
    self.__police_remark_profile = YANGDynClass(base=YANGListType("profile_name",police_remark_profile.police_remark_profile, yang_name="police-remark-profile", rest_name="police-remark-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Configure police remark profile', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'police_remark_profile', u'cli-mode-name': u'police-remark-profile-$(profile-name)'}}), is_container='list', yang_name="police-remark-profile", rest_name="police-remark-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure police remark profile', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'police_remark_profile', u'cli-mode-name': u'police-remark-profile-$(profile-name)'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)


  def _get_class_map(self):
    """
    Getter method for class_map, mapped from YANG variable /class_map (list)
    """
    return self.__class_map
      
  def _set_class_map(self, v, load=False):
    """
    Setter method for class_map, mapped from YANG variable /class_map (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_class_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_class_map() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",class_map.class_map, yang_name="class-map", rest_name="class-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}), is_container='list', yang_name="class-map", rest_name="class-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """class_map must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",class_map.class_map, yang_name="class-map", rest_name="class-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}), is_container='list', yang_name="class-map", rest_name="class-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)""",
        })

    self.__class_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_class_map(self):
    self.__class_map = YANGDynClass(base=YANGListType("name",class_map.class_map, yang_name="class-map", rest_name="class-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}), is_container='list', yang_name="class-map", rest_name="class-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)


  def _get_policy_map(self):
    """
    Getter method for policy_map, mapped from YANG variable /policy_map (list)
    """
    return self.__policy_map
      
  def _set_policy_map(self, v, load=False):
    """
    Setter method for policy_map, mapped from YANG variable /policy_map (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_map() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",policy_map.policy_map, yang_name="policy-map", rest_name="policy-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}), is_container='list', yang_name="policy-map", rest_name="policy-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_map must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",policy_map.policy_map, yang_name="policy-map", rest_name="policy-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}), is_container='list', yang_name="policy-map", rest_name="policy-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)""",
        })

    self.__policy_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_map(self):
    self.__policy_map = YANGDynClass(base=YANGListType("name",policy_map.policy_map, yang_name="policy-map", rest_name="policy-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}), is_container='list', yang_name="policy-map", rest_name="policy-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'74', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)


  def _get_system_qos(self):
    """
    Getter method for system_qos, mapped from YANG variable /system_qos (container)
    """
    return self.__system_qos
      
  def _set_system_qos(self, v, load=False):
    """
    Setter method for system_qos, mapped from YANG variable /system_qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_qos() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system_qos.system_qos, is_container='container', presence=False, yang_name="system-qos", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'76'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system_qos.system_qos, is_container='container', presence=False, yang_name="system-qos", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'76'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='container', is_config=True)""",
        })

    self.__system_qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_qos(self):
    self.__system_qos = YANGDynClass(base=system_qos.system_qos, is_container='container', presence=False, yang_name="system-qos", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'76'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='container', is_config=True)

  police_remark_profile = __builtin__.property(_get_police_remark_profile, _set_police_remark_profile)
  class_map = __builtin__.property(_get_class_map, _set_class_map)
  policy_map = __builtin__.property(_get_policy_map, _set_policy_map)
  system_qos = __builtin__.property(_get_system_qos, _set_system_qos)


  _pyangbind_elements = {'police_remark_profile': police_remark_profile, 'class_map': class_map, 'policy_map': policy_map, 'system_qos': system_qos, }


import cpu_cfg_state
import cpu_info_state
import dscp_exp_state
import exp_dscp_state
import exp_traffic_class_state
import traffic_class_exp_state
class brocade_qos_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-operational - based on the path /brocade-qos-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage qos
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cpu_cfg_state','__cpu_info_state','__dscp_exp_state','__exp_dscp_state','__exp_traffic_class_state','__traffic_class_exp_state',)

  _yang_name = 'brocade-qos-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cpu_cfg_state = YANGDynClass(base=cpu_cfg_state.cpu_cfg_state, is_container='container', presence=False, yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    self.__traffic_class_exp_state = YANGDynClass(base=traffic_class_exp_state.traffic_class_exp_state, is_container='container', presence=False, yang_name="traffic-class-exp-state", rest_name="traffic-class-exp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-traffic-class-exp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    self.__exp_traffic_class_state = YANGDynClass(base=exp_traffic_class_state.exp_traffic_class_state, is_container='container', presence=False, yang_name="exp-traffic-class-state", rest_name="exp-traffic-class-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-exp-traffic-class', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    self.__exp_dscp_state = YANGDynClass(base=exp_dscp_state.exp_dscp_state, is_container='container', presence=False, yang_name="exp-dscp-state", rest_name="exp-dscp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-exp-dscp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    self.__cpu_info_state = YANGDynClass(base=cpu_info_state.cpu_info_state, is_container='container', presence=False, yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    self.__dscp_exp_state = YANGDynClass(base=dscp_exp_state.dscp_exp_state, is_container='container', presence=False, yang_name="dscp-exp-state", rest_name="dscp-exp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-dscp-exp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_cpu_cfg_state(self):
    """
    Getter method for cpu_cfg_state, mapped from YANG variable /cpu_cfg_state (container)

    YANG Description: QoS CPU config info
    """
    return self.__cpu_cfg_state
      
  def _set_cpu_cfg_state(self, v, load=False):
    """
    Setter method for cpu_cfg_state, mapped from YANG variable /cpu_cfg_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_cfg_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_cfg_state() directly.

    YANG Description: QoS CPU config info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cpu_cfg_state.cpu_cfg_state, is_container='container', presence=False, yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_cfg_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cpu_cfg_state.cpu_cfg_state, is_container='container', presence=False, yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)""",
        })

    self.__cpu_cfg_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_cfg_state(self):
    self.__cpu_cfg_state = YANGDynClass(base=cpu_cfg_state.cpu_cfg_state, is_container='container', presence=False, yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)


  def _get_cpu_info_state(self):
    """
    Getter method for cpu_info_state, mapped from YANG variable /cpu_info_state (container)

    YANG Description: QoS CPU info
    """
    return self.__cpu_info_state
      
  def _set_cpu_info_state(self, v, load=False):
    """
    Setter method for cpu_info_state, mapped from YANG variable /cpu_info_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_info_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_info_state() directly.

    YANG Description: QoS CPU info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cpu_info_state.cpu_info_state, is_container='container', presence=False, yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_info_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cpu_info_state.cpu_info_state, is_container='container', presence=False, yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)""",
        })

    self.__cpu_info_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_info_state(self):
    self.__cpu_info_state = YANGDynClass(base=cpu_info_state.cpu_info_state, is_container='container', presence=False, yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)


  def _get_dscp_exp_state(self):
    """
    Getter method for dscp_exp_state, mapped from YANG variable /dscp_exp_state (container)

    YANG Description: dscp_exp
    """
    return self.__dscp_exp_state
      
  def _set_dscp_exp_state(self, v, load=False):
    """
    Setter method for dscp_exp_state, mapped from YANG variable /dscp_exp_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dscp_exp_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dscp_exp_state() directly.

    YANG Description: dscp_exp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=dscp_exp_state.dscp_exp_state, is_container='container', presence=False, yang_name="dscp-exp-state", rest_name="dscp-exp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-dscp-exp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dscp_exp_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dscp_exp_state.dscp_exp_state, is_container='container', presence=False, yang_name="dscp-exp-state", rest_name="dscp-exp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-dscp-exp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)""",
        })

    self.__dscp_exp_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dscp_exp_state(self):
    self.__dscp_exp_state = YANGDynClass(base=dscp_exp_state.dscp_exp_state, is_container='container', presence=False, yang_name="dscp-exp-state", rest_name="dscp-exp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-dscp-exp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)


  def _get_exp_dscp_state(self):
    """
    Getter method for exp_dscp_state, mapped from YANG variable /exp_dscp_state (container)

    YANG Description: exp_dscp
    """
    return self.__exp_dscp_state
      
  def _set_exp_dscp_state(self, v, load=False):
    """
    Setter method for exp_dscp_state, mapped from YANG variable /exp_dscp_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exp_dscp_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exp_dscp_state() directly.

    YANG Description: exp_dscp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=exp_dscp_state.exp_dscp_state, is_container='container', presence=False, yang_name="exp-dscp-state", rest_name="exp-dscp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-exp-dscp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exp_dscp_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=exp_dscp_state.exp_dscp_state, is_container='container', presence=False, yang_name="exp-dscp-state", rest_name="exp-dscp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-exp-dscp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)""",
        })

    self.__exp_dscp_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exp_dscp_state(self):
    self.__exp_dscp_state = YANGDynClass(base=exp_dscp_state.exp_dscp_state, is_container='container', presence=False, yang_name="exp-dscp-state", rest_name="exp-dscp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-exp-dscp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)


  def _get_exp_traffic_class_state(self):
    """
    Getter method for exp_traffic_class_state, mapped from YANG variable /exp_traffic_class_state (container)

    YANG Description: exp_traffic_class
    """
    return self.__exp_traffic_class_state
      
  def _set_exp_traffic_class_state(self, v, load=False):
    """
    Setter method for exp_traffic_class_state, mapped from YANG variable /exp_traffic_class_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exp_traffic_class_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exp_traffic_class_state() directly.

    YANG Description: exp_traffic_class
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=exp_traffic_class_state.exp_traffic_class_state, is_container='container', presence=False, yang_name="exp-traffic-class-state", rest_name="exp-traffic-class-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-exp-traffic-class', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exp_traffic_class_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=exp_traffic_class_state.exp_traffic_class_state, is_container='container', presence=False, yang_name="exp-traffic-class-state", rest_name="exp-traffic-class-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-exp-traffic-class', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)""",
        })

    self.__exp_traffic_class_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exp_traffic_class_state(self):
    self.__exp_traffic_class_state = YANGDynClass(base=exp_traffic_class_state.exp_traffic_class_state, is_container='container', presence=False, yang_name="exp-traffic-class-state", rest_name="exp-traffic-class-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-exp-traffic-class', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)


  def _get_traffic_class_exp_state(self):
    """
    Getter method for traffic_class_exp_state, mapped from YANG variable /traffic_class_exp_state (container)

    YANG Description: traffic_class_exp
    """
    return self.__traffic_class_exp_state
      
  def _set_traffic_class_exp_state(self, v, load=False):
    """
    Setter method for traffic_class_exp_state, mapped from YANG variable /traffic_class_exp_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_class_exp_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_class_exp_state() directly.

    YANG Description: traffic_class_exp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=traffic_class_exp_state.traffic_class_exp_state, is_container='container', presence=False, yang_name="traffic-class-exp-state", rest_name="traffic-class-exp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-traffic-class-exp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_class_exp_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=traffic_class_exp_state.traffic_class_exp_state, is_container='container', presence=False, yang_name="traffic-class-exp-state", rest_name="traffic-class-exp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-traffic-class-exp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)""",
        })

    self.__traffic_class_exp_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_class_exp_state(self):
    self.__traffic_class_exp_state = YANGDynClass(base=traffic_class_exp_state.traffic_class_exp_state, is_container='container', presence=False, yang_name="traffic-class-exp-state", rest_name="traffic-class-exp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-traffic-class-exp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='container', is_config=True)

  cpu_cfg_state = __builtin__.property(_get_cpu_cfg_state, _set_cpu_cfg_state)
  cpu_info_state = __builtin__.property(_get_cpu_info_state, _set_cpu_info_state)
  dscp_exp_state = __builtin__.property(_get_dscp_exp_state, _set_dscp_exp_state)
  exp_dscp_state = __builtin__.property(_get_exp_dscp_state, _set_exp_dscp_state)
  exp_traffic_class_state = __builtin__.property(_get_exp_traffic_class_state, _set_exp_traffic_class_state)
  traffic_class_exp_state = __builtin__.property(_get_traffic_class_exp_state, _set_traffic_class_exp_state)


  _pyangbind_elements = {'cpu_cfg_state': cpu_cfg_state, 'cpu_info_state': cpu_info_state, 'dscp_exp_state': dscp_exp_state, 'exp_dscp_state': exp_dscp_state, 'exp_traffic_class_state': exp_traffic_class_state, 'traffic_class_exp_state': traffic_class_exp_state, }


class brocade_port_profile_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-port-profile-ext - based on the path /brocade-port-profile-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an extension to the port-profile
model for 
   - Defining RPCs to retrieve port-profile related operational
     data in the managed device.
  """
  _pyangbind_elements = {}

  

class brocade_ipv6_nd_ra(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ipv6-nd-ra - based on the path /brocade-ipv6-nd-ra. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
for Neighbor Discovery and Router Advertisement.
  """
  _pyangbind_elements = {}

  

import adj_neighbor_entries_state
import counts_state
import isis_state
import traffic_state
import spf_log_state
class brocade_isis_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-isis-operational - based on the path /brocade-isis-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage isis
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__adj_neighbor_entries_state','__counts_state','__isis_state','__traffic_state','__spf_log_state',)

  _yang_name = 'brocade-isis-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__isis_state = YANGDynClass(base=isis_state.isis_state, is_container='container', presence=False, yang_name="isis-state", rest_name="isis-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-isis', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    self.__traffic_state = YANGDynClass(base=traffic_state.traffic_state, is_container='container', presence=False, yang_name="traffic-state", rest_name="traffic-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-traffic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    self.__counts_state = YANGDynClass(base=counts_state.counts_state, is_container='container', presence=False, yang_name="counts-state", rest_name="counts-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-counts', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    self.__adj_neighbor_entries_state = YANGDynClass(base=adj_neighbor_entries_state.adj_neighbor_entries_state, is_container='container', presence=False, yang_name="adj-neighbor-entries-state", rest_name="adj-neighbor-entries-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-adj-neighbor-entries', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    self.__spf_log_state = YANGDynClass(base=YANGListType("spf_log_version",spf_log_state.spf_log_state, yang_name="spf-log-state", rest_name="spf-log-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='spf-log-version', extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}), is_container='list', yang_name="spf-log-state", rest_name="spf-log-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_adj_neighbor_entries_state(self):
    """
    Getter method for adj_neighbor_entries_state, mapped from YANG variable /adj_neighbor_entries_state (container)

    YANG Description: ISIS Adjacency Neighbor Entries
    """
    return self.__adj_neighbor_entries_state
      
  def _set_adj_neighbor_entries_state(self, v, load=False):
    """
    Setter method for adj_neighbor_entries_state, mapped from YANG variable /adj_neighbor_entries_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_neighbor_entries_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_neighbor_entries_state() directly.

    YANG Description: ISIS Adjacency Neighbor Entries
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=adj_neighbor_entries_state.adj_neighbor_entries_state, is_container='container', presence=False, yang_name="adj-neighbor-entries-state", rest_name="adj-neighbor-entries-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-adj-neighbor-entries', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_neighbor_entries_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=adj_neighbor_entries_state.adj_neighbor_entries_state, is_container='container', presence=False, yang_name="adj-neighbor-entries-state", rest_name="adj-neighbor-entries-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-adj-neighbor-entries', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)""",
        })

    self.__adj_neighbor_entries_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_neighbor_entries_state(self):
    self.__adj_neighbor_entries_state = YANGDynClass(base=adj_neighbor_entries_state.adj_neighbor_entries_state, is_container='container', presence=False, yang_name="adj-neighbor-entries-state", rest_name="adj-neighbor-entries-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-adj-neighbor-entries', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)


  def _get_counts_state(self):
    """
    Getter method for counts_state, mapped from YANG variable /counts_state (container)

    YANG Description: IS-IS Counters
    """
    return self.__counts_state
      
  def _set_counts_state(self, v, load=False):
    """
    Setter method for counts_state, mapped from YANG variable /counts_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counts_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counts_state() directly.

    YANG Description: IS-IS Counters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counts_state.counts_state, is_container='container', presence=False, yang_name="counts-state", rest_name="counts-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-counts', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counts_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counts_state.counts_state, is_container='container', presence=False, yang_name="counts-state", rest_name="counts-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-counts', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)""",
        })

    self.__counts_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counts_state(self):
    self.__counts_state = YANGDynClass(base=counts_state.counts_state, is_container='container', presence=False, yang_name="counts-state", rest_name="counts-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-counts', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)


  def _get_isis_state(self):
    """
    Getter method for isis_state, mapped from YANG variable /isis_state (container)

    YANG Description: ISIS Operational Information
    """
    return self.__isis_state
      
  def _set_isis_state(self, v, load=False):
    """
    Setter method for isis_state, mapped from YANG variable /isis_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isis_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isis_state() directly.

    YANG Description: ISIS Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=isis_state.isis_state, is_container='container', presence=False, yang_name="isis-state", rest_name="isis-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-isis', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isis_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=isis_state.isis_state, is_container='container', presence=False, yang_name="isis-state", rest_name="isis-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-isis', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)""",
        })

    self.__isis_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isis_state(self):
    self.__isis_state = YANGDynClass(base=isis_state.isis_state, is_container='container', presence=False, yang_name="isis-state", rest_name="isis-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-isis', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)


  def _get_traffic_state(self):
    """
    Getter method for traffic_state, mapped from YANG variable /traffic_state (container)

    YANG Description: IS-IS packet counts
    """
    return self.__traffic_state
      
  def _set_traffic_state(self, v, load=False):
    """
    Setter method for traffic_state, mapped from YANG variable /traffic_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_state() directly.

    YANG Description: IS-IS packet counts
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=traffic_state.traffic_state, is_container='container', presence=False, yang_name="traffic-state", rest_name="traffic-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-traffic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=traffic_state.traffic_state, is_container='container', presence=False, yang_name="traffic-state", rest_name="traffic-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-traffic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)""",
        })

    self.__traffic_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_state(self):
    self.__traffic_state = YANGDynClass(base=traffic_state.traffic_state, is_container='container', presence=False, yang_name="traffic-state", rest_name="traffic-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-traffic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)


  def _get_spf_log_state(self):
    """
    Getter method for spf_log_state, mapped from YANG variable /spf_log_state (list)

    YANG Description: ISIS IPv4 or IPv6 SPF LOG information
    """
    return self.__spf_log_state
      
  def _set_spf_log_state(self, v, load=False):
    """
    Setter method for spf_log_state, mapped from YANG variable /spf_log_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spf_log_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spf_log_state() directly.

    YANG Description: ISIS IPv4 or IPv6 SPF LOG information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("spf_log_version",spf_log_state.spf_log_state, yang_name="spf-log-state", rest_name="spf-log-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='spf-log-version', extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}), is_container='list', yang_name="spf-log-state", rest_name="spf-log-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spf_log_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("spf_log_version",spf_log_state.spf_log_state, yang_name="spf-log-state", rest_name="spf-log-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='spf-log-version', extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}), is_container='list', yang_name="spf-log-state", rest_name="spf-log-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='list', is_config=True)""",
        })

    self.__spf_log_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spf_log_state(self):
    self.__spf_log_state = YANGDynClass(base=YANGListType("spf_log_version",spf_log_state.spf_log_state, yang_name="spf-log-state", rest_name="spf-log-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='spf-log-version', extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}), is_container='list', yang_name="spf-log-state", rest_name="spf-log-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='list', is_config=True)

  adj_neighbor_entries_state = __builtin__.property(_get_adj_neighbor_entries_state, _set_adj_neighbor_entries_state)
  counts_state = __builtin__.property(_get_counts_state, _set_counts_state)
  isis_state = __builtin__.property(_get_isis_state, _set_isis_state)
  traffic_state = __builtin__.property(_get_traffic_state, _set_traffic_state)
  spf_log_state = __builtin__.property(_get_spf_log_state, _set_spf_log_state)


  _pyangbind_elements = {'adj_neighbor_entries_state': adj_neighbor_entries_state, 'counts_state': counts_state, 'isis_state': isis_state, 'traffic_state': traffic_state, 'spf_log_state': spf_log_state, }


import overlay
import overlay_transit
class brocade_vxlan_visibility(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vxlan-visibility - based on the path /brocade-vxlan-visibility. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages VxLan Visibility commands
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__overlay','__overlay_transit',)

  _yang_name = 'brocade-vxlan-visibility'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__overlay_transit = YANGDynClass(base=YANGListType("user_transit_name",overlay_transit.overlay_transit, yang_name="overlay-transit", rest_name="overlay-transit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='user-transit-name', extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'hidden': u'full', u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-sequence-commands': None, u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}), is_container='list', yang_name="overlay-transit", rest_name="overlay-transit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'hidden': u'full', u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-sequence-commands': None, u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='list', is_config=True)
    self.__overlay = YANGDynClass(base=overlay.overlay, is_container='container', presence=False, yang_name="overlay", rest_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay', u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_overlay(self):
    """
    Getter method for overlay, mapped from YANG variable /overlay (container)
    """
    return self.__overlay
      
  def _set_overlay(self, v, load=False):
    """
    Setter method for overlay, mapped from YANG variable /overlay (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overlay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overlay() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=overlay.overlay, is_container='container', presence=False, yang_name="overlay", rest_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay', u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overlay must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=overlay.overlay, is_container='container', presence=False, yang_name="overlay", rest_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay', u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='container', is_config=True)""",
        })

    self.__overlay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overlay(self):
    self.__overlay = YANGDynClass(base=overlay.overlay, is_container='container', presence=False, yang_name="overlay", rest_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay', u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='container', is_config=True)


  def _get_overlay_transit(self):
    """
    Getter method for overlay_transit, mapped from YANG variable /overlay_transit (list)
    """
    return self.__overlay_transit
      
  def _set_overlay_transit(self, v, load=False):
    """
    Setter method for overlay_transit, mapped from YANG variable /overlay_transit (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overlay_transit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overlay_transit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("user_transit_name",overlay_transit.overlay_transit, yang_name="overlay-transit", rest_name="overlay-transit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='user-transit-name', extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'hidden': u'full', u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-sequence-commands': None, u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}), is_container='list', yang_name="overlay-transit", rest_name="overlay-transit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'hidden': u'full', u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-sequence-commands': None, u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overlay_transit must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("user_transit_name",overlay_transit.overlay_transit, yang_name="overlay-transit", rest_name="overlay-transit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='user-transit-name', extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'hidden': u'full', u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-sequence-commands': None, u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}), is_container='list', yang_name="overlay-transit", rest_name="overlay-transit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'hidden': u'full', u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-sequence-commands': None, u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='list', is_config=True)""",
        })

    self.__overlay_transit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overlay_transit(self):
    self.__overlay_transit = YANGDynClass(base=YANGListType("user_transit_name",overlay_transit.overlay_transit, yang_name="overlay-transit", rest_name="overlay-transit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='user-transit-name', extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'hidden': u'full', u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-sequence-commands': None, u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}), is_container='list', yang_name="overlay-transit", rest_name="overlay-transit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'hidden': u'full', u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-sequence-commands': None, u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='list', is_config=True)

  overlay = __builtin__.property(_get_overlay, _set_overlay)
  overlay_transit = __builtin__.property(_get_overlay_transit, _set_overlay_transit)


  _pyangbind_elements = {'overlay': overlay, 'overlay_transit': overlay_transit, }


class brocade_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bfd - based on the path /brocade-bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage BFD.
  """
  _pyangbind_elements = {}

  

import vlan
class brocade_vlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vlan - based on the path /brocade-vlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule manages VLAN related CLIs.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vlan',)

  _yang_name = 'brocade-vlan'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vlan = YANGDynClass(base=vlan.vlan, is_container='container', presence=False, yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Vlan commands', u'cli-incomplete-no': None, u'sort-priority': u'55', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-vlan', defining_module='brocade-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /vlan (container)
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vlan.vlan, is_container='container', presence=False, yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Vlan commands', u'cli-incomplete-no': None, u'sort-priority': u'55', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-vlan', defining_module='brocade-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vlan.vlan, is_container='container', presence=False, yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Vlan commands', u'cli-incomplete-no': None, u'sort-priority': u'55', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-vlan', defining_module='brocade-vlan', yang_type='container', is_config=True)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=vlan.vlan, is_container='container', presence=False, yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Vlan commands', u'cli-incomplete-no': None, u'sort-priority': u'55', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-vlan', defining_module='brocade-vlan', yang_type='container', is_config=True)

  vlan = __builtin__.property(_get_vlan, _set_vlan)


  _pyangbind_elements = {'vlan': vlan, }


import nsx_controller
import overlay_gateway
import ovsdb_server
import tunnel_settings
class brocade_tunnels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-tunnels - based on the path /brocade-tunnels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the IP
tunnels.

Glossary of the terms used:
---------------------------
VXLAN       Virtual eXtensible Local Area Network. See internet
           draft draft-mahalingam-dutt-dcops-vxlan-03.
VXLAN Gateway
           Software module in Brocade VCS switch which forwards
           traffic between VXLAN and non-VXLAN environments.
NSX         NSX is a network virtualization platform solution
           by Vmware. Refer - www.vmware.com/in/products/nsx
NSX Controller
           NSX Controller is the cluster of x86 systems which
           manage the virtual networks.
TCP         Transmission Control Protocol (RFC 793)
SSL         Secure Sockets Layer Protocol (RFC 6101)
BFD         Bidirectional Forwarding Detection (RFC 5880)


  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__nsx_controller','__overlay_gateway','__ovsdb_server','__tunnel_settings',)

  _yang_name = 'brocade-tunnels'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__nsx_controller = YANGDynClass(base=YANGListType("name",nsx_controller.nsx_controller, yang_name="nsx-controller", rest_name="nsx-controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'cli-full-command': None, u'cli-suppress-list-no': None, u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'callpoint': u'nvp-controller-config'}}), is_container='list', yang_name="nsx-controller", rest_name="nsx-controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'cli-suppress-list-no': None, u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'callpoint': u'nvp-controller-config'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    self.__tunnel_settings = YANGDynClass(base=tunnel_settings.tunnel_settings, is_container='container', presence=False, yang_name="tunnel-settings", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='container', is_config=True)
    self.__overlay_gateway = YANGDynClass(base=YANGListType("name",overlay_gateway.overlay_gateway, yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'TunnelsGwCallpoint', u'cli-mode-name': u'config-overlay-gw-$(name)'}}), is_container='list', yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'TunnelsGwCallpoint', u'cli-mode-name': u'config-overlay-gw-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    self.__ovsdb_server = YANGDynClass(base=YANGListType("name",ovsdb_server.ovsdb_server, yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}), is_container='list', yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_nsx_controller(self):
    """
    Getter method for nsx_controller, mapped from YANG variable /nsx_controller (list)
    """
    return self.__nsx_controller
      
  def _set_nsx_controller(self, v, load=False):
    """
    Setter method for nsx_controller, mapped from YANG variable /nsx_controller (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsx_controller is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsx_controller() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",nsx_controller.nsx_controller, yang_name="nsx-controller", rest_name="nsx-controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'cli-full-command': None, u'cli-suppress-list-no': None, u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'callpoint': u'nvp-controller-config'}}), is_container='list', yang_name="nsx-controller", rest_name="nsx-controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'cli-suppress-list-no': None, u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'callpoint': u'nvp-controller-config'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsx_controller must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",nsx_controller.nsx_controller, yang_name="nsx-controller", rest_name="nsx-controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'cli-full-command': None, u'cli-suppress-list-no': None, u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'callpoint': u'nvp-controller-config'}}), is_container='list', yang_name="nsx-controller", rest_name="nsx-controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'cli-suppress-list-no': None, u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'callpoint': u'nvp-controller-config'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)""",
        })

    self.__nsx_controller = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsx_controller(self):
    self.__nsx_controller = YANGDynClass(base=YANGListType("name",nsx_controller.nsx_controller, yang_name="nsx-controller", rest_name="nsx-controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'cli-full-command': None, u'cli-suppress-list-no': None, u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'callpoint': u'nvp-controller-config'}}), is_container='list', yang_name="nsx-controller", rest_name="nsx-controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'cli-suppress-list-no': None, u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'callpoint': u'nvp-controller-config'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)


  def _get_overlay_gateway(self):
    """
    Getter method for overlay_gateway, mapped from YANG variable /overlay_gateway (list)
    """
    return self.__overlay_gateway
      
  def _set_overlay_gateway(self, v, load=False):
    """
    Setter method for overlay_gateway, mapped from YANG variable /overlay_gateway (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overlay_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overlay_gateway() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",overlay_gateway.overlay_gateway, yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'TunnelsGwCallpoint', u'cli-mode-name': u'config-overlay-gw-$(name)'}}), is_container='list', yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'TunnelsGwCallpoint', u'cli-mode-name': u'config-overlay-gw-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overlay_gateway must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",overlay_gateway.overlay_gateway, yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'TunnelsGwCallpoint', u'cli-mode-name': u'config-overlay-gw-$(name)'}}), is_container='list', yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'TunnelsGwCallpoint', u'cli-mode-name': u'config-overlay-gw-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)""",
        })

    self.__overlay_gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overlay_gateway(self):
    self.__overlay_gateway = YANGDynClass(base=YANGListType("name",overlay_gateway.overlay_gateway, yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'TunnelsGwCallpoint', u'cli-mode-name': u'config-overlay-gw-$(name)'}}), is_container='list', yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'TunnelsGwCallpoint', u'cli-mode-name': u'config-overlay-gw-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)


  def _get_ovsdb_server(self):
    """
    Getter method for ovsdb_server, mapped from YANG variable /ovsdb_server (list)
    """
    return self.__ovsdb_server
      
  def _set_ovsdb_server(self, v, load=False):
    """
    Setter method for ovsdb_server, mapped from YANG variable /ovsdb_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ovsdb_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ovsdb_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",ovsdb_server.ovsdb_server, yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}), is_container='list', yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ovsdb_server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",ovsdb_server.ovsdb_server, yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}), is_container='list', yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)""",
        })

    self.__ovsdb_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ovsdb_server(self):
    self.__ovsdb_server = YANGDynClass(base=YANGListType("name",ovsdb_server.ovsdb_server, yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}), is_container='list', yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)


  def _get_tunnel_settings(self):
    """
    Getter method for tunnel_settings, mapped from YANG variable /tunnel_settings (container)

    YANG Description: Tunnel related internal settings
    """
    return self.__tunnel_settings
      
  def _set_tunnel_settings(self, v, load=False):
    """
    Setter method for tunnel_settings, mapped from YANG variable /tunnel_settings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_settings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_settings() directly.

    YANG Description: Tunnel related internal settings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=tunnel_settings.tunnel_settings, is_container='container', presence=False, yang_name="tunnel-settings", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_settings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tunnel_settings.tunnel_settings, is_container='container', presence=False, yang_name="tunnel-settings", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='container', is_config=True)""",
        })

    self.__tunnel_settings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_settings(self):
    self.__tunnel_settings = YANGDynClass(base=tunnel_settings.tunnel_settings, is_container='container', presence=False, yang_name="tunnel-settings", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='container', is_config=True)

  nsx_controller = __builtin__.property(_get_nsx_controller, _set_nsx_controller)
  overlay_gateway = __builtin__.property(_get_overlay_gateway, _set_overlay_gateway)
  ovsdb_server = __builtin__.property(_get_ovsdb_server, _set_ovsdb_server)
  tunnel_settings = __builtin__.property(_get_tunnel_settings, _set_tunnel_settings)


  _pyangbind_elements = {'nsx_controller': nsx_controller, 'overlay_gateway': overlay_gateway, 'ovsdb_server': ovsdb_server, 'tunnel_settings': tunnel_settings, }


class brocade_ipv6_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ipv6-config - based on the path /brocade-ipv6-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for IP Access-list.
  """
  _pyangbind_elements = {}

  

class brocade_qos_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-cpu - based on the path /brocade-qos-cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages CPU Quality Of Service (QOS)
  """
  _pyangbind_elements = {}

  

import port_channel_redundancy_group
class brocade_lag(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lag - based on the path /brocade-lag. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module is an instrumentation to manage Link
aggregation or IEEE 802.1AX-2008 feature.

Glossary of the terms used:
--------------------------
LAG - Link Aggregation.
LACP - Link Aggregation Control Protocol
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__port_channel_redundancy_group',)

  _yang_name = 'brocade-lag'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__port_channel_redundancy_group = YANGDynClass(base=YANGListType("group_id",port_channel_redundancy_group.port_channel_redundancy_group, yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'102', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}), is_container='list', yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'102', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}, namespace='urn:brocade.com:mgmt:brocade-lag', defining_module='brocade-lag', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_port_channel_redundancy_group(self):
    """
    Getter method for port_channel_redundancy_group, mapped from YANG variable /port_channel_redundancy_group (list)

    YANG Description: The list of port-channel redundancy groups in a managed device.
Each entry represents a port-channel-redundancy-group.
    """
    return self.__port_channel_redundancy_group
      
  def _set_port_channel_redundancy_group(self, v, load=False):
    """
    Setter method for port_channel_redundancy_group, mapped from YANG variable /port_channel_redundancy_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_channel_redundancy_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_channel_redundancy_group() directly.

    YANG Description: The list of port-channel redundancy groups in a managed device.
Each entry represents a port-channel-redundancy-group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("group_id",port_channel_redundancy_group.port_channel_redundancy_group, yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'102', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}), is_container='list', yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'102', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}, namespace='urn:brocade.com:mgmt:brocade-lag', defining_module='brocade-lag', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_channel_redundancy_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("group_id",port_channel_redundancy_group.port_channel_redundancy_group, yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'102', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}), is_container='list', yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'102', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}, namespace='urn:brocade.com:mgmt:brocade-lag', defining_module='brocade-lag', yang_type='list', is_config=True)""",
        })

    self.__port_channel_redundancy_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_channel_redundancy_group(self):
    self.__port_channel_redundancy_group = YANGDynClass(base=YANGListType("group_id",port_channel_redundancy_group.port_channel_redundancy_group, yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'102', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}), is_container='list', yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'102', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}, namespace='urn:brocade.com:mgmt:brocade-lag', defining_module='brocade-lag', yang_type='list', is_config=True)

  port_channel_redundancy_group = __builtin__.property(_get_port_channel_redundancy_group, _set_port_channel_redundancy_group)


  _pyangbind_elements = {'port_channel_redundancy_group': port_channel_redundancy_group, }


import telnet_sa
import ssh_sa
class brocade_sec_services(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-sec-services - based on the path /brocade-sec-services. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Instrument to configure Telnet Server and SSH Server
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__telnet_sa','__ssh_sa',)

  _yang_name = 'brocade-sec-services'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__telnet_sa = YANGDynClass(base=telnet_sa.telnet_sa, is_container='container', presence=False, yang_name="telnet-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_TELNET_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)
    self.__ssh_sa = YANGDynClass(base=ssh_sa.ssh_sa, is_container='container', presence=False, yang_name="ssh-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_SSH_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_telnet_sa(self):
    """
    Getter method for telnet_sa, mapped from YANG variable /telnet_sa (container)
    """
    return self.__telnet_sa
      
  def _set_telnet_sa(self, v, load=False):
    """
    Setter method for telnet_sa, mapped from YANG variable /telnet_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telnet_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telnet_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=telnet_sa.telnet_sa, is_container='container', presence=False, yang_name="telnet-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_TELNET_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telnet_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=telnet_sa.telnet_sa, is_container='container', presence=False, yang_name="telnet-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_TELNET_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)""",
        })

    self.__telnet_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telnet_sa(self):
    self.__telnet_sa = YANGDynClass(base=telnet_sa.telnet_sa, is_container='container', presence=False, yang_name="telnet-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_TELNET_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)


  def _get_ssh_sa(self):
    """
    Getter method for ssh_sa, mapped from YANG variable /ssh_sa (container)
    """
    return self.__ssh_sa
      
  def _set_ssh_sa(self, v, load=False):
    """
    Setter method for ssh_sa, mapped from YANG variable /ssh_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ssh_sa.ssh_sa, is_container='container', presence=False, yang_name="ssh-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_SSH_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ssh_sa.ssh_sa, is_container='container', presence=False, yang_name="ssh-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_SSH_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)""",
        })

    self.__ssh_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_sa(self):
    self.__ssh_sa = YANGDynClass(base=ssh_sa.ssh_sa, is_container='container', presence=False, yang_name="ssh-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_SSH_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)

  telnet_sa = __builtin__.property(_get_telnet_sa, _set_telnet_sa)
  ssh_sa = __builtin__.property(_get_ssh_sa, _set_ssh_sa)


  _pyangbind_elements = {'telnet_sa': telnet_sa, 'ssh_sa': ssh_sa, }


import vcsmode
import local_node
import vcs
class brocade_vcs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vcs - based on the path /brocade-vcs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage  
Virtual Cluster Switching (VCS).
        
Glossary of the terms used:
--------------------------- 
VAL  - Virtual Access Layer, provided by VCS.
VCS  - Virtual Cluster Switching.
TRILL - Transparent Interconnection of Lot of Links.
TLS - Transparent LAN Services.
        
        
VCS refers to the ability of a group of physical Ethernet 
switches, inter-connected in arbitrary fashion via the regular 
front-end data ports, to present themselves as one unified and
transparent Ethernet switching service to the external network. 
The inter-connecting network that glues all these individual 
switches is refered as 'fabric', and the group of physical 
Ethernet switches in the fabric is refered to as 'cluster'. 
        
+--------+                                   +--------+
|External|                                   |External| 
|Non-VCS |                                   |Non-VCS |
|Switch  |                                   |Switch  |
+--------+                                   +--------+          
  |                                              |
  |                                              |
  |                                              |
+---+                                            |          
|   |                                            | 
|S1 |                                      ******************
+---+                                      * Logical Switch *  
  |<------ Fabric Port    \---->           *                *  
  |                       /---->           * (VCS Cluster)  *
+---+                                      ******************
|   |                                            |
|S2 |                                            |
+---+                                            |
  |<----- Edge Port                              |
  |                                              |
+-------+                                   +-------+
|Server |                                   |Server |
+-------+                                   +-------+

[Physical View]                            [Logical View]

As shown in the figure above, the fabric ports are transparent 
as far as the external devices connected to the VCS are 
concerned. In this sense the whole of the cluster behaves like 
a logical switch to the external network.         

  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vcsmode','__local_node','__vcs',)

  _yang_name = 'brocade-vcs'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__local_node = YANGDynClass(base=local_node.local_node, is_container='container', presence=False, yang_name="local-node", rest_name="local-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    self.__vcs = YANGDynClass(base=vcs.vcs, is_container='container', presence=False, yang_name="vcs", rest_name="vcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Virtual Cluster Switching Configuration', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    self.__vcsmode = YANGDynClass(base=vcsmode.vcsmode, is_container='container', presence=False, yang_name="vcsmode", rest_name="vcsmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vcsmode(self):
    """
    Getter method for vcsmode, mapped from YANG variable /vcsmode (container)
    """
    return self.__vcsmode
      
  def _set_vcsmode(self, v, load=False):
    """
    Setter method for vcsmode, mapped from YANG variable /vcsmode (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcsmode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcsmode() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vcsmode.vcsmode, is_container='container', presence=False, yang_name="vcsmode", rest_name="vcsmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcsmode must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vcsmode.vcsmode, is_container='container', presence=False, yang_name="vcsmode", rest_name="vcsmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)""",
        })

    self.__vcsmode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcsmode(self):
    self.__vcsmode = YANGDynClass(base=vcsmode.vcsmode, is_container='container', presence=False, yang_name="vcsmode", rest_name="vcsmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)


  def _get_local_node(self):
    """
    Getter method for local_node, mapped from YANG variable /local_node (container)
    """
    return self.__local_node
      
  def _set_local_node(self, v, load=False):
    """
    Setter method for local_node, mapped from YANG variable /local_node (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_node() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=local_node.local_node, is_container='container', presence=False, yang_name="local-node", rest_name="local-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_node must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=local_node.local_node, is_container='container', presence=False, yang_name="local-node", rest_name="local-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)""",
        })

    self.__local_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_node(self):
    self.__local_node = YANGDynClass(base=local_node.local_node, is_container='container', presence=False, yang_name="local-node", rest_name="local-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)


  def _get_vcs(self):
    """
    Getter method for vcs, mapped from YANG variable /vcs (container)
    """
    return self.__vcs
      
  def _set_vcs(self, v, load=False):
    """
    Setter method for vcs, mapped from YANG variable /vcs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vcs.vcs, is_container='container', presence=False, yang_name="vcs", rest_name="vcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Virtual Cluster Switching Configuration', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vcs.vcs, is_container='container', presence=False, yang_name="vcs", rest_name="vcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Virtual Cluster Switching Configuration', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)""",
        })

    self.__vcs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcs(self):
    self.__vcs = YANGDynClass(base=vcs.vcs, is_container='container', presence=False, yang_name="vcs", rest_name="vcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Virtual Cluster Switching Configuration', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)

  vcsmode = __builtin__.property(_get_vcsmode, _set_vcsmode)
  local_node = __builtin__.property(_get_local_node, _set_local_node)
  vcs = __builtin__.property(_get_vcs, _set_vcs)


  _pyangbind_elements = {'vcsmode': vcsmode, 'local_node': local_node, 'vcs': vcs, }


import vrf
class brocade_vrf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vrf - based on the path /brocade-vrf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages Virtual Routing and Forwarding (VRF)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vrf',)

  _yang_name = 'brocade-vrf'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vrf = YANGDynClass(base=YANGListType("vrf_name",vrf.vrf, yang_name="vrf", rest_name="vrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}), is_container='list', yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vrf', defining_module='brocade-vrf', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vrf(self):
    """
    Getter method for vrf, mapped from YANG variable /vrf (list)
    """
    return self.__vrf
      
  def _set_vrf(self, v, load=False):
    """
    Setter method for vrf, mapped from YANG variable /vrf (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vrf_name",vrf.vrf, yang_name="vrf", rest_name="vrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}), is_container='list', yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vrf', defining_module='brocade-vrf', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vrf_name",vrf.vrf, yang_name="vrf", rest_name="vrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}), is_container='list', yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vrf', defining_module='brocade-vrf', yang_type='list', is_config=True)""",
        })

    self.__vrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf(self):
    self.__vrf = YANGDynClass(base=YANGListType("vrf_name",vrf.vrf, yang_name="vrf", rest_name="vrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}), is_container='list', yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vrf', defining_module='brocade-vrf', yang_type='list', is_config=True)

  vrf = __builtin__.property(_get_vrf, _set_vrf)


  _pyangbind_elements = {'vrf': vrf, }


import monitor
class brocade_span(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-span - based on the path /brocade-span. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages Port Mirroring (SPAN)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__monitor',)

  _yang_name = 'brocade-span'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__monitor = YANGDynClass(base=monitor.monitor, is_container='container', presence=False, yang_name="monitor", rest_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Entering span sessions', u'cli-incomplete-no': None, u'callpoint': u'Span', u'sort-priority': u'RUNNCFG_LEVEL_SPAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-span', defining_module='brocade-span', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_monitor(self):
    """
    Getter method for monitor, mapped from YANG variable /monitor (container)
    """
    return self.__monitor
      
  def _set_monitor(self, v, load=False):
    """
    Setter method for monitor, mapped from YANG variable /monitor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=monitor.monitor, is_container='container', presence=False, yang_name="monitor", rest_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Entering span sessions', u'cli-incomplete-no': None, u'callpoint': u'Span', u'sort-priority': u'RUNNCFG_LEVEL_SPAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-span', defining_module='brocade-span', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=monitor.monitor, is_container='container', presence=False, yang_name="monitor", rest_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Entering span sessions', u'cli-incomplete-no': None, u'callpoint': u'Span', u'sort-priority': u'RUNNCFG_LEVEL_SPAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-span', defining_module='brocade-span', yang_type='container', is_config=True)""",
        })

    self.__monitor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor(self):
    self.__monitor = YANGDynClass(base=monitor.monitor, is_container='container', presence=False, yang_name="monitor", rest_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Entering span sessions', u'cli-incomplete-no': None, u'callpoint': u'Span', u'sort-priority': u'RUNNCFG_LEVEL_SPAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-span', defining_module='brocade-span', yang_type='container', is_config=True)

  monitor = __builtin__.property(_get_monitor, _set_monitor)


  _pyangbind_elements = {'monitor': monitor, }


class brocade_anycast_gateway(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-anycast-gateway - based on the path /brocade-anycast-gateway. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for anycast gateway
  """
  _pyangbind_elements = {}

  

import bridge_domain
class brocade_bridge_domain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bridge-domain - based on the path /brocade-bridge-domain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage Bridge-Domain .
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__bridge_domain',)

  _yang_name = 'brocade-bridge-domain'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__bridge_domain = YANGDynClass(base=YANGListType("bridge_domain_id bridge_domain_type",bridge_domain.bridge_domain, yang_name="bridge-domain", rest_name="bridge-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bridge-domain-id bridge-domain-type', extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_BRIDGE_DOMAIN', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}), is_container='list', yang_name="bridge-domain", rest_name="bridge-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_BRIDGE_DOMAIN', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_bridge_domain(self):
    """
    Getter method for bridge_domain, mapped from YANG variable /bridge_domain (list)
    """
    return self.__bridge_domain
      
  def _set_bridge_domain(self, v, load=False):
    """
    Setter method for bridge_domain, mapped from YANG variable /bridge_domain (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge_domain() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bridge_domain_id bridge_domain_type",bridge_domain.bridge_domain, yang_name="bridge-domain", rest_name="bridge-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bridge-domain-id bridge-domain-type', extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_BRIDGE_DOMAIN', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}), is_container='list', yang_name="bridge-domain", rest_name="bridge-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_BRIDGE_DOMAIN', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge_domain must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bridge_domain_id bridge_domain_type",bridge_domain.bridge_domain, yang_name="bridge-domain", rest_name="bridge-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bridge-domain-id bridge-domain-type', extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_BRIDGE_DOMAIN', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}), is_container='list', yang_name="bridge-domain", rest_name="bridge-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_BRIDGE_DOMAIN', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)""",
        })

    self.__bridge_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge_domain(self):
    self.__bridge_domain = YANGDynClass(base=YANGListType("bridge_domain_id bridge_domain_type",bridge_domain.bridge_domain, yang_name="bridge-domain", rest_name="bridge-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bridge-domain-id bridge-domain-type', extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_BRIDGE_DOMAIN', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}), is_container='list', yang_name="bridge-domain", rest_name="bridge-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_BRIDGE_DOMAIN', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)

  bridge_domain = __builtin__.property(_get_bridge_domain, _set_bridge_domain)


  _pyangbind_elements = {'bridge_domain': bridge_domain, }


import ip_acl
import acl_mirror
class brocade_ip_access_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-access-list - based on the path /brocade-ip-access-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for IP Access-list.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ip_acl','__acl_mirror',)

  _yang_name = 'brocade-ip-access-list'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__acl_mirror = YANGDynClass(base=acl_mirror.acl_mirror, is_container='container', presence=False, yang_name="acl-mirror", rest_name="acl-mirror", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Interface to be mirrored', u'cli-incomplete-no': None, u'hidden': u'full', u'callpoint': u'AclmirrorPort', u'sort-priority': u'148'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)
    self.__ip_acl = YANGDynClass(base=ip_acl.ip_acl, is_container='container', presence=False, yang_name="ip-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'46'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_ip_acl(self):
    """
    Getter method for ip_acl, mapped from YANG variable /ip_acl (container)
    """
    return self.__ip_acl
      
  def _set_ip_acl(self, v, load=False):
    """
    Setter method for ip_acl, mapped from YANG variable /ip_acl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_acl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_acl() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ip_acl.ip_acl, is_container='container', presence=False, yang_name="ip-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'46'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_acl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip_acl.ip_acl, is_container='container', presence=False, yang_name="ip-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'46'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)""",
        })

    self.__ip_acl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_acl(self):
    self.__ip_acl = YANGDynClass(base=ip_acl.ip_acl, is_container='container', presence=False, yang_name="ip-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'46'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)


  def _get_acl_mirror(self):
    """
    Getter method for acl_mirror, mapped from YANG variable /acl_mirror (container)
    """
    return self.__acl_mirror
      
  def _set_acl_mirror(self, v, load=False):
    """
    Setter method for acl_mirror, mapped from YANG variable /acl_mirror (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_mirror is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_mirror() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=acl_mirror.acl_mirror, is_container='container', presence=False, yang_name="acl-mirror", rest_name="acl-mirror", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Interface to be mirrored', u'cli-incomplete-no': None, u'hidden': u'full', u'callpoint': u'AclmirrorPort', u'sort-priority': u'148'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_mirror must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=acl_mirror.acl_mirror, is_container='container', presence=False, yang_name="acl-mirror", rest_name="acl-mirror", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Interface to be mirrored', u'cli-incomplete-no': None, u'hidden': u'full', u'callpoint': u'AclmirrorPort', u'sort-priority': u'148'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)""",
        })

    self.__acl_mirror = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_mirror(self):
    self.__acl_mirror = YANGDynClass(base=acl_mirror.acl_mirror, is_container='container', presence=False, yang_name="acl-mirror", rest_name="acl-mirror", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Interface to be mirrored', u'cli-incomplete-no': None, u'hidden': u'full', u'callpoint': u'AclmirrorPort', u'sort-priority': u'148'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)

  ip_acl = __builtin__.property(_get_ip_acl, _set_ip_acl)
  acl_mirror = __builtin__.property(_get_acl_mirror, _set_acl_mirror)


  _pyangbind_elements = {'ip_acl': ip_acl, 'acl_mirror': acl_mirror, }


class brocade_interface_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-interface-ext - based on the path /brocade-interface-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is an extension to interface model for 
 - Defining RPCs to retrieve interface related operational data
   in the managed device.
 
Glossary of the terms used:
--------------------------- 
HDLC - High-Level Data Link Control.
PPP  - Point-to-Point Protocol.
ATM  - Asynchronous Transfer Mode.
GBIC - Gigabit Interface Converter.
SFP  - small form-factor.
XFP  - 10 Gigabit Small Form Factor Pluggable.
xFF  -
XFP-E - XFP Extended.
ISL   - Inter switch Link.

  """
  _pyangbind_elements = {}

  

import capabilities
class brocade_system_capabilities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-system-capabilities - based on the path /brocade-system-capabilities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the System Capabilities of the platform.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__capabilities',)

  _yang_name = 'brocade-system-capabilities'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__capabilities = YANGDynClass(base=capabilities.capabilities, is_container='container', presence=False, yang_name="capabilities", rest_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'CapabilitiesCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-system-capabilities', defining_module='brocade-system-capabilities', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_capabilities(self):
    """
    Getter method for capabilities, mapped from YANG variable /capabilities (container)
    """
    return self.__capabilities
      
  def _set_capabilities(self, v, load=False):
    """
    Setter method for capabilities, mapped from YANG variable /capabilities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capabilities() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=capabilities.capabilities, is_container='container', presence=False, yang_name="capabilities", rest_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'CapabilitiesCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-system-capabilities', defining_module='brocade-system-capabilities', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capabilities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=capabilities.capabilities, is_container='container', presence=False, yang_name="capabilities", rest_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'CapabilitiesCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-system-capabilities', defining_module='brocade-system-capabilities', yang_type='container', is_config=True)""",
        })

    self.__capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capabilities(self):
    self.__capabilities = YANGDynClass(base=capabilities.capabilities, is_container='container', presence=False, yang_name="capabilities", rest_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'CapabilitiesCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-system-capabilities', defining_module='brocade-system-capabilities', yang_type='container', is_config=True)

  capabilities = __builtin__.property(_get_capabilities, _set_capabilities)


  _pyangbind_elements = {'capabilities': capabilities, }


import cluster
class brocade_mct(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mct - based on the path /brocade-mct. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage Mct .
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cluster',)

  _yang_name = 'brocade-mct'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cluster = YANGDynClass(base=YANGListType("cluster_name cluster_id",cluster.cluster, yang_name="cluster", rest_name="cluster", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-name cluster-id', extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'cli-full-no': None, u'sort-priority': u'145', u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}), is_container='list', yang_name="cluster", rest_name="cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'cli-full-no': None, u'sort-priority': u'145', u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}, namespace='urn:brocade.com:mgmt:brocade-mct', defining_module='brocade-mct', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_cluster(self):
    """
    Getter method for cluster, mapped from YANG variable /cluster (list)
    """
    return self.__cluster
      
  def _set_cluster(self, v, load=False):
    """
    Setter method for cluster, mapped from YANG variable /cluster (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cluster_name cluster_id",cluster.cluster, yang_name="cluster", rest_name="cluster", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-name cluster-id', extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'cli-full-no': None, u'sort-priority': u'145', u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}), is_container='list', yang_name="cluster", rest_name="cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'cli-full-no': None, u'sort-priority': u'145', u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}, namespace='urn:brocade.com:mgmt:brocade-mct', defining_module='brocade-mct', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cluster_name cluster_id",cluster.cluster, yang_name="cluster", rest_name="cluster", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-name cluster-id', extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'cli-full-no': None, u'sort-priority': u'145', u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}), is_container='list', yang_name="cluster", rest_name="cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'cli-full-no': None, u'sort-priority': u'145', u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}, namespace='urn:brocade.com:mgmt:brocade-mct', defining_module='brocade-mct', yang_type='list', is_config=True)""",
        })

    self.__cluster = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster(self):
    self.__cluster = YANGDynClass(base=YANGListType("cluster_name cluster_id",cluster.cluster, yang_name="cluster", rest_name="cluster", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-name cluster-id', extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'cli-full-no': None, u'sort-priority': u'145', u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}), is_container='list', yang_name="cluster", rest_name="cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'cli-full-no': None, u'sort-priority': u'145', u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}, namespace='urn:brocade.com:mgmt:brocade-mct', defining_module='brocade-mct', yang_type='list', is_config=True)

  cluster = __builtin__.property(_get_cluster, _set_cluster)


  _pyangbind_elements = {'cluster': cluster, }


import mac
class brocade_mac_access_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mac-access-list - based on the path /brocade-mac-access-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for MAC Access-list.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mac',)

  _yang_name = 'brocade-mac-access-list'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mac = YANGDynClass(base=mac.mac, is_container='container', presence=False, yang_name="mac", rest_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC access list', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_MAC_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-mac-access-list', defining_module='brocade-mac-access-list', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /mac (container)
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /mac (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mac.mac, is_container='container', presence=False, yang_name="mac", rest_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC access list', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_MAC_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-mac-access-list', defining_module='brocade-mac-access-list', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac.mac, is_container='container', presence=False, yang_name="mac", rest_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC access list', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_MAC_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-mac-access-list', defining_module='brocade-mac-access-list', yang_type='container', is_config=True)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=mac.mac, is_container='container', presence=False, yang_name="mac", rest_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC access list', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_MAC_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-mac-access-list', defining_module='brocade-mac-access-list', yang_type='container', is_config=True)

  mac = __builtin__.property(_get_mac, _set_mac)


  _pyangbind_elements = {'mac': mac, }


class brocade_intf_loopback(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-intf-loopback - based on the path /brocade-intf-loopback. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Module for implementing Interface Loopback CLIs
  """
  _pyangbind_elements = {}

  

class brocade_ras_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ras-ext - based on the path /brocade-ras-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines RASLOG related information.
Copyright (c) 2010-11 by Brocade Communications Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class brocade_xstp_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-xstp-ext - based on the path /brocade-xstp-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Spanning Tree
Protocol

Glossary of the terms used:
---------------------------
CIST   Common and Internal Spanning Tree (IEEE 802.1Q)

  """
  _pyangbind_elements = {}

  

class brocade_ospf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ospf - based on the path /brocade-ospf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
OSPF Version 2 Protocol.
  """
  _pyangbind_elements = {}

  

import interface
import interface_vlan
import protocol
import global_mtu_conf
class brocade_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-interface - based on the path /brocade-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage  
ethernet network interfaces sub-layers.
        
The following ethernet interfaces can be managed using this 
management module:
        
+--------------------------------------------------------------+
| List name                  Description                       |
+--------------------------------------------------------------+
| ethernet                   Physical Ethernet interfaces      |
| port-channel               Port-channel/LAG interfaces       |
| management                 Management port/interfaces        |
| vlan                       L2 Vlan interface.                |
| homerun                    Homerun interface.                |
+--------------------------------------------------------------+
        
This module provides mechanism:
   - to discover and characterize the interface sub-layers.
   - to configure various attributes of these interfaces.
   - to structure the interfaces such that various L2/L3 
   access/security policies, network discovery policies, QoS 
   policies and Link aggregation policies can be applied using 
   other modules supported by the managed entity.
        
Glossary of the terms used:
--------------------------- 
TRILL   - Transparent Interconnection of Lots of Links.
VLAN    - Virtual Local Area Network.
ISL     - Inter switch Link.
MTU     - Maximum transmission unit. The size of the largest 
         packet which can be sent/received on an interface.
LAG     - IEEE Link Aggregation (IEEE 802.1AX).
vLAG    - virtual LAG.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__interface','__interface_vlan','__protocol','__global_mtu_conf',)

  _yang_name = 'brocade-interface'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__interface = YANGDynClass(base=interface.interface, is_container='container', presence=False, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'All the interface related configurations/data.', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    self.__protocol = YANGDynClass(base=protocol.protocol, is_container='container', presence=False, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Protocol Configuration', u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L2_CONFIG', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    self.__interface_vlan = YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_VLAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    self.__global_mtu_conf = YANGDynClass(base=global_mtu_conf.global_mtu_conf, is_container='container', presence=False, yang_name="global-mtu-conf", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'global-mtu-cfg-cp', u'sort-priority': u'RUNNCFG_LEVEL_FEATURE_GLOBAL_MTU'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interface (container)

    YANG Description: All the interface related elements of this managed device
grouped under this container.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: All the interface related elements of this managed device
grouped under this container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface.interface, is_container='container', presence=False, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'All the interface related configurations/data.', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface.interface, is_container='container', presence=False, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'All the interface related configurations/data.', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=interface.interface, is_container='container', presence=False, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'All the interface related configurations/data.', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)


  def _get_interface_vlan(self):
    """
    Getter method for interface_vlan, mapped from YANG variable /interface_vlan (container)

    YANG Description: An intermediary node that separates the vlan related 
elements of this managed device.
    """
    return self.__interface_vlan
      
  def _set_interface_vlan(self, v, load=False):
    """
    Setter method for interface_vlan, mapped from YANG variable /interface_vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_vlan() directly.

    YANG Description: An intermediary node that separates the vlan related 
elements of this managed device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_VLAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_VLAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)""",
        })

    self.__interface_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_vlan(self):
    self.__interface_vlan = YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_VLAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /protocol (container)
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /protocol (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol.protocol, is_container='container', presence=False, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Protocol Configuration', u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L2_CONFIG', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol.protocol, is_container='container', presence=False, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Protocol Configuration', u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L2_CONFIG', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=protocol.protocol, is_container='container', presence=False, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Protocol Configuration', u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L2_CONFIG', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)


  def _get_global_mtu_conf(self):
    """
    Getter method for global_mtu_conf, mapped from YANG variable /global_mtu_conf (container)
    """
    return self.__global_mtu_conf
      
  def _set_global_mtu_conf(self, v, load=False):
    """
    Setter method for global_mtu_conf, mapped from YANG variable /global_mtu_conf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_mtu_conf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_mtu_conf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=global_mtu_conf.global_mtu_conf, is_container='container', presence=False, yang_name="global-mtu-conf", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'global-mtu-cfg-cp', u'sort-priority': u'RUNNCFG_LEVEL_FEATURE_GLOBAL_MTU'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_mtu_conf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=global_mtu_conf.global_mtu_conf, is_container='container', presence=False, yang_name="global-mtu-conf", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'global-mtu-cfg-cp', u'sort-priority': u'RUNNCFG_LEVEL_FEATURE_GLOBAL_MTU'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)""",
        })

    self.__global_mtu_conf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_mtu_conf(self):
    self.__global_mtu_conf = YANGDynClass(base=global_mtu_conf.global_mtu_conf, is_container='container', presence=False, yang_name="global-mtu-conf", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'global-mtu-cfg-cp', u'sort-priority': u'RUNNCFG_LEVEL_FEATURE_GLOBAL_MTU'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  interface_vlan = __builtin__.property(_get_interface_vlan, _set_interface_vlan)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  global_mtu_conf = __builtin__.property(_get_global_mtu_conf, _set_global_mtu_conf)


  _pyangbind_elements = {'interface': interface, 'interface_vlan': interface_vlan, 'protocol': protocol, 'global_mtu_conf': global_mtu_conf, }


import port_profile
import port_profile_global
import port_profile_domain
class brocade_port_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-port-profile - based on the path /brocade-port-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage  
Automatic Port Profiles in the device.
        
Glossary of the terms used:
--------------------------- 
APPM - Automatic Port Profile Management.
AMPP - Automatic Migration of Port Profile.
VM   - Virtual Machine.
VAL  - Virtual Access Layer, provided by VCS.
VCS  - Virtual Cluster Switching.
        
        
A port-profile is a collection of network policies to be 
applied on a network traffic on a given port.
        
Automatic Migration of Port Profile (AMPP) functionality 
provides fabric wide configuration of Ethernet policies and 
achieves per port-profile forwarding and enables network level 
features to support VM mobility.
        
With Server Virtualization infrastructure, a VM can move from 
one physical server to another. When such move occurs, it is 
ideal for access-layer to apply the network policies on the 
VM transparently. The Brocade VAL service provides such 
automatic migration of the port-profile on a given VMAC 
transparently. 
   
                                          [Hypervisor2]
                                           _____
                                          |     |
                                         /|VMAC |
                     '*************'    / |_____|
                     '             '   /     ^
                     '             '  /      |
                     '             '_/       ^
                     ' [VCS Fabric]'_        |
                     ' VMAC-PP map ' \     VM mobility
                     '             '  \      |
                     '             '   \     ^
                     '*************'    \  __|__
                                         \|     |
                                          |VMAC |
                                          |_____|
                                          [Hypervisor1]
                                          
This management module provides instrumentation to 
   - create/activate port-profile
   - map port-profile to MAC

A Port-profile typically comprises of:
+--------------------------------------------------------------+
| sub-profile         Description                              |
+--------------------------------------------------------------+
| Vlan profile        Vlan membership and filtering rules.     |
| QoS profile         Qos policies.                            |
| FCoE profile        The attributes needed for the port to    |
|                     support FCoE: FCoE VLAN, FCMAP, FCoE     |
|                     Priority, Virtual Fabric ID etc.         |
| Security profile    Security rules needed for the server     |
|                     port, typically enabling 802.1x with EAP |
|                     TLV extensions for VM Mobility, MAC based|
|                     standard and extended ACLs.              |
+--------------------------------------------------------------+
        
VM MAC addresses are added to a port-profile to specify all the 
network attributes for a server port. A port-profile is 
activated on a server port when as part of regular MAC learning. 
VM MAC to port-profile association is specified using this 
management module. The actual association in hardware is applied
when the MAC address is learned.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__port_profile','__port_profile_global','__port_profile_domain',)

  _yang_name = 'brocade-port-profile'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__port_profile_domain = YANGDynClass(base=YANGListType("port_profile_domain_name",port_profile_domain.port_profile_domain, yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-profile-domain-name', extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'72', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}), is_container='list', yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'72', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)
    self.__port_profile_global = YANGDynClass(base=port_profile_global.port_profile_global, is_container='container', presence=False, yang_name="port-profile-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'71'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='container', is_config=True)
    self.__port_profile = YANGDynClass(base=YANGListType("name",port_profile.port_profile, yang_name="port-profile", rest_name="port-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'71'}}), is_container='list', yang_name="port-profile", rest_name="port-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'71'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_port_profile(self):
    """
    Getter method for port_profile, mapped from YANG variable /port_profile (list)

    YANG Description: The list of port-profiles in the managed device. Each row
represents port profile name and its subprofiles.
    """
    return self.__port_profile
      
  def _set_port_profile(self, v, load=False):
    """
    Setter method for port_profile, mapped from YANG variable /port_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_profile() directly.

    YANG Description: The list of port-profiles in the managed device. Each row
represents port profile name and its subprofiles.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",port_profile.port_profile, yang_name="port-profile", rest_name="port-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'71'}}), is_container='list', yang_name="port-profile", rest_name="port-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'71'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",port_profile.port_profile, yang_name="port-profile", rest_name="port-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'71'}}), is_container='list', yang_name="port-profile", rest_name="port-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'71'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)""",
        })

    self.__port_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_profile(self):
    self.__port_profile = YANGDynClass(base=YANGListType("name",port_profile.port_profile, yang_name="port-profile", rest_name="port-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'71'}}), is_container='list', yang_name="port-profile", rest_name="port-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'71'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)


  def _get_port_profile_global(self):
    """
    Getter method for port_profile_global, mapped from YANG variable /port_profile_global (container)

    YANG Description: This provides the grouping for configuration parameters
to activate and MAC for a port profile.
    """
    return self.__port_profile_global
      
  def _set_port_profile_global(self, v, load=False):
    """
    Setter method for port_profile_global, mapped from YANG variable /port_profile_global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_profile_global is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_profile_global() directly.

    YANG Description: This provides the grouping for configuration parameters
to activate and MAC for a port profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=port_profile_global.port_profile_global, is_container='container', presence=False, yang_name="port-profile-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'71'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_profile_global must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=port_profile_global.port_profile_global, is_container='container', presence=False, yang_name="port-profile-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'71'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='container', is_config=True)""",
        })

    self.__port_profile_global = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_profile_global(self):
    self.__port_profile_global = YANGDynClass(base=port_profile_global.port_profile_global, is_container='container', presence=False, yang_name="port-profile-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'71'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='container', is_config=True)


  def _get_port_profile_domain(self):
    """
    Getter method for port_profile_domain, mapped from YANG variable /port_profile_domain (list)
    """
    return self.__port_profile_domain
      
  def _set_port_profile_domain(self, v, load=False):
    """
    Setter method for port_profile_domain, mapped from YANG variable /port_profile_domain (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_profile_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_profile_domain() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("port_profile_domain_name",port_profile_domain.port_profile_domain, yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-profile-domain-name', extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'72', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}), is_container='list', yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'72', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_profile_domain must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("port_profile_domain_name",port_profile_domain.port_profile_domain, yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-profile-domain-name', extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'72', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}), is_container='list', yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'72', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)""",
        })

    self.__port_profile_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_profile_domain(self):
    self.__port_profile_domain = YANGDynClass(base=YANGListType("port_profile_domain_name",port_profile_domain.port_profile_domain, yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-profile-domain-name', extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'72', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}), is_container='list', yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'72', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)

  port_profile = __builtin__.property(_get_port_profile, _set_port_profile)
  port_profile_global = __builtin__.property(_get_port_profile_global, _set_port_profile_global)
  port_profile_domain = __builtin__.property(_get_port_profile_domain, _set_port_profile_domain)


  _pyangbind_elements = {'port_profile': port_profile, 'port_profile_global': port_profile_global, 'port_profile_domain': port_profile_domain, }


class brocade_lif(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lif - based on the path /brocade-lif. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
This module defines configuration commands related for creating logical interfaces for
physical and port channel interfaces.

Configuration examples:
interface e 1/1.1
interface e 2/2.23
interface port-channel 2.1
interface port-channel 2.23

  """
  _pyangbind_elements = {}

  

import fabric
class brocade_fabric_service(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-fabric-service - based on the path /brocade-fabric-service. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module gives Virtual Cluster Switching (VCS)
FABRIC related information. VCS refers to the ability of
a group of physical Ethernet switches, inter-connected
in arbitrary fashion via the regular front-end
data ports, to present themselves as one unified and
transparent Ethernet switching service to the external network.
The inter-connecting network that glues all these individual
switches is refered as 'fabric', and the group of physical
Ethernet switches in the fabric is refered to as 'cluster'.

Glossary of the terms used:
---------------------------
RBridge     - A Routing Bridge or RBridge is a network device
              that implements the TRILL protocol, as defined
              by the IETF.

RBridge-ID  - RBridge-ID is the unique identifier of a node
              in the fabric. It can take values from 1 - 239.

ISL         - A inter switch link (ISL) is the link directly
              connecting a fabric port of one switch to fabric
              port of another switch. For an ISL to come up
              both side of the link need to have
              compatible configurations.

Trunk       - Brocade trunk is a hardware based LAG (link
              aggregation group) that is formed dynamically.
              It is a technology that allows to combine up to
              8 ISLs into a single logical trunk that provides
              up to 80 Gigabits per second (Gbps) data
              transfers.
              Trunking uses a simple algorithm to optimally
              distribute frames across a set of available paths
              that link two adjacent switches. Such a set of
              links is called trunking group.
              In a trunk group one of the trunk ports is
              used to set up all routing paths for the entire
              trunk group. This port is called the 'trunk
              master'.

WWN         - World Wide Name (WWN) is a unique 64 bit
              identifier that is assigned to a manufacturer
              by the Institute of Electrical and Electronic
              Engineers(IEEE) and hard-coded into a Fibre
              Channel (FC) device.

Principle   - In a fabric one switch is elected to manage
Switch        RBridge-ID assignments within the fabric.
              This switch is called the Principal Switch.
              Each fabric has its own Principal Switch. If the
              fabric configuration changes, a different switch
              could become principal.
              Note: In case of a single switch fabric, the same
              switch acts as the Principal Switch.

ECMP        - Equal cost multiple path (ECMP) is a routing
              strategy where next-hop packet forwarding to a
              single destination can occur over multiple
              'best paths' which tie for top place in routing
              metric calculations.

BUM         - Broadcast, Unknown Unicast & Multicast (BUM)
              traffic.

FSPF        - Fabric Shortest Path First (FSPF) is a routing
              protocol used in Fibre Channel networks.
              It calculates the best path between switches,
              establishes routes across the fabric and
              calculates alternate routes in event of a
              failure or topology change. FSPF guarantees
              in-order delivery of frames, even if the
              routing topology has changed during a failure,
              by enforcing a 'hold down' time before a new
              path is activated.

Port ID(PID)- The Fibre Channel address ID in DDAAPP
              hexadecimal format.

VID         - VLAN identifier (VID).

PISL        - Physical inter switch link (PISL).

Note:
The terms node and switch have been used interchangeably
in this document. Both refer to the same.

  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__fabric',)

  _yang_name = 'brocade-fabric-service'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__fabric = YANGDynClass(base=fabric.fabric, is_container='container', presence=False, yang_name="fabric", rest_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Allows to configure fabric related parameters', u'display-when': u'/vcsmode/vcs-mode = "true"', u'sort-priority': u'52', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fabric-service', defining_module='brocade-fabric-service', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_fabric(self):
    """
    Getter method for fabric, mapped from YANG variable /fabric (container)

    YANG Description: This function is used to configure fabric
parameters such as multicast priority.
    """
    return self.__fabric
      
  def _set_fabric(self, v, load=False):
    """
    Setter method for fabric, mapped from YANG variable /fabric (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fabric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fabric() directly.

    YANG Description: This function is used to configure fabric
parameters such as multicast priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=fabric.fabric, is_container='container', presence=False, yang_name="fabric", rest_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Allows to configure fabric related parameters', u'display-when': u'/vcsmode/vcs-mode = "true"', u'sort-priority': u'52', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fabric-service', defining_module='brocade-fabric-service', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fabric must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fabric.fabric, is_container='container', presence=False, yang_name="fabric", rest_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Allows to configure fabric related parameters', u'display-when': u'/vcsmode/vcs-mode = "true"', u'sort-priority': u'52', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fabric-service', defining_module='brocade-fabric-service', yang_type='container', is_config=True)""",
        })

    self.__fabric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fabric(self):
    self.__fabric = YANGDynClass(base=fabric.fabric, is_container='container', presence=False, yang_name="fabric", rest_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Allows to configure fabric related parameters', u'display-when': u'/vcsmode/vcs-mode = "true"', u'sort-priority': u'52', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fabric-service', defining_module='brocade-fabric-service', yang_type='container', is_config=True)

  fabric = __builtin__.property(_get_fabric, _set_fabric)


  _pyangbind_elements = {'fabric': fabric, }


class brocade_tunnels_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-tunnels-ext - based on the path /brocade-tunnels-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the IP
tunnels. It is a extension of brocade-tunnels module.

Glossary of the terms used:
---------------------------
VXLAN       Virtual eXtensible Local Area Network (RFC 7348)
VXLAN Gateway
           Software module in Brocade VCS switch which forwards
           traffic between VXLAN and non-VXLAN environments.
NSX         NSX is a network virtualization platform solution
           by Vmware. Refer - www.vmware.com/in/products/nsx
NSX Controller
           NSX Controller is the cluster of x86 systems which
           manage the virtual networks.
TCP         Transmission Control Protocol (RFC 793)
SSL         Secure Sockets Layer Protocol (RFC 6101)
BFD         Bidirectional Forwarding Detection (RFC 5880)
BGP-EVPN    Border Gateway Protocol, Ethernet VPN (RFC 7432)


  """
  _pyangbind_elements = {}

  

import qos
class brocade_qos_mls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-mls - based on the path /brocade-qos-mls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages Multi Layer Switching(MLS) Quality Of Service (QOS)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__qos',)

  _yang_name = 'brocade-qos-mls'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', presence=False, yang_name="qos", rest_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Quality of Service (QoS)', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mls', defining_module='brocade-qos-mls', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', presence=False, yang_name="qos", rest_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Quality of Service (QoS)', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mls', defining_module='brocade-qos-mls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', presence=False, yang_name="qos", rest_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Quality of Service (QoS)', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mls', defining_module='brocade-qos-mls', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', presence=False, yang_name="qos", rest_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Quality of Service (QoS)', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mls', defining_module='brocade-qos-mls', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = {'qos': qos, }


class brocade_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bgp - based on the path /brocade-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
BGP Protocol.
  """
  _pyangbind_elements = {}

  

import rbridge_id
class brocade_rbridge(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-rbridge - based on the path /brocade-rbridge. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
rbridge-id feature.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__rbridge_id',)

  _yang_name = 'brocade-rbridge'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__rbridge_id = YANGDynClass(base=YANGListType("rbridge_id",rbridge_id.rbridge_id, yang_name="rbridge-id", rest_name="rbridge-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='rbridge-id', extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}), is_container='list', yang_name="rbridge-id", rest_name="rbridge-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge', defining_module='brocade-rbridge', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_rbridge_id(self):
    """
    Getter method for rbridge_id, mapped from YANG variable /rbridge_id (list)
    """
    return self.__rbridge_id
      
  def _set_rbridge_id(self, v, load=False):
    """
    Setter method for rbridge_id, mapped from YANG variable /rbridge_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rbridge_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rbridge_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("rbridge_id",rbridge_id.rbridge_id, yang_name="rbridge-id", rest_name="rbridge-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='rbridge-id', extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}), is_container='list', yang_name="rbridge-id", rest_name="rbridge-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge', defining_module='brocade-rbridge', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rbridge_id must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("rbridge_id",rbridge_id.rbridge_id, yang_name="rbridge-id", rest_name="rbridge-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='rbridge-id', extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}), is_container='list', yang_name="rbridge-id", rest_name="rbridge-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge', defining_module='brocade-rbridge', yang_type='list', is_config=True)""",
        })

    self.__rbridge_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rbridge_id(self):
    self.__rbridge_id = YANGDynClass(base=YANGListType("rbridge_id",rbridge_id.rbridge_id, yang_name="rbridge-id", rest_name="rbridge-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='rbridge-id', extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}), is_container='list', yang_name="rbridge-id", rest_name="rbridge-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge', defining_module='brocade-rbridge', yang_type='list', is_config=True)

  rbridge_id = __builtin__.property(_get_rbridge_id, _set_rbridge_id)


  _pyangbind_elements = {'rbridge_id': rbridge_id, }


import mgmt_cluster
class brocade_cluster(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-cluster - based on the path /brocade-cluster. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides interface to provision principal priority
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mgmt_cluster',)

  _yang_name = 'brocade-cluster'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mgmt_cluster = YANGDynClass(base=mgmt_cluster.mgmt_cluster, is_container='container', presence=False, yang_name="mgmt-cluster", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='http://brocade.com/ns/brocade-cluster', defining_module='brocade-cluster', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mgmt_cluster(self):
    """
    Getter method for mgmt_cluster, mapped from YANG variable /mgmt_cluster (container)

    YANG Description: An intermediary node that separates the cluster related
elements of this managed device.
    """
    return self.__mgmt_cluster
      
  def _set_mgmt_cluster(self, v, load=False):
    """
    Setter method for mgmt_cluster, mapped from YANG variable /mgmt_cluster (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_cluster is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_cluster() directly.

    YANG Description: An intermediary node that separates the cluster related
elements of this managed device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mgmt_cluster.mgmt_cluster, is_container='container', presence=False, yang_name="mgmt-cluster", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='http://brocade.com/ns/brocade-cluster', defining_module='brocade-cluster', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_cluster must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mgmt_cluster.mgmt_cluster, is_container='container', presence=False, yang_name="mgmt-cluster", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='http://brocade.com/ns/brocade-cluster', defining_module='brocade-cluster', yang_type='container', is_config=True)""",
        })

    self.__mgmt_cluster = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_cluster(self):
    self.__mgmt_cluster = YANGDynClass(base=mgmt_cluster.mgmt_cluster, is_container='container', presence=False, yang_name="mgmt-cluster", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='http://brocade.com/ns/brocade-cluster', defining_module='brocade-cluster', yang_type='container', is_config=True)

  mgmt_cluster = __builtin__.property(_get_mgmt_cluster, _set_mgmt_cluster)


  _pyangbind_elements = {'mgmt_cluster': mgmt_cluster, }


class brocade_xstp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-xstp - based on the path /brocade-xstp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the 
Spanning Tree Protocol (STP).          
        
Glossary of the terms used:
--------------------------- 
        

  """
  _pyangbind_elements = {}

  

import mac_address_table
import mac_group
class brocade_mac_address_table(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mac-address-table - based on the path /brocade-mac-address-table. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Mac forwarding table
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mac_address_table','__mac_group',)

  _yang_name = 'brocade-mac-address-table'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mac_address_table = YANGDynClass(base=mac_address_table.mac_address_table, is_container='container', presence=False, yang_name="mac-address-table", rest_name="mac-address-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC forwarding table information', u'cli-incomplete-no': None, u'sort-priority': u'87'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='container', is_config=True)
    self.__mac_group = YANGDynClass(base=YANGListType("mac_group_id",mac_group.mac_group, yang_name="mac-group", rest_name="mac-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac-group-id', extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'55', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}), is_container='list', yang_name="mac-group", rest_name="mac-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'55', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mac_address_table(self):
    """
    Getter method for mac_address_table, mapped from YANG variable /mac_address_table (container)
    """
    return self.__mac_address_table
      
  def _set_mac_address_table(self, v, load=False):
    """
    Setter method for mac_address_table, mapped from YANG variable /mac_address_table (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address_table is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address_table() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mac_address_table.mac_address_table, is_container='container', presence=False, yang_name="mac-address-table", rest_name="mac-address-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC forwarding table information', u'cli-incomplete-no': None, u'sort-priority': u'87'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address_table must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_address_table.mac_address_table, is_container='container', presence=False, yang_name="mac-address-table", rest_name="mac-address-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC forwarding table information', u'cli-incomplete-no': None, u'sort-priority': u'87'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='container', is_config=True)""",
        })

    self.__mac_address_table = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address_table(self):
    self.__mac_address_table = YANGDynClass(base=mac_address_table.mac_address_table, is_container='container', presence=False, yang_name="mac-address-table", rest_name="mac-address-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC forwarding table information', u'cli-incomplete-no': None, u'sort-priority': u'87'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='container', is_config=True)


  def _get_mac_group(self):
    """
    Getter method for mac_group, mapped from YANG variable /mac_group (list)
    """
    return self.__mac_group
      
  def _set_mac_group(self, v, load=False):
    """
    Setter method for mac_group, mapped from YANG variable /mac_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_group() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mac_group_id",mac_group.mac_group, yang_name="mac-group", rest_name="mac-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac-group-id', extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'55', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}), is_container='list', yang_name="mac-group", rest_name="mac-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'55', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mac_group_id",mac_group.mac_group, yang_name="mac-group", rest_name="mac-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac-group-id', extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'55', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}), is_container='list', yang_name="mac-group", rest_name="mac-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'55', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='list', is_config=True)""",
        })

    self.__mac_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_group(self):
    self.__mac_group = YANGDynClass(base=YANGListType("mac_group_id",mac_group.mac_group, yang_name="mac-group", rest_name="mac-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac-group-id', extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'55', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}), is_container='list', yang_name="mac-group", rest_name="mac-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'55', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='list', is_config=True)

  mac_address_table = __builtin__.property(_get_mac_address_table, _set_mac_address_table)
  mac_group = __builtin__.property(_get_mac_group, _set_mac_group)


  _pyangbind_elements = {'mac_address_table': mac_address_table, 'mac_group': mac_group, }


import sflow
import sflow_profile
class brocade_sflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-sflow - based on the path /brocade-sflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule describes the data model for sFlow
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__sflow','__sflow_profile',)

  _yang_name = 'brocade-sflow'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__sflow_profile = YANGDynClass(base=YANGListType("profile_name",sflow_profile.sflow_profile, yang_name="sflow-profile", rest_name="sflow-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'SflowProfile'}}), is_container='list', yang_name="sflow-profile", rest_name="sflow-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'SflowProfile'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='list', is_config=True)
    self.__sflow = YANGDynClass(base=sflow.sflow, is_container='container', presence=False, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Configuration', u'cli-incomplete-no': None, u'callpoint': u'Sflow', u'sort-priority': u'RUNNCFG_LEVEL_SFLOW_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_sflow(self):
    """
    Getter method for sflow, mapped from YANG variable /sflow (container)
    """
    return self.__sflow
      
  def _set_sflow(self, v, load=False):
    """
    Setter method for sflow, mapped from YANG variable /sflow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sflow() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sflow.sflow, is_container='container', presence=False, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Configuration', u'cli-incomplete-no': None, u'callpoint': u'Sflow', u'sort-priority': u'RUNNCFG_LEVEL_SFLOW_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sflow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sflow.sflow, is_container='container', presence=False, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Configuration', u'cli-incomplete-no': None, u'callpoint': u'Sflow', u'sort-priority': u'RUNNCFG_LEVEL_SFLOW_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='container', is_config=True)""",
        })

    self.__sflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sflow(self):
    self.__sflow = YANGDynClass(base=sflow.sflow, is_container='container', presence=False, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Configuration', u'cli-incomplete-no': None, u'callpoint': u'Sflow', u'sort-priority': u'RUNNCFG_LEVEL_SFLOW_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='container', is_config=True)


  def _get_sflow_profile(self):
    """
    Getter method for sflow_profile, mapped from YANG variable /sflow_profile (list)
    """
    return self.__sflow_profile
      
  def _set_sflow_profile(self, v, load=False):
    """
    Setter method for sflow_profile, mapped from YANG variable /sflow_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sflow_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sflow_profile() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("profile_name",sflow_profile.sflow_profile, yang_name="sflow-profile", rest_name="sflow-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'SflowProfile'}}), is_container='list', yang_name="sflow-profile", rest_name="sflow-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'SflowProfile'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sflow_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("profile_name",sflow_profile.sflow_profile, yang_name="sflow-profile", rest_name="sflow-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'SflowProfile'}}), is_container='list', yang_name="sflow-profile", rest_name="sflow-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'SflowProfile'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='list', is_config=True)""",
        })

    self.__sflow_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sflow_profile(self):
    self.__sflow_profile = YANGDynClass(base=YANGListType("profile_name",sflow_profile.sflow_profile, yang_name="sflow-profile", rest_name="sflow-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'SflowProfile'}}), is_container='list', yang_name="sflow-profile", rest_name="sflow-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'SflowProfile'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='list', is_config=True)

  sflow = __builtin__.property(_get_sflow, _set_sflow)
  sflow_profile = __builtin__.property(_get_sflow_profile, _set_sflow_profile)


  _pyangbind_elements = {'sflow': sflow, 'sflow_profile': sflow_profile, }


import vrrp_rbridge_global
import protocol_vrrpv3
class brocade_vrrpv3(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vrrpv3 - based on the path /brocade-vrrpv3. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Virtual Router Redundancy Protocol
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vrrp_rbridge_global','__protocol_vrrpv3',)

  _yang_name = 'brocade-vrrpv3'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vrrp_rbridge_global = YANGDynClass(base=vrrp_rbridge_global.vrrp_rbridge_global, is_container='container', presence=False, yang_name="vrrp-rbridge-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'vrrpv3GlobalConf', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)
    self.__protocol_vrrpv3 = YANGDynClass(base=protocol_vrrpv3.protocol_vrrpv3, is_container='container', presence=False, yang_name="protocol-vrrpv3", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'41'}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vrrp_rbridge_global(self):
    """
    Getter method for vrrp_rbridge_global, mapped from YANG variable /vrrp_rbridge_global (container)
    """
    return self.__vrrp_rbridge_global
      
  def _set_vrrp_rbridge_global(self, v, load=False):
    """
    Setter method for vrrp_rbridge_global, mapped from YANG variable /vrrp_rbridge_global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp_rbridge_global is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp_rbridge_global() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vrrp_rbridge_global.vrrp_rbridge_global, is_container='container', presence=False, yang_name="vrrp-rbridge-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'vrrpv3GlobalConf', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp_rbridge_global must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vrrp_rbridge_global.vrrp_rbridge_global, is_container='container', presence=False, yang_name="vrrp-rbridge-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'vrrpv3GlobalConf', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)""",
        })

    self.__vrrp_rbridge_global = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp_rbridge_global(self):
    self.__vrrp_rbridge_global = YANGDynClass(base=vrrp_rbridge_global.vrrp_rbridge_global, is_container='container', presence=False, yang_name="vrrp-rbridge-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'vrrpv3GlobalConf', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)


  def _get_protocol_vrrpv3(self):
    """
    Getter method for protocol_vrrpv3, mapped from YANG variable /protocol_vrrpv3 (container)

    YANG Description: An intermediary node that separates the protocol vrrpv3 from other protocols.
    """
    return self.__protocol_vrrpv3
      
  def _set_protocol_vrrpv3(self, v, load=False):
    """
    Setter method for protocol_vrrpv3, mapped from YANG variable /protocol_vrrpv3 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_vrrpv3 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_vrrpv3() directly.

    YANG Description: An intermediary node that separates the protocol vrrpv3 from other protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol_vrrpv3.protocol_vrrpv3, is_container='container', presence=False, yang_name="protocol-vrrpv3", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'41'}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_vrrpv3 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol_vrrpv3.protocol_vrrpv3, is_container='container', presence=False, yang_name="protocol-vrrpv3", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'41'}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)""",
        })

    self.__protocol_vrrpv3 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_vrrpv3(self):
    self.__protocol_vrrpv3 = YANGDynClass(base=protocol_vrrpv3.protocol_vrrpv3, is_container='container', presence=False, yang_name="protocol-vrrpv3", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'41'}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)

  vrrp_rbridge_global = __builtin__.property(_get_vrrp_rbridge_global, _set_vrrp_rbridge_global)
  protocol_vrrpv3 = __builtin__.property(_get_protocol_vrrpv3, _set_protocol_vrrpv3)


  _pyangbind_elements = {'vrrp_rbridge_global': vrrp_rbridge_global, 'protocol_vrrpv3': protocol_vrrpv3, }


class brocade_isis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-isis - based on the path /brocade-isis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
ISIS Protocol.
  """
  _pyangbind_elements = {}

  

import mpls_state
class brocade_mpls_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /brocade-mpls-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage mpls
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mpls_state',)

  _yang_name = 'brocade-mpls-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mpls_state = YANGDynClass(base=mpls_state.mpls_state, is_container='container', presence=False, yang_name="mpls-state", rest_name="mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mpls_state(self):
    """
    Getter method for mpls_state, mapped from YANG variable /mpls_state (container)

    YANG Description: MPLS Operational Information
    """
    return self.__mpls_state
      
  def _set_mpls_state(self, v, load=False):
    """
    Setter method for mpls_state, mapped from YANG variable /mpls_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_state() directly.

    YANG Description: MPLS Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls_state.mpls_state, is_container='container', presence=False, yang_name="mpls-state", rest_name="mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls_state.mpls_state, is_container='container', presence=False, yang_name="mpls-state", rest_name="mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=True)""",
        })

    self.__mpls_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_state(self):
    self.__mpls_state = YANGDynClass(base=mpls_state.mpls_state, is_container='container', presence=False, yang_name="mpls-state", rest_name="mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=True)

  mpls_state = __builtin__.property(_get_mpls_state, _set_mpls_state)


  _pyangbind_elements = {'mpls_state': mpls_state, }


