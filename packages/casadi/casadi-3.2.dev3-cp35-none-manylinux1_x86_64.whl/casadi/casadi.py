# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_casadi')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_casadi')
    _casadi = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_casadi', [dirname(__file__)])
        except ImportError:
            import _casadi
            return _casadi
        if fp is not None:
            try:
                _mod = imp.load_module('_casadi', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _casadi = swig_import_helper()
    del swig_import_helper
else:
    import _casadi
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x




import contextlib

class _copyableObject(_object):
  def __copy__(self):
    return self.__class__(self)

  def __deepcopy__(self,dummy=None):
    return self.__class__(self)

_object = _copyableObject

_swig_repr_default = _swig_repr
def _swig_repr(self):
  if hasattr(self,'getRepresentation'):
    return self.getRepresentation()
  else:
    return _swig_repr_default(self)


MNAME = _casadi.MNAME
class SwigPyIterator(_object):
    """


    SwigPyIterator() -> 



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi.delete_SwigPyIterator

    def value(self, *args) -> "PyObject *":
        """


        value(self) -> PyObject *



        """
        return _casadi.SwigPyIterator_value(self, *args)


    def incr(self, *args) -> "swig::SwigPyIterator *":
        """


        incr(self, size_t n) -> SwigPyIterator



        """
        return _casadi.SwigPyIterator_incr(self, *args)


    def decr(self, *args) -> "swig::SwigPyIterator *":
        """


        decr(self, size_t n) -> SwigPyIterator



        """
        return _casadi.SwigPyIterator_decr(self, *args)


    def distance(self, *args) -> "ptrdiff_t":
        """


        distance(self, SwigPyIterator x) -> ptrdiff_t



        """
        return _casadi.SwigPyIterator_distance(self, *args)


    def equal(self, *args) -> "bool":
        """


        equal(self, SwigPyIterator x) -> bool



        """
        return _casadi.SwigPyIterator_equal(self, *args)


    def copy(self, *args) -> "swig::SwigPyIterator *":
        """


        copy(self) -> SwigPyIterator



        """
        return _casadi.SwigPyIterator_copy(self, *args)


    def next(self, *args) -> "PyObject *":
        """


        next(self) -> PyObject *



        """
        return _casadi.SwigPyIterator_next(self, *args)


    def __next__(self, *args) -> "PyObject *":
        """


        __next__(self) -> PyObject *



        """
        return _casadi.SwigPyIterator___next__(self, *args)


    def previous(self, *args) -> "PyObject *":
        """


        previous(self) -> PyObject *



        """
        return _casadi.SwigPyIterator_previous(self, *args)


    def advance(self, *args) -> "swig::SwigPyIterator *":
        """


        advance(self, ptrdiff_t n) -> SwigPyIterator



        """
        return _casadi.SwigPyIterator_advance(self, *args)


    def __eq__(self, *args) -> "bool":
        """


        __eq__(self, SwigPyIterator x) -> bool



        """
        return _casadi.SwigPyIterator___eq__(self, *args)


    def __ne__(self, *args) -> "bool":
        """


        __ne__(self, SwigPyIterator x) -> bool



        """
        return _casadi.SwigPyIterator___ne__(self, *args)


    def __iadd__(self, *args) -> "swig::SwigPyIterator &":
        """


        __iadd__(self, ptrdiff_t n) -> SwigPyIterator



        """
        return _casadi.SwigPyIterator___iadd__(self, *args)


    def __isub__(self, *args) -> "swig::SwigPyIterator &":
        """


        __isub__(self, ptrdiff_t n) -> SwigPyIterator



        """
        return _casadi.SwigPyIterator___isub__(self, *args)


    def __add__(self, *args) -> "swig::SwigPyIterator *":
        """


        __add__(self, ptrdiff_t n) -> SwigPyIterator



        """
        return _casadi.SwigPyIterator___add__(self, *args)


    def __sub__(self, *args) -> "ptrdiff_t":
        """


        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        __sub__(self, ptrdiff_t n) -> SwigPyIterator



        """
        return _casadi.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _casadi.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

L_INT = _casadi.L_INT
L_BOOL = _casadi.L_BOOL
LL = _casadi.LL
LR = _casadi.LR
L_DICT = _casadi.L_DICT
L_DOUBLE = _casadi.L_DOUBLE
L_STR = _casadi.L_STR
LABEL = _casadi.LABEL

if __name__ != "casadi.casadi":
  raise Exception("""
            CasADi is not running from its package context.

            You probably specified the wrong casadi directory.

            When setting PYTHONPATH or sys.path.append,
            take care not to add a trailing '/casadi'.

        """)

def swigtypeconvertor(*args):
  return swig_typename_convertor_python2cpp(args)

def swig_typename_convertor_python2cpp(a):
  try:
    import numpy as np
  except:
    class NoExist:
      pass
    class Temp(object):
      ndarray = NoExist
    np = Temp()
  if isinstance(a,list):
    if len(a)>0:
      return "[%s]" % "|".join(set([swig_typename_convertor_python2cpp(i) for i in a]))
    else:
      return "[]"
  elif isinstance(a,tuple):
    return "(%s)" % ",".join([swig_typename_convertor_python2cpp(i) for i in a])
  elif isinstance(a,np.ndarray):
    return "np.array(%s)" % ",".join(set([swig_typename_convertor_python2cpp(i) for i in np.array(a).flatten().tolist()]))
  elif isinstance(a,dict):
    if len(a)>0:
      return "|".join(set([swig_typename_convertor_python2cpp(i) for i in a.keys()])) +":"+ "|".join(set([swig_typename_convertor_python2cpp(i) for i in a.values()]))
    else:
      return "dict"
  return type(a).__name__


try:
  from numpy import pi, inf
except:
  pass

arcsin = lambda x: _casadi.asin(x)
arccos = lambda x: _casadi.acos(x)
arctan = lambda x: _casadi.atan(x)
arctan2 = lambda x,y: _casadi.atan2(x, y)
arctanh = lambda x: _casadi.atanh(x)
arcsinh = lambda x: _casadi.asinh(x)
arccosh = lambda x: _casadi.acosh(x)


def veccat(*args): return _veccat(args)
def vertcat(*args): return _vertcat(args)
def horzcat(*args): return _horzcat(args)
def diagcat(*args): return _diagcat(args)
def vvcat(args): return _veccat(args)
def vcat(args): return _vertcat(args)
def hcat(args): return _horzcat(args)
def dcat(args): return _diagcat(args)


class NZproxy:
  def __init__(self,matrix):
    self.matrix = matrix

  def __getitem__(self,s):
    return self.matrix.get_nz(False, s)

  def __setitem__(self,s,val):
    return self.matrix.set_nz(val, False, s)

  def __len__(self):
    return self.matrix.nnz()

class PrintSharedObject(_object):
    """
      Base class for objects that have a natural string representation.



    Joel Andersson

    C++ includes: printable_object.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSharedObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSharedObject, name)
    __repr__ = _swig_repr

    def __str__(self, *args) -> "std::string":
        """


        __str__(self) -> str



        """
        return _casadi.PrintSharedObject___str__(self, *args)


    def getRepresentation(self, *args) -> "std::string":
        """


        getRepresentation(self) -> str



        """
        return _casadi.PrintSharedObject_getRepresentation(self, *args)


    def __init__(self, *args):
        """


        PrintSharedObject()
        PrintSharedObject(PrintSharedObject other)



        """
        this = _casadi.new_PrintSharedObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_PrintSharedObject
PrintSharedObject_swigregister = _casadi.PrintSharedObject_swigregister
PrintSharedObject_swigregister(PrintSharedObject)

class PrintSlice(_object):
    """
      Base class for objects that have a natural string representation.



    Joel Andersson

    C++ includes: printable_object.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSlice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSlice, name)
    __repr__ = _swig_repr

    def __str__(self, *args) -> "std::string":
        """


        __str__(self) -> str



        """
        return _casadi.PrintSlice___str__(self, *args)


    def getRepresentation(self, *args) -> "std::string":
        """


        getRepresentation(self) -> str



        """
        return _casadi.PrintSlice_getRepresentation(self, *args)


    def __init__(self, *args):
        """


        PrintSlice()
        PrintSlice(PrintSlice other)



        """
        this = _casadi.new_PrintSlice(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_PrintSlice
PrintSlice_swigregister = _casadi.PrintSlice_swigregister
PrintSlice_swigregister(PrintSlice)

class PrintIM(_object):
    """
      Base class for objects that have a natural string representation.



    Joel Andersson

    C++ includes: printable_object.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintIM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintIM, name)
    __repr__ = _swig_repr

    def __str__(self, *args) -> "std::string":
        """


        __str__(self) -> str



        """
        return _casadi.PrintIM___str__(self, *args)


    def getRepresentation(self, *args) -> "std::string":
        """


        getRepresentation(self) -> str



        """
        return _casadi.PrintIM_getRepresentation(self, *args)


    def __init__(self, *args):
        """


        PrintIM()
        PrintIM(PrintIM other)



        """
        this = _casadi.new_PrintIM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_PrintIM
PrintIM_swigregister = _casadi.PrintIM_swigregister
PrintIM_swigregister(PrintIM)

class PrintDM(_object):
    """
      Base class for objects that have a natural string representation.



    Joel Andersson

    C++ includes: printable_object.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintDM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintDM, name)
    __repr__ = _swig_repr

    def __str__(self, *args) -> "std::string":
        """


        __str__(self) -> str



        """
        return _casadi.PrintDM___str__(self, *args)


    def getRepresentation(self, *args) -> "std::string":
        """


        getRepresentation(self) -> str



        """
        return _casadi.PrintDM_getRepresentation(self, *args)


    def __init__(self, *args):
        """


        PrintDM()
        PrintDM(PrintDM other)



        """
        this = _casadi.new_PrintDM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_PrintDM
PrintDM_swigregister = _casadi.PrintDM_swigregister
PrintDM_swigregister(PrintDM)

class PrintNlpBuilder(_object):
    """
      Base class for objects that have a natural string representation.



    Joel Andersson

    C++ includes: printable_object.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintNlpBuilder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintNlpBuilder, name)
    __repr__ = _swig_repr

    def __str__(self, *args) -> "std::string":
        """


        __str__(self) -> str



        """
        return _casadi.PrintNlpBuilder___str__(self, *args)


    def getRepresentation(self, *args) -> "std::string":
        """


        getRepresentation(self) -> str



        """
        return _casadi.PrintNlpBuilder_getRepresentation(self, *args)


    def __init__(self, *args):
        """


        PrintNlpBuilder()
        PrintNlpBuilder(PrintNlpBuilder other)



        """
        this = _casadi.new_PrintNlpBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_PrintNlpBuilder
PrintNlpBuilder_swigregister = _casadi.PrintNlpBuilder_swigregister
PrintNlpBuilder_swigregister(PrintNlpBuilder)

class PrintVariable(_object):
    """
      Base class for objects that have a natural string representation.



    Joel Andersson

    C++ includes: printable_object.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintVariable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintVariable, name)
    __repr__ = _swig_repr

    def __str__(self, *args) -> "std::string":
        """


        __str__(self) -> str



        """
        return _casadi.PrintVariable___str__(self, *args)


    def getRepresentation(self, *args) -> "std::string":
        """


        getRepresentation(self) -> str



        """
        return _casadi.PrintVariable_getRepresentation(self, *args)


    def __init__(self, *args):
        """


        PrintVariable()
        PrintVariable(PrintVariable other)



        """
        this = _casadi.new_PrintVariable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_PrintVariable
PrintVariable_swigregister = _casadi.PrintVariable_swigregister
PrintVariable_swigregister(PrintVariable)

class PrintDaeBuilder(_object):
    """
      Base class for objects that have a natural string representation.



    Joel Andersson

    C++ includes: printable_object.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintDaeBuilder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintDaeBuilder, name)
    __repr__ = _swig_repr

    def __str__(self, *args) -> "std::string":
        """


        __str__(self) -> str



        """
        return _casadi.PrintDaeBuilder___str__(self, *args)


    def getRepresentation(self, *args) -> "std::string":
        """


        getRepresentation(self) -> str



        """
        return _casadi.PrintDaeBuilder_getRepresentation(self, *args)


    def __init__(self, *args):
        """


        PrintDaeBuilder()
        PrintDaeBuilder(PrintDaeBuilder other)



        """
        this = _casadi.new_PrintDaeBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_PrintDaeBuilder
PrintDaeBuilder_swigregister = _casadi.PrintDaeBuilder_swigregister
PrintDaeBuilder_swigregister(PrintDaeBuilder)

class SharedObject(PrintSharedObject):
    """
      SharedObject implements a reference counting framework similar for efficient


    and easily-maintained memory management.

    To use the class, both the SharedObject class (the public class), and the
    SharedObjectInternal class (the internal class) must be inherited from. It
    can be done in two different files and together with memory management, this
    approach provides a clear distinction of which methods of the class are to
    be considered "public", i.e. methods for public use that can be considered
    to remain over time with small changes, and the internal memory.

    When interfacing a software, which typically includes including some header
    file, this is best done only in the file where the internal class is
    defined, to avoid polluting the global namespace and other side effects.

    The default constructor always means creating a null pointer to an internal
    class only. To allocate an internal class (this works only when the internal
    class isn't abstract), use the constructor with arguments.

    The copy constructor and the assignment operator perform shallow copies
    only, to make a deep copy you must use the clone method explicitly. This
    will give a shared pointer instance.

    In an inheritance hierarchy, you can cast down automatically, e.g. (
    SXFunction is a child class of Function): SXFunction derived(...); Function
    base = derived;

    To cast up, use the shared_cast template function, which works analogously
    to dynamic_cast, static_cast, const_cast etc, e.g.: SXFunction derived(...);
    Function base = derived; SXFunction derived_from_base =
    shared_cast<SXFunction>(base);

    A failed shared_cast will result in a null pointer (cf. dynamic_cast)

    Joel Andersson

    C++ includes: shared_object.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [PrintSharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SharedObject, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintSharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SharedObject, name)
    __repr__ = _swig_repr

    def printPtr(self, *args) -> "void":
        """
        [INTERNAL]  Print the pointer to the internal class

        printPtr(self)





        """
        return _casadi.SharedObject_printPtr(self, *args)


    def is_null(self, *args) -> "bool":
        """
        Is a null pointer?

        is_null(self) -> bool





        """
        return _casadi.SharedObject_is_null(self, *args)


    def __hash__(self, *args) -> "size_t":
        """
          Returns a number that is unique for a given Node. If the Object does not

          __hash__(self) -> size_t

        point to any node, "0" is returned.




        """
        return _casadi.SharedObject___hash__(self, *args)


    def __init__(self, *args):
        """


        SharedObject()
        SharedObject(SharedObject other)



        """
        this = _casadi.new_SharedObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SharedObject
SharedObject_swigregister = _casadi.SharedObject_swigregister
SharedObject_swigregister(SharedObject)

class WeakRef(SharedObject):
    """
      Weak reference type A weak reference to a SharedObject.



    Joel Andersson

    C++ includes: shared_object.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeakRef, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeakRef, name)
    __repr__ = _swig_repr

    def shared(self, *args) -> "casadi::SharedObject":
        """
        Get a shared (owning) reference.

        shared(self) -> SharedObject





        """
        return _casadi.WeakRef_shared(self, *args)


    def alive(self, *args) -> "bool":
        """
        Check if alive.

        alive(self) -> bool





        """
        return _casadi.WeakRef_alive(self, *args)


    def __init__(self, *args):
        """


          WeakRef(int dummy)
            Default constructor.
          WeakRef(WeakRef other)
          WeakRef(SharedObject shared)
            Construct from a shared object (also implicit type conversion)

        > WeakRef(WeakRef other)
        ------------------------------------------------------------------------

        > WeakRef(SharedObject shared)
        ------------------------------------------------------------------------


        Construct from a shared object (also implicit type conversion)


        > WeakRef(int dummy)
        ------------------------------------------------------------------------


        Default constructor.




        """
        this = _casadi.new_WeakRef(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_WeakRef
WeakRef_swigregister = _casadi.WeakRef_swigregister
WeakRef_swigregister(WeakRef)


def complement(*args) -> "std::vector< int,std::allocator< int > >":
    """
      Returns the list of all i in [0, size[ not found in supplied list.

      complement([int] v, int size) -> [int]


    The supplied vector may contain duplicates and may be non-monotonous The
    supplied vector will be checked for bounds The result vector is guaranteed
    to be monotonously increasing




    """
    return _casadi.complement(*args)

def lookupvector(*args) -> "std::vector< int,std::allocator< int > >":
    """


      lookupvector([int] v) -> [int]
      lookupvector([int] v, int size) -> [int]
        Returns a vector for quickly looking up entries of supplied list.

    > lookupvector([int] v)
    ------------------------------------------------------------------------



    > lookupvector([int] v, int size)
    ------------------------------------------------------------------------


    Returns a vector for quickly looking up entries of supplied list.

    lookupvector[i]!=-1 <=> v contains i v[lookupvector[i]] == i <=> v contains
    i

    Duplicates are treated by looking up last occurrence




    """
    return _casadi.lookupvector(*args)
SWIG_IND1 = _casadi.SWIG_IND1
class GenericType(_object):
    """
      Generic data type, can hold different types such as bool, int, string etc.



    Joel Andersson

    C++ includes: generic_type.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        GenericType()
        GenericType(GenericType other)



        """
        this = _casadi.new_GenericType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_GenericType
GenericType_swigregister = _casadi.GenericType_swigregister
GenericType_swigregister(GenericType)

OP_ASSIGN = _casadi.OP_ASSIGN
OP_ADD = _casadi.OP_ADD
OP_SUB = _casadi.OP_SUB
OP_MUL = _casadi.OP_MUL
OP_DIV = _casadi.OP_DIV
OP_NEG = _casadi.OP_NEG
OP_EXP = _casadi.OP_EXP
OP_LOG = _casadi.OP_LOG
OP_POW = _casadi.OP_POW
OP_CONSTPOW = _casadi.OP_CONSTPOW
OP_SQRT = _casadi.OP_SQRT
OP_SQ = _casadi.OP_SQ
OP_TWICE = _casadi.OP_TWICE
OP_SIN = _casadi.OP_SIN
OP_COS = _casadi.OP_COS
OP_TAN = _casadi.OP_TAN
OP_ASIN = _casadi.OP_ASIN
OP_ACOS = _casadi.OP_ACOS
OP_ATAN = _casadi.OP_ATAN
OP_LT = _casadi.OP_LT
OP_LE = _casadi.OP_LE
OP_EQ = _casadi.OP_EQ
OP_NE = _casadi.OP_NE
OP_NOT = _casadi.OP_NOT
OP_AND = _casadi.OP_AND
OP_OR = _casadi.OP_OR
OP_FLOOR = _casadi.OP_FLOOR
OP_CEIL = _casadi.OP_CEIL
OP_FMOD = _casadi.OP_FMOD
OP_FABS = _casadi.OP_FABS
OP_SIGN = _casadi.OP_SIGN
OP_COPYSIGN = _casadi.OP_COPYSIGN
OP_IF_ELSE_ZERO = _casadi.OP_IF_ELSE_ZERO
OP_ERF = _casadi.OP_ERF
OP_FMIN = _casadi.OP_FMIN
OP_FMAX = _casadi.OP_FMAX
OP_INV = _casadi.OP_INV
OP_SINH = _casadi.OP_SINH
OP_COSH = _casadi.OP_COSH
OP_TANH = _casadi.OP_TANH
OP_ASINH = _casadi.OP_ASINH
OP_ACOSH = _casadi.OP_ACOSH
OP_ATANH = _casadi.OP_ATANH
OP_ATAN2 = _casadi.OP_ATAN2
OP_CONST = _casadi.OP_CONST
OP_INPUT = _casadi.OP_INPUT
OP_OUTPUT = _casadi.OP_OUTPUT
OP_PARAMETER = _casadi.OP_PARAMETER
OP_CALL = _casadi.OP_CALL
OP_FIND = _casadi.OP_FIND
OP_MAP = _casadi.OP_MAP
OP_MTIMES = _casadi.OP_MTIMES
OP_SOLVE = _casadi.OP_SOLVE
OP_TRANSPOSE = _casadi.OP_TRANSPOSE
OP_DETERMINANT = _casadi.OP_DETERMINANT
OP_INVERSE = _casadi.OP_INVERSE
OP_DOT = _casadi.OP_DOT
OP_BILIN = _casadi.OP_BILIN
OP_RANK1 = _casadi.OP_RANK1
OP_HORZCAT = _casadi.OP_HORZCAT
OP_VERTCAT = _casadi.OP_VERTCAT
OP_DIAGCAT = _casadi.OP_DIAGCAT
OP_HORZSPLIT = _casadi.OP_HORZSPLIT
OP_VERTSPLIT = _casadi.OP_VERTSPLIT
OP_DIAGSPLIT = _casadi.OP_DIAGSPLIT
OP_RESHAPE = _casadi.OP_RESHAPE
OP_SUBREF = _casadi.OP_SUBREF
OP_SUBASSIGN = _casadi.OP_SUBASSIGN
OP_GETNONZEROS = _casadi.OP_GETNONZEROS
OP_ADDNONZEROS = _casadi.OP_ADDNONZEROS
OP_SETNONZEROS = _casadi.OP_SETNONZEROS
OP_PROJECT = _casadi.OP_PROJECT
OP_ASSERTION = _casadi.OP_ASSERTION
OP_MONITOR = _casadi.OP_MONITOR
OP_NORM2 = _casadi.OP_NORM2
OP_NORM1 = _casadi.OP_NORM1
OP_NORMINF = _casadi.OP_NORMINF
OP_NORMF = _casadi.OP_NORMF
OP_HORZREPMAT = _casadi.OP_HORZREPMAT
OP_HORZREPSUM = _casadi.OP_HORZREPSUM
OP_ERFINV = _casadi.OP_ERFINV
OP_PRINTME = _casadi.OP_PRINTME
OP_LIFT = _casadi.OP_LIFT
OP_EINSTEIN = _casadi.OP_EINSTEIN
class SparsityInterfaceCommon(_object):
    """


    SparsityInterfaceCommon() -> 



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparsityInterfaceCommon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SparsityInterfaceCommon, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        SparsityInterfaceCommon()
        SparsityInterfaceCommon(SparsityInterfaceCommon other)



        """
        this = _casadi.new_SparsityInterfaceCommon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SparsityInterfaceCommon
SparsityInterfaceCommon_swigregister = _casadi.SparsityInterfaceCommon_swigregister
SparsityInterfaceCommon_swigregister(SparsityInterfaceCommon)

class SpSparsity(SparsityInterfaceCommon):
    """
      Sparsity interface class.



    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpSparsity, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpSparsity, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        SpSparsity()
        SpSparsity(SpSparsity other)



        """
        this = _casadi.new_SpSparsity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SpSparsity
SpSparsity_swigregister = _casadi.SpSparsity_swigregister
SpSparsity_swigregister(SpSparsity)

class Sparsity(SharedObject, SpSparsity):
    """
      General sparsity class.



    The storage format is a compressed column storage (CCS) format.  In this
    format, the structural non-zero elements are stored in column-major order,
    starting from the upper left corner of the matrix and ending in the lower
    right corner.

    In addition to the dimension ( size1(), size2()), (i.e. the number of rows
    and the number of columns respectively), there are also two vectors of
    integers:

    "colind" [length size2()+1], which contains the index to the first non-
    zero element on or after the corresponding column. All the non-zero elements
    of a particular i are thus the elements with index el that fulfills:
    colind[i] <= el < colind[i+1].

    "row" [same length as the number of non-zero elements, nnz()] The rows for
    each of the structural non-zeros.

    Note that with this format, it is cheap to loop over all the non-zero
    elements of a particular column, at constant time per element, but expensive
    to jump to access a location (i, j).

    If the matrix is dense, i.e. length(row) == size1()*size2(), the format
    reduces to standard dense column major format, which allows access to an
    arbitrary element in constant time.

    Since the object is reference counted (it inherits from SharedObject),
    several matrices are allowed to share the same sparsity pattern.

    The implementations of some methods of this class has been taken from the
    CSparse package and modified to use C++ standard library and CasADi data
    structures.

    See:   Matrix

    Joel Andersson

    C++ includes: sparsity.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SharedObject, SpSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sparsity, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject, SpSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sparsity, name)
    __repr__ = _swig_repr

    def scalar(*args) -> "casadi::Sparsity":
        """
        Create a scalar sparsity pattern.

        scalar(bool dense_scalar) -> Sparsity





        """
        return _casadi.Sparsity_scalar(*args)

    scalar = staticmethod(scalar)

    def dense(*args) -> "casadi::Sparsity":
        """
        Create a dense rectangular sparsity pattern.

        dense(int nrow, int ncol) -> Sparsity
        dense((int,int) rc) -> Sparsity





        """
        return _casadi.Sparsity_dense(*args)

    dense = staticmethod(dense)

    def unit(*args) -> "casadi::Sparsity":
        """
          Create the sparsity pattern for a unit vector of length n and a nonzero on

          unit(int n, int el) -> Sparsity

        position el.




        """
        return _casadi.Sparsity_unit(*args)

    unit = staticmethod(unit)

    def upper(*args) -> "casadi::Sparsity":
        """


        upper(int n) -> Sparsity



        """
        return _casadi.Sparsity_upper(*args)

    upper = staticmethod(upper)

    def lower(*args) -> "casadi::Sparsity":
        """


        lower(int n) -> Sparsity



        """
        return _casadi.Sparsity_lower(*args)

    lower = staticmethod(lower)

    def diag(*args) -> "casadi::Sparsity":
        """
        Create diagonal sparsity pattern.

        diag(int nrow) -> Sparsity
        diag((int,int) rc) -> Sparsity
        diag(int nrow, int ncol) -> Sparsity





        """
        return _casadi.Sparsity_diag(*args)

    diag = staticmethod(diag)

    def band(*args) -> "casadi::Sparsity":
        """


        band(int n, int p) -> Sparsity



        """
        return _casadi.Sparsity_band(*args)

    band = staticmethod(band)

    def banded(*args) -> "casadi::Sparsity":
        """


        banded(int n, int p) -> Sparsity



        """
        return _casadi.Sparsity_banded(*args)

    banded = staticmethod(banded)

    def rowcol(*args) -> "casadi::Sparsity":
        """


        rowcol([int] row, [int] col, int nrow, int ncol) -> Sparsity



        """
        return _casadi.Sparsity_rowcol(*args)

    rowcol = staticmethod(rowcol)

    def triplet(*args) -> "casadi::Sparsity":
        """


        triplet(int nrow, int ncol, [int] row, [int] col) -> Sparsity
        triplet(int nrow, int ncol, [int] row, [int] col, bool invert_mapping) -> (Sparsity , [int] OUTPUT)



        """
        return _casadi.Sparsity_triplet(*args)

    triplet = staticmethod(triplet)

    def compressed(*args) -> "casadi::Sparsity":
        """
          Create from a single vector containing the pattern in compressed column

          compressed([int] v) -> Sparsity

        storage format: The format: The first two entries are the number of rows
        (nrow) and columns (ncol) The next ncol+1 entries are the column offsets
        (colind). Note that the last element, colind[ncol], gives the number of
        nonzeros The last colind[ncol] entries are the row indices




        """
        return _casadi.Sparsity_compressed(*args)

    compressed = staticmethod(compressed)

    def sanity_check(self, *args) -> "void":
        """
          Check if the dimensions and colind, row vectors are compatible.

          sanity_check(self, bool complete)


        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result




        """
        return _casadi.Sparsity_sanity_check(self, *args)


    def get_diag(self, *args) -> "casadi::Sparsity":
        """
          Get the diagonal of the matrix/create a diagonal matrix (mapping will

          get_diag(self) -> (Sparsity , [int] OUTPUT)

        contain the nonzero mapping) When the input is square, the diagonal elements
        are returned. If the input is vector-like, a diagonal matrix is constructed
        with it.




        """
        return _casadi.Sparsity_get_diag(self, *args)


    def compress(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
        Compress a sparsity pattern.

        compress(self) -> [int]





        """
        return _casadi.Sparsity_compress(self, *args)


    def is_equal(self, *args) -> "bool":
        """


        is_equal(self, Sparsity y) -> bool
        is_equal(self, int nrow, int ncol, [int] colind, [int] row) -> bool



        """
        return _casadi.Sparsity_is_equal(self, *args)


    def __eq__(self, *args) -> "bool":
        """


        __eq__(self, Sparsity y) -> bool



        """
        return _casadi.Sparsity___eq__(self, *args)


    def __ne__(self, *args) -> "bool":
        """


        __ne__(self, Sparsity y) -> bool



        """
        return _casadi.Sparsity___ne__(self, *args)


    def size1(self, *args) -> "int":
        """
        Get the number of rows.

        size1(self) -> int





        """
        return _casadi.Sparsity_size1(self, *args)


    def size2(self, *args) -> "int":
        """
        Get the number of columns.

        size2(self) -> int





        """
        return _casadi.Sparsity_size2(self, *args)


    def numel(self, *args) -> "int":
        """
          The total number of elements, including structural zeros, i.e.

          numel(self) -> int

        size2()*size1()

        See:   nnz()




        """
        return _casadi.Sparsity_numel(self, *args)


    def is_empty(self, *args) -> "bool":
        """
          Check if the sparsity is empty.

          is_empty(self, bool both) -> bool


        A sparsity is considered empty if one of the dimensions is zero (or
        optionally both dimensions)




        """
        return _casadi.Sparsity_is_empty(self, *args)


    def nnz(self, *args) -> "int":
        """
          Get the number of (structural) non-zeros.

          nnz(self) -> int


        See:   numel()




        """
        return _casadi.Sparsity_nnz(self, *args)


    def nnz_upper(self, *args) -> "int":
        """
          Number of non-zeros in the upper triangular half, i.e. the number of

          nnz_upper(self, bool strictly) -> int

        elements (i, j) with j>=i.




        """
        return _casadi.Sparsity_nnz_upper(self, *args)


    def nnz_lower(self, *args) -> "int":
        """
          Number of non-zeros in the lower triangular half, i.e. the number of

          nnz_lower(self, bool strictly) -> int

        elements (i, j) with j<=i.




        """
        return _casadi.Sparsity_nnz_lower(self, *args)


    def nnz_diag(self, *args) -> "int":
        """
          Number of non-zeros on the diagonal, i.e. the number of elements (i, j) with

          nnz_diag(self) -> int

        j==i.




        """
        return _casadi.Sparsity_nnz_diag(self, *args)


    def bw_upper(self, *args) -> "int":
        """
        Upper half-bandwidth.

        bw_upper(self) -> int





        """
        return _casadi.Sparsity_bw_upper(self, *args)


    def bw_lower(self, *args) -> "int":
        """
        Lower half-bandwidth.

        bw_lower(self) -> int





        """
        return _casadi.Sparsity_bw_lower(self, *args)


    def size(self, *args) -> "int":
        """
          Get the size along a particular dimensions.

          size(self) -> (int,int)
            Get the shape.
          size(self, int axis) -> int



        > size(self)
        ------------------------------------------------------------------------


        Get the shape.


        > size(self, int axis)
        ------------------------------------------------------------------------


        Get the size along a particular dimensions.




        """
        return _casadi.Sparsity_size(self, *args)


    def colind(self, *args) -> "int":
        """
          Get a reference to the colindex of column cc (see class description)

          colind(self) -> [int]
            Get the column index for each column Together with the row-vector, one
          colind(self, int cc) -> int



        > colind(self)
        ------------------------------------------------------------------------


        Get the column index for each column Together with the row-vector, one
        obtains the sparsity pattern in the column compressed format.


        > colind(self, int cc)
        ------------------------------------------------------------------------


        Get a reference to the colindex of column cc (see class description)




        """
        return _casadi.Sparsity_colind(self, *args)


    def row(self, *args) -> "int":
        """
          Get the row of a non-zero element.

          row(self) -> [int]
            Get the row for each non-zero entry Together with the column-vector, this
          row(self, int el) -> int



        > row(self, int el)
        ------------------------------------------------------------------------


        Get the row of a non-zero element.


        > row(self)
        ------------------------------------------------------------------------


        Get the row for each non-zero entry Together with the column-vector, this
        vector gives the sparsity of the matrix in sparse triplet format, and
        together with the colind vector, one obtains the sparsity in column
        compressed format.




        """
        return _casadi.Sparsity_row(self, *args)


    def get_col(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
          Get the column for each non-zero entry Together with the row-vector, this

          get_col(self) -> [int]

        vector gives the sparsity of the matrix in sparse triplet format, i.e. the
        column and row for each non-zero elements.




        """
        return _casadi.Sparsity_get_col(self, *args)


    def resize(self, *args) -> "void":
        """
        Resize.

        resize(self, int nrow, int ncol)





        """
        return _casadi.Sparsity_resize(self, *args)


    def add_nz(self, *args) -> "int":
        """
          Get the index of a non-zero element Add the element if it does not exist and

          add_nz(self, int rr, int cc) -> int

        copy object if it's not unique.




        """
        return _casadi.Sparsity_add_nz(self, *args)


    def has_nz(self, *args) -> "bool":
        """
        Returns true if the pattern has a non-zero at location rr, cc.

        has_nz(self, int rr, int cc) -> bool





        """
        return _casadi.Sparsity_has_nz(self, *args)


    def get_nz(self, *args) -> "void":
        """
          Get the nonzero index for a set of elements The index vector is used both

          get_nz(self) -> [int]
          get_nz(self, int rr, int cc) -> int
            Get the index of an existing non-zero element return -1 if the element does
          get_nz(self, [int] rr, [int] cc) -> [int]
            Get a set of non-zero element return -1 if the element does not exist.

        for input and outputs and must be sorted by increasing nonzero index, i.e.
        column-wise. Elements not found in the sparsity pattern are set to -1.


        > get_nz(self, int rr, int cc)
        ------------------------------------------------------------------------


        Get the index of an existing non-zero element return -1 if the element does
        not exist.


        > get_nz(self)
        ------------------------------------------------------------------------


        Get the nonzero index for a set of elements The index vector is used both
        for input and outputs and must be sorted by increasing nonzero index, i.e.
        column-wise. Elements not found in the sparsity pattern are set to -1.


        > get_nz(self, [int] rr, [int] cc)
        ------------------------------------------------------------------------


        Get a set of non-zero element return -1 if the element does not exist.




        """
        return _casadi.Sparsity_get_nz(self, *args)


    def get_lower(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
        Get nonzeros in lower triangular part.

        get_lower(self) -> [int]





        """
        return _casadi.Sparsity_get_lower(self, *args)


    def get_upper(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
        Get nonzeros in upper triangular part.

        get_upper(self) -> [int]





        """
        return _casadi.Sparsity_get_upper(self, *args)


    def get_ccs(self, *args) -> "void":
        """
        Get the sparsity in compressed column storage (CCS) format.

        get_ccs(self) -> ([int] OUTPUT, [int] OUTPUT)





        """
        return _casadi.Sparsity_get_ccs(self, *args)


    def get_crs(self, *args) -> "void":
        """
        Get the sparsity in compressed row storage (CRS) format.

        get_crs(self) -> ([int] OUTPUT, [int] OUTPUT)





        """
        return _casadi.Sparsity_get_crs(self, *args)


    def get_triplet(self, *args) -> "void":
        """
        Get the sparsity in sparse triplet format.

        get_triplet(self) -> ([int] OUTPUT, [int] OUTPUT)





        """
        return _casadi.Sparsity_get_triplet(self, *args)


    def sub(self, *args) -> "casadi::Sparsity":
        """
          Get a set of elements.

          sub(self, [int] rr, Sparsity sp, bool ind1) -> (Sparsity , [int] OUTPUT)
          sub(self, [int] rr, [int] cc, bool ind1) -> (Sparsity , [int] OUTPUT)
            Get a submatrix.


        Returns the sparsity of the corresponding elements, with a mapping such that
        submatrix[k] = originalmatrix[mapping[k]]


        > sub(self, [int] rr, Sparsity sp, bool ind1)
        ------------------------------------------------------------------------


        Get a set of elements.

        Returns the sparsity of the corresponding elements, with a mapping such that
        submatrix[k] = originalmatrix[mapping[k]]


        > sub(self, [int] rr, [int] cc, bool ind1)
        ------------------------------------------------------------------------


        Get a submatrix.

        Returns the sparsity of the submatrix, with a mapping such that submatrix[k]
        = originalmatrix[mapping[k]]




        """
        return _casadi.Sparsity_sub(self, *args)


    def transpose(self, *args) -> "casadi::Sparsity":
        """
          Transpose the matrix and get the reordering of the non-zero entries.

          transpose(self, bool invert_mapping) -> (Sparsity , [int] OUTPUT)


        Parameters:
        -----------

        mapping:  the non-zeros of the original matrix for each non-zero of the new
        matrix




        """
        return _casadi.Sparsity_transpose(self, *args)


    def is_transpose(self, *args) -> "bool":
        """
        Check if the sparsity is the transpose of another.

        is_transpose(self, Sparsity y) -> bool





        """
        return _casadi.Sparsity_is_transpose(self, *args)


    def isReshape(self, *args) -> "bool":
        """
        Check if the sparsity is a reshape of another.

        isReshape(self, Sparsity y) -> bool





        """
        return _casadi.Sparsity_isReshape(self, *args)


    def combine(self, *args) -> "casadi::Sparsity":
        """
          Combine two sparsity patterns Returns the new sparsity pattern as well as a

          combine(self, Sparsity y, bool f0x_is_zero, bool fx0_is_zero) -> Sparsity

        mapping with the same length as the number of non-zero elements The mapping
        matrix contains the arguments for each nonzero, the first bit indicates if
        the first argument is nonzero, the second bit indicates if the second
        argument is nonzero (note that none of, one of or both of the arguments can
        be nonzero)




        """
        return _casadi.Sparsity_combine(self, *args)


    def unite(self, *args) -> "casadi::Sparsity":
        """
        Union of two sparsity patterns.

        unite(self, Sparsity y) -> Sparsity





        """
        return _casadi.Sparsity_unite(self, *args)


    def __add__(self, *args) -> "casadi::Sparsity":
        """


        __add__(self, Sparsity b) -> Sparsity



        """
        return _casadi.Sparsity___add__(self, *args)


    def intersect(self, *args) -> "casadi::Sparsity":
        """
          Intersection of two sparsity patterns Returns the new sparsity pattern as

          intersect(self, Sparsity y) -> Sparsity

        well as a mapping with the same length as the number of non-zero elements
        The value is 1 if the non-zero comes from the first (i.e. this) object, 2 if
        it is from the second and 3 (i.e. 1 | 2) if from both.




        """
        return _casadi.Sparsity_intersect(self, *args)


    def __mul__(self, *args) -> "casadi::Sparsity":
        """


        __mul__(self, Sparsity b) -> Sparsity



        """
        return _casadi.Sparsity___mul__(self, *args)


    def pattern_inverse(self, *args) -> "casadi::Sparsity":
        """
        Take the inverse of a sparsity pattern; flip zeros and non-zeros.

        pattern_inverse(self) -> Sparsity





        """
        return _casadi.Sparsity_pattern_inverse(self, *args)


    def enlarge(self, *args) -> "void":
        """
          Enlarge matrix Make the matrix larger by inserting empty rows and columns,

          enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)

        keeping the existing non-zeros.

        For the matrices A to B A(m, n) length(jj)=m , length(ii)=n B(nrow, ncol)

        A=enlarge(m, n, ii, jj) makes sure that

        B[jj, ii] == A




        """
        return _casadi.Sparsity_enlarge(self, *args)


    def enlargeRows(self, *args) -> "void":
        """
        Enlarge the matrix along the first dimension (i.e. insert rows)

        enlargeRows(self, int nrow, [int] rr, bool ind1)





        """
        return _casadi.Sparsity_enlargeRows(self, *args)


    def enlargeColumns(self, *args) -> "void":
        """
        Enlarge the matrix along the second dimension (i.e. insert columns)

        enlargeColumns(self, int ncol, [int] cc, bool ind1)





        """
        return _casadi.Sparsity_enlargeColumns(self, *args)


    def makeDense(self, *args) -> "casadi::Sparsity":
        """
        Make a patten dense.

        makeDense(self) -> (Sparsity , [int] OUTPUT)





        """
        return _casadi.Sparsity_makeDense(self, *args)


    def erase(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
          Erase elements of a matrix.

          erase(self, [int] rr, bool ind1) -> [int]
          erase(self, [int] rr, [int] cc, bool ind1) -> [int]
            Erase rows and/or columns of a matrix.



        > erase(self, [int] rr, bool ind1)
        ------------------------------------------------------------------------


        Erase elements of a matrix.


        > erase(self, [int] rr, [int] cc, bool ind1)
        ------------------------------------------------------------------------


        Erase rows and/or columns of a matrix.




        """
        return _casadi.Sparsity_erase(self, *args)


    def append(self, *args) -> "void":
        """
        Append another sparsity patten vertically (NOTE: only efficient if vector)

        append(self, Sparsity sp)





        """
        return _casadi.Sparsity_append(self, *args)


    def appendColumns(self, *args) -> "void":
        """
        Append another sparsity patten horizontally.

        appendColumns(self, Sparsity sp)





        """
        return _casadi.Sparsity_appendColumns(self, *args)


    def is_scalar(self, *args) -> "bool":
        """
        Is scalar?

        is_scalar(self, bool scalar_and_dense) -> bool





        """
        return _casadi.Sparsity_is_scalar(self, *args)


    def is_dense(self, *args) -> "bool":
        """
        Is dense?

        is_dense(self) -> bool





        """
        return _casadi.Sparsity_is_dense(self, *args)


    def is_row(self, *args) -> "bool":
        """
        Check if the pattern is a row vector (i.e. size1()==1)

        is_row(self) -> bool





        """
        return _casadi.Sparsity_is_row(self, *args)


    def is_column(self, *args) -> "bool":
        """
        Check if the pattern is a column vector (i.e. size2()==1)

        is_column(self) -> bool





        """
        return _casadi.Sparsity_is_column(self, *args)


    def is_vector(self, *args) -> "bool":
        """
        Check if the pattern is a row or column vector.

        is_vector(self) -> bool





        """
        return _casadi.Sparsity_is_vector(self, *args)


    def is_diag(self, *args) -> "bool":
        """
        Is diagonal?

        is_diag(self) -> bool





        """
        return _casadi.Sparsity_is_diag(self, *args)


    def is_square(self, *args) -> "bool":
        """
        Is square?

        is_square(self) -> bool





        """
        return _casadi.Sparsity_is_square(self, *args)


    def is_symmetric(self, *args) -> "bool":
        """
        Is symmetric?

        is_symmetric(self) -> bool





        """
        return _casadi.Sparsity_is_symmetric(self, *args)


    def is_triu(self, *args) -> "bool":
        """
        Is upper triangular?

        is_triu(self) -> bool





        """
        return _casadi.Sparsity_is_triu(self, *args)


    def is_tril(self, *args) -> "bool":
        """
        Is lower triangular?

        is_tril(self) -> bool





        """
        return _casadi.Sparsity_is_tril(self, *args)


    def is_singular(self, *args) -> "bool":
        """
        Check whether the sparsity-pattern indicates structural singularity.

        is_singular(self) -> bool





        """
        return _casadi.Sparsity_is_singular(self, *args)


    def rowsSequential(self, *args) -> "bool":
        """
          Do the rows appear sequentially on each column.

          rowsSequential(self, bool strictly) -> bool


        Parameters:
        -----------

        strictly:  if true, then do not allow multiple entries




        """
        return _casadi.Sparsity_rowsSequential(self, *args)


    def removeDuplicates(self, *args) -> "void":
        """
          Remove duplicate entries.

          removeDuplicates(self) -> [int]


        The same indices will be removed from the mapping vector, which must have
        the same length as the number of nonzeros




        """
        return _casadi.Sparsity_removeDuplicates(self, *args)


    def etree(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
          Calculate the elimination tree See Direct Methods for Sparse Linear Systems

          etree(self, bool ata) -> [int]

        by Davis (2006). If the parameter ata is false, the algorithm is equivalent
        to MATLAB's etree(A), except that the indices are zero- based. If ata is
        true, the algorithm is equivalent to MATLAB's etree(A, 'col').




        """
        return _casadi.Sparsity_etree(self, *args)


    def dfs(self, *args) -> "int":
        """
          Depth-first search on the adjacency graph of the sparsity See Direct Methods

          dfs(self, int j, int top, [int] pinv) -> (int , [int] INOUT, [int] INOUT, [bool] INOUT)

        for Sparse Linear Systems by Davis (2006).




        """
        return _casadi.Sparsity_dfs(self, *args)


    def scc(self, *args) -> "int":
        """
          Find the strongly connected components of the bigraph defined by the

          scc(self) -> (int , [int] OUTPUT, [int] OUTPUT)

        sparsity pattern of a square matrix.

        See Direct Methods for Sparse Linear Systems by Davis (2006). Returns:
        Number of components

        Offset for each components (length: 1 + number of components)

        Indices for each components, component i has indices index[offset[i]], ...,
        index[offset[i+1]]

        In the case that the matrix is symmetric, the result has a particular
        interpretation: Given a symmetric matrix A and n = A.scc(p, r)

        => A[p, p] will appear block-diagonal with n blocks and with the indices of
        the block boundaries to be found in r.




        """
        return _casadi.Sparsity_scc(self, *args)


    def btf(self, *args) -> "int":
        """
          Calculate the block triangular form (BTF) See Direct Methods for Sparse

          btf(self) -> (int , [int] OUTPUT, [int] OUTPUT, [int] OUTPUT, [int] OUTPUT, [int] OUTPUT, [int] OUTPUT)

        Linear Systems by Davis (2006).

        The function computes the Dulmage-Mendelsohn decomposition, which allows you
        to reorder the rows and columns of a matrix to bring it into block
        triangular form (BTF).

        It will not consider the distance of off-diagonal elements to the diagonal:
        there is no guarantee you will get a block-diagonal matrix if you supply a
        randomly permuted block-diagonal matrix.

        If your matrix is symmetrical, this method is of limited use; permutation
        can make it non-symmetric.

        See:   scc




        """
        return _casadi.Sparsity_btf(self, *args)


    def find(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
          Get the location of all non-zero elements as they would appear in a Dense

          find(self, bool ind1) -> [int]

        matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-
        zeros.

        k = A.find() A[k] will contain the elements of A that are non-zero in B




        """
        return _casadi.Sparsity_find(self, *args)


    def uni_coloring(self, *args) -> "casadi::Sparsity":
        """
          Perform a unidirectional coloring: A greedy distance-2 coloring algorithm

          uni_coloring(self, Sparsity AT, int cutoff) -> Sparsity

        (Algorithm 3.1 in A. H. GEBREMEDHIN, F. MANNE, A. POTHEN)




        """
        return _casadi.Sparsity_uni_coloring(self, *args)


    def star_coloring(self, *args) -> "casadi::Sparsity":
        """
          Perform a star coloring of a symmetric matrix: A greedy distance-2 coloring

          star_coloring(self, int ordering, int cutoff) -> Sparsity

        algorithm Algorithm 4.1 in What Color Is Your Jacobian? Graph Coloring for
        Computing Derivatives A. H. GEBREMEDHIN, F. MANNE, A. POTHEN SIAM Rev.,
        47(4), 629705 (2006)

        Ordering options: None (0), largest first (1)




        """
        return _casadi.Sparsity_star_coloring(self, *args)


    def star_coloring2(self, *args) -> "casadi::Sparsity":
        """
          Perform a star coloring of a symmetric matrix: A new greedy distance-2

          star_coloring2(self, int ordering, int cutoff) -> Sparsity

        coloring algorithm Algorithm 4.1 in NEW ACYCLIC AND STAR COLORING ALGORITHMS
        WITH APPLICATION TO COMPUTING HESSIANS A. H. GEBREMEDHIN, A. TARAFDAR, F.
        MANNE, A. POTHEN SIAM J. SCI. COMPUT. Vol. 29, No. 3, pp. 10421072 (2007)

        Ordering options: None (0), largest first (1)




        """
        return _casadi.Sparsity_star_coloring2(self, *args)


    def largest_first(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
        Order the columns by decreasing degree.

        largest_first(self) -> [int]





        """
        return _casadi.Sparsity_largest_first(self, *args)


    def pmult(self, *args) -> "casadi::Sparsity":
        """
          Permute rows and/or columns Multiply the sparsity with a permutation matrix

          pmult(self, [int] p, bool permute_rows, bool permute_columns, bool invert_permutation) -> Sparsity

        from the left and/or from the right P * A * trans(P), A * trans(P) or A *
        trans(P) with P defined by an index vector containing the row for each col.
        As an alternative, P can be transposed (inverted).




        """
        return _casadi.Sparsity_pmult(self, *args)


    def dim(self, *args) -> "std::string":
        """
        Get the dimension as a string.

        dim(self) -> str





        """
        return _casadi.Sparsity_dim(self, *args)


    def repr_el(self, *args) -> "std::string":
        """
        Describe the nonzero location k as a string.

        repr_el(self, int k) -> str





        """
        return _casadi.Sparsity_repr_el(self, *args)


    def spy(self, *args) -> "void":
        """
        Print a textual representation of sparsity.

        spy(self)





        """
        return _casadi.Sparsity_spy(self, *args)


    def spy_matlab(self, *args) -> "void":
        """
          Generate a script for Matlab or Octave which visualizes the sparsity using

          spy_matlab(self, str mfile)

        the spy command.




        """
        return _casadi.Sparsity_spy_matlab(self, *args)


    def print_compact(self, *args) -> "void":
        """
        Print a compact description of the sparsity pattern.

        print_compact(self)





        """
        return _casadi.Sparsity_print_compact(self, *args)


    def hash(self, *args) -> "std::size_t":
        """


        hash(self) -> std::size_t



        """
        return _casadi.Sparsity_hash(self, *args)


    def test_cast(*args) -> "bool":
        """


        test_cast(casadi::SharedObjectInternal const * ptr) -> bool



        """
        return _casadi.Sparsity_test_cast(*args)

    test_cast = staticmethod(test_cast)

    def __setstate__(self, state):
        if state:
          self.__init__(state["nrow"],state["ncol"],state["colind"],state["row"])
        else:
          self.__init__()

    def __getstate__(self):
        if self.is_null(): return {}
        return {"nrow": self.size1(), "ncol": self.size2(), "colind": numpy.array(self.colind(),dtype=int), "row": numpy.array(self.row(),dtype=int)}


    @property
    def shape(self):
        return (self.size1(),self.size2())

    @property
    def T(self):
        return _casadi.transpose(self)

    def __array__(self,*args,**kwargs):
        return DM.ones(self).full()


    def __init__(self, *args):
        """


          Sparsity(int dummy)
            Default constructor.
          Sparsity((int,int) rc)
            Create a sparse matrix with all structural zeros.
          Sparsity(Sparsity other)
          Sparsity(int nrow, int ncol)
            Pattern with all structural zeros.
          Sparsity(int nrow, int ncol, [int] colind, [int] row)
            Construct from sparsity pattern vectors given in compressed column storage

        > Sparsity(Sparsity other)
        ------------------------------------------------------------------------

        > Sparsity(int nrow, int ncol)
        ------------------------------------------------------------------------


        Pattern with all structural zeros.


        > Sparsity(int nrow, int ncol, [int] colind, [int] row)
        ------------------------------------------------------------------------


        Construct from sparsity pattern vectors given in compressed column storage
        format.


        > Sparsity(int dummy)
        ------------------------------------------------------------------------


        Default constructor.


        > Sparsity((int,int) rc)
        ------------------------------------------------------------------------


        Create a sparse matrix with all structural zeros.




        """
        this = _casadi.new_Sparsity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_Sparsity
Sparsity_swigregister = _casadi.Sparsity_swigregister
Sparsity_swigregister(Sparsity)

def Sparsity_scalar(*args) -> "casadi::Sparsity":
    """
    Create a scalar sparsity pattern.

    scalar(bool dense_scalar) -> Sparsity





    """
    return _casadi.Sparsity_scalar(*args)

def Sparsity_dense(*args) -> "casadi::Sparsity":
    """
    Create a dense rectangular sparsity pattern.

    dense(int nrow, int ncol) -> Sparsity
    dense((int,int) rc) -> Sparsity





    """
    return _casadi.Sparsity_dense(*args)

def Sparsity_unit(*args) -> "casadi::Sparsity":
    """
      Create the sparsity pattern for a unit vector of length n and a nonzero on

      unit(int n, int el) -> Sparsity

    position el.




    """
    return _casadi.Sparsity_unit(*args)

def Sparsity_upper(*args) -> "casadi::Sparsity":
    """


    upper(int n) -> Sparsity



    """
    return _casadi.Sparsity_upper(*args)

def Sparsity_lower(*args) -> "casadi::Sparsity":
    """


    lower(int n) -> Sparsity



    """
    return _casadi.Sparsity_lower(*args)

def Sparsity_diag(*args) -> "casadi::Sparsity":
    """
    Create diagonal sparsity pattern.

    diag(int nrow) -> Sparsity
    diag((int,int) rc) -> Sparsity
    diag(int nrow, int ncol) -> Sparsity





    """
    return _casadi.Sparsity_diag(*args)

def Sparsity_band(*args) -> "casadi::Sparsity":
    """


    band(int n, int p) -> Sparsity



    """
    return _casadi.Sparsity_band(*args)

def Sparsity_banded(*args) -> "casadi::Sparsity":
    """


    banded(int n, int p) -> Sparsity



    """
    return _casadi.Sparsity_banded(*args)

def Sparsity_rowcol(*args) -> "casadi::Sparsity":
    """


    rowcol([int] row, [int] col, int nrow, int ncol) -> Sparsity



    """
    return _casadi.Sparsity_rowcol(*args)

def Sparsity_triplet(*args) -> "casadi::Sparsity":
    """


    triplet(int nrow, int ncol, [int] row, [int] col) -> Sparsity
    triplet(int nrow, int ncol, [int] row, [int] col, bool invert_mapping) -> (Sparsity , [int] OUTPUT)



    """
    return _casadi.Sparsity_triplet(*args)

def Sparsity_compressed(*args) -> "casadi::Sparsity":
    """
      Create from a single vector containing the pattern in compressed column

      compressed([int] v) -> Sparsity

    storage format: The format: The first two entries are the number of rows
    (nrow) and columns (ncol) The next ncol+1 entries are the column offsets
    (colind). Note that the last element, colind[ncol], gives the number of
    nonzeros The last colind[ncol] entries are the row indices




    """
    return _casadi.Sparsity_compressed(*args)

def Sparsity_test_cast(*args) -> "bool":
    """


    test_cast(casadi::SharedObjectInternal const * ptr) -> bool



    """
    return _casadi.Sparsity_test_cast(*args)


def hash_combine(*args) -> "void":
    """
      Generate a hash value incrementally (function taken from boost)

      hash_combine(std::size_t & seed, [int] v)
      hash_combine(std::size_t & seed, int const * v, int sz)
        Generate a hash value incrementally, array.



    > hash_combine(std::size_t & seed, [int] v)
    ------------------------------------------------------------------------


    Generate a hash value incrementally (function taken from boost)


    > hash_combine(std::size_t & seed, int const * v, int sz)
    ------------------------------------------------------------------------


    Generate a hash value incrementally, array.




    """
    return _casadi.hash_combine(*args)

def hash_sparsity(*args) -> "std::size_t":
    """


      hash_sparsity(int nrow, int ncol, int const * colind, int const * row) -> std::size_t
      hash_sparsity(int nrow, int ncol, [int] colind, [int] row) -> std::size_t
        Hash a sparsity pattern.

    > hash_sparsity(int nrow, int ncol, int const * colind, int const * row)
    ------------------------------------------------------------------------



    > hash_sparsity(int nrow, int ncol, [int] colind, [int] row)
    ------------------------------------------------------------------------


    Hash a sparsity pattern.




    """
    return _casadi.hash_sparsity(*args)
class Slice(PrintSlice):
    """
      Class representing a Slice.



    Note that Python or Octave do not need to use this class. They can just use
    slicing utility from the host language ( M[0:6] in Python, M(1:7) )

    C++ includes: slice.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [PrintSlice]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Slice, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintSlice]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Slice, name)
    __repr__ = _swig_repr
    __swig_getmethods__["start"] = _casadi.Slice_start_get
    if _newclass:
        start = _swig_property(_casadi.Slice_start_get)
    __swig_getmethods__["stop"] = _casadi.Slice_stop_get
    if _newclass:
        stop = _swig_property(_casadi.Slice_stop_get)
    __swig_getmethods__["step"] = _casadi.Slice_step_get
    if _newclass:
        step = _swig_property(_casadi.Slice_step_get)

    def all(self, *args) -> "std::vector< int,std::allocator< int > >":
        """
          Get a vector of indices (nested slice)

          all(self, int len, bool ind1) -> [int]
            Get a vector of indices.
          all(self, Slice outer, int len) -> [int]



        > all(self, int len, bool ind1)
        ------------------------------------------------------------------------


        Get a vector of indices.


        > all(self, Slice outer, int len)
        ------------------------------------------------------------------------


        Get a vector of indices (nested slice)




        """
        return _casadi.Slice_all(self, *args)


    def is_scalar(self, *args) -> "bool":
        """
        Is the slice a scalar.

        is_scalar(self, int len) -> bool





        """
        return _casadi.Slice_is_scalar(self, *args)


    def scalar(self, *args) -> "int":
        """
        Get scalar (if is_scalar)

        scalar(self, int len) -> int





        """
        return _casadi.Slice_scalar(self, *args)


    def __eq__(self, *args) -> "bool":
        """


        __eq__(self, Slice other) -> bool



        """
        return _casadi.Slice___eq__(self, *args)


    def __ne__(self, *args) -> "bool":
        """


        __ne__(self, Slice other) -> bool



        """
        return _casadi.Slice___ne__(self, *args)


    def __init__(self, *args):
        """


          Slice()
            Default constructor - all elements.
          Slice(int i, bool ind1)
            A single element (explicit to avoid ambiguity with IM overload.
          Slice(Slice other)
          Slice(int start, int stop, int step)
            A slice.

        > Slice()
        ------------------------------------------------------------------------


        Default constructor - all elements.


        > Slice(Slice other)
        ------------------------------------------------------------------------

        > Slice(int start, int stop, int step)
        ------------------------------------------------------------------------


        A slice.


        > Slice(int i, bool ind1)
        ------------------------------------------------------------------------


        A single element (explicit to avoid ambiguity with IM overload.




        """
        this = _casadi.new_Slice(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_Slice
Slice_swigregister = _casadi.Slice_swigregister
Slice_swigregister(Slice)


def to_slice2(*args) -> "std::pair< casadi::Slice,casadi::Slice >":
    """
      Construct nested slices from an index vector (requires is_slice2(v) to be

      to_slice2([int] v) -> std::pair< casadi::Slice,casadi::Slice >

    true)




    """
    return _casadi.to_slice2(*args)

def is_slice2(*args) -> "bool":
    """
      Check if an index vector can be represented more efficiently as two nested

      is_slice2([int] v) -> bool

    slices.




    """
    return _casadi.is_slice2(*args)
class SpIM(SparsityInterfaceCommon):
    """
      Sparsity interface class.



    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpIM, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpIM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        SpIM()
        SpIM(SpIM other)



        """
        this = _casadi.new_SpIM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SpIM
SpIM_swigregister = _casadi.SpIM_swigregister
SpIM_swigregister(SpIM)

class SpDM(SparsityInterfaceCommon):
    """
      Sparsity interface class.



    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpDM, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpDM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        SpDM()
        SpDM(SpDM other)



        """
        this = _casadi.new_SpDM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SpDM
SpDM_swigregister = _casadi.SpDM_swigregister
SpDM_swigregister(SpDM)

class SpSX(SparsityInterfaceCommon):
    """
      Sparsity interface class.



    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpSX, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpSX, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        SpSX()
        SpSX(SpSX other)



        """
        this = _casadi.new_SpSX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SpSX
SpSX_swigregister = _casadi.SpSX_swigregister
SpSX_swigregister(SpSX)

class SpMX(SparsityInterfaceCommon):
    """
      Sparsity interface class.



    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpMX, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpMX, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        SpMX()
        SpMX(SpMX other)



        """
        this = _casadi.new_SpMX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SpMX
SpMX_swigregister = _casadi.SpMX_swigregister
SpMX_swigregister(SpMX)

class GenericMatrixCommon(_object):
    """


    GenericMatrixCommon() -> 



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericMatrixCommon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericMatrixCommon, name)
    __repr__ = _swig_repr

    def __mldivide__(x, y): return _casadi.mldivide(x, y)
    def __rmldivide__(y, x): return _casadi.mldivide(x, y)
    def __mrdivide__(x, y): return _casadi.mrdivide(x, y)
    def __rmrdivide__(y, x): return _casadi.mrdivide(x, y)
    def __mpower__(x, y): return _casadi.mpower(x, y)
    def __rmpower__(y, x): return _casadi.mpower(x, y)


    def __init__(self, *args):
        """


        GenericMatrixCommon()
        GenericMatrixCommon(GenericMatrixCommon other)



        """
        this = _casadi.new_GenericMatrixCommon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_GenericMatrixCommon
GenericMatrixCommon_swigregister = _casadi.GenericMatrixCommon_swigregister
GenericMatrixCommon_swigregister(GenericMatrixCommon)


def index_interp1d(*args) -> "double":
    """


    index_interp1d([float] x, float xq, bool equidistant) -> float



    """
    return _casadi.index_interp1d(*args)
class GenIM(GenericMatrixCommon, SpIM):
    """
      Matrix base class.



    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [GenericMatrixCommon, SpIM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenIM, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericMatrixCommon, SpIM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenIM, name)
    __repr__ = _swig_repr

    def nnz(self, *args) -> "int":
        """


        nnz(self) -> int



        """
        return _casadi.GenIM_nnz(self, *args)


    def nnz_lower(self, *args) -> "int":
        """


        nnz_lower(self) -> int



        """
        return _casadi.GenIM_nnz_lower(self, *args)


    def nnz_upper(self, *args) -> "int":
        """


        nnz_upper(self) -> int



        """
        return _casadi.GenIM_nnz_upper(self, *args)


    def nnz_diag(self, *args) -> "int":
        """


        nnz_diag(self) -> int



        """
        return _casadi.GenIM_nnz_diag(self, *args)


    def numel(self, *args) -> "int":
        """


        numel(self) -> int



        """
        return _casadi.GenIM_numel(self, *args)


    def size1(self, *args) -> "int":
        """


        size1(self) -> int



        """
        return _casadi.GenIM_size1(self, *args)


    def size2(self, *args) -> "int":
        """


        size2(self) -> int



        """
        return _casadi.GenIM_size2(self, *args)


    def dim(self, *args) -> "std::string":
        """


        dim(self) -> str



        """
        return _casadi.GenIM_dim(self, *args)


    def size(self, *args) -> "int":
        """


        size(self) -> (int,int)
        size(self, int axis) -> int



        """
        return _casadi.GenIM_size(self, *args)


    def is_empty(self, *args) -> "bool":
        """


        is_empty(self, bool both) -> bool



        """
        return _casadi.GenIM_is_empty(self, *args)


    def is_dense(self, *args) -> "bool":
        """


        is_dense(self) -> bool



        """
        return _casadi.GenIM_is_dense(self, *args)


    def is_scalar(self, *args) -> "bool":
        """


        is_scalar(self, bool scalar_and_dense) -> bool



        """
        return _casadi.GenIM_is_scalar(self, *args)


    def is_square(self, *args) -> "bool":
        """


        is_square(self) -> bool



        """
        return _casadi.GenIM_is_square(self, *args)


    def is_vector(self, *args) -> "bool":
        """


        is_vector(self) -> bool



        """
        return _casadi.GenIM_is_vector(self, *args)


    def is_row(self, *args) -> "bool":
        """


        is_row(self) -> bool



        """
        return _casadi.GenIM_is_row(self, *args)


    def is_column(self, *args) -> "bool":
        """


        is_column(self) -> bool



        """
        return _casadi.GenIM_is_column(self, *args)


    def is_triu(self, *args) -> "bool":
        """


        is_triu(self) -> bool



        """
        return _casadi.GenIM_is_triu(self, *args)


    def is_tril(self, *args) -> "bool":
        """


        is_tril(self) -> bool



        """
        return _casadi.GenIM_is_tril(self, *args)


    def row(self, *args) -> "int":
        """


        row(self) -> [int]
        row(self, int el) -> int



        """
        return _casadi.GenIM_row(self, *args)


    def colind(self, *args) -> "int":
        """


        colind(self) -> [int]
        colind(self, int col) -> int



        """
        return _casadi.GenIM_colind(self, *args)


    def sparsity(self, *args) -> "casadi::Sparsity const":
        """


        sparsity(self) -> Sparsity



        """
        return _casadi.GenIM_sparsity(self, *args)


    def sym(*args) -> "std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > >":
        """


        sym(str name, int nrow, int ncol) -> IM
        sym(str name, (int,int) rc) -> IM
        sym(str name, Sparsity sp) -> IM
        sym(str name, Sparsity sp, int p) -> [IM]
        sym(str name, int nrow, int ncol, int p) -> [IM]
        sym(str name, Sparsity sp, int p, int r) -> [IM]]
        sym(str name, int nrow, int ncol, int p, int r) -> [IM]]



        """
        return _casadi.GenIM_sym(*args)

    sym = staticmethod(sym)

    def zeros(*args) -> "casadi::Matrix< int >":
        """


        zeros(int nrow, int ncol) -> IM
        zeros((int,int) rc) -> IM
        zeros(Sparsity sp) -> IM



        """
        return _casadi.GenIM_zeros(*args)

    zeros = staticmethod(zeros)

    def ones(*args) -> "casadi::Matrix< int >":
        """


        ones(int nrow, int ncol) -> IM
        ones((int,int) rc) -> IM
        ones(Sparsity sp) -> IM



        """
        return _casadi.GenIM_ones(*args)

    ones = staticmethod(ones)

    def __init__(self, *args):
        """


        GenIM()
        GenIM(GenIM other)



        """
        this = _casadi.new_GenIM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_GenIM
GenIM_swigregister = _casadi.GenIM_swigregister
GenIM_swigregister(GenIM)

def GenIM_sym(*args) -> "std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > >":
    """


    sym(str name, int nrow, int ncol) -> IM
    sym(str name, (int,int) rc) -> IM
    sym(str name, Sparsity sp) -> IM
    sym(str name, Sparsity sp, int p) -> [IM]
    sym(str name, int nrow, int ncol, int p) -> [IM]
    sym(str name, Sparsity sp, int p, int r) -> [IM]]
    sym(str name, int nrow, int ncol, int p, int r) -> [IM]]



    """
    return _casadi.GenIM_sym(*args)

def GenIM_zeros(*args) -> "casadi::Matrix< int >":
    """


    zeros(int nrow, int ncol) -> IM
    zeros((int,int) rc) -> IM
    zeros(Sparsity sp) -> IM



    """
    return _casadi.GenIM_zeros(*args)

def GenIM_ones(*args) -> "casadi::Matrix< int >":
    """


    ones(int nrow, int ncol) -> IM
    ones((int,int) rc) -> IM
    ones(Sparsity sp) -> IM



    """
    return _casadi.GenIM_ones(*args)

class GenDM(GenericMatrixCommon, SpDM):
    """
      Matrix base class.



    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [GenericMatrixCommon, SpDM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenDM, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericMatrixCommon, SpDM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenDM, name)
    __repr__ = _swig_repr

    def nnz(self, *args) -> "int":
        """


        nnz(self) -> int



        """
        return _casadi.GenDM_nnz(self, *args)


    def nnz_lower(self, *args) -> "int":
        """


        nnz_lower(self) -> int



        """
        return _casadi.GenDM_nnz_lower(self, *args)


    def nnz_upper(self, *args) -> "int":
        """


        nnz_upper(self) -> int



        """
        return _casadi.GenDM_nnz_upper(self, *args)


    def nnz_diag(self, *args) -> "int":
        """


        nnz_diag(self) -> int



        """
        return _casadi.GenDM_nnz_diag(self, *args)


    def numel(self, *args) -> "int":
        """


        numel(self) -> int



        """
        return _casadi.GenDM_numel(self, *args)


    def size1(self, *args) -> "int":
        """


        size1(self) -> int



        """
        return _casadi.GenDM_size1(self, *args)


    def size2(self, *args) -> "int":
        """


        size2(self) -> int



        """
        return _casadi.GenDM_size2(self, *args)


    def dim(self, *args) -> "std::string":
        """


        dim(self) -> str



        """
        return _casadi.GenDM_dim(self, *args)


    def size(self, *args) -> "int":
        """


        size(self) -> (int,int)
        size(self, int axis) -> int



        """
        return _casadi.GenDM_size(self, *args)


    def is_empty(self, *args) -> "bool":
        """


        is_empty(self, bool both) -> bool



        """
        return _casadi.GenDM_is_empty(self, *args)


    def is_dense(self, *args) -> "bool":
        """


        is_dense(self) -> bool



        """
        return _casadi.GenDM_is_dense(self, *args)


    def is_scalar(self, *args) -> "bool":
        """


        is_scalar(self, bool scalar_and_dense) -> bool



        """
        return _casadi.GenDM_is_scalar(self, *args)


    def is_square(self, *args) -> "bool":
        """


        is_square(self) -> bool



        """
        return _casadi.GenDM_is_square(self, *args)


    def is_vector(self, *args) -> "bool":
        """


        is_vector(self) -> bool



        """
        return _casadi.GenDM_is_vector(self, *args)


    def is_row(self, *args) -> "bool":
        """


        is_row(self) -> bool



        """
        return _casadi.GenDM_is_row(self, *args)


    def is_column(self, *args) -> "bool":
        """


        is_column(self) -> bool



        """
        return _casadi.GenDM_is_column(self, *args)


    def is_triu(self, *args) -> "bool":
        """


        is_triu(self) -> bool



        """
        return _casadi.GenDM_is_triu(self, *args)


    def is_tril(self, *args) -> "bool":
        """


        is_tril(self) -> bool



        """
        return _casadi.GenDM_is_tril(self, *args)


    def row(self, *args) -> "int":
        """


        row(self) -> [int]
        row(self, int el) -> int



        """
        return _casadi.GenDM_row(self, *args)


    def colind(self, *args) -> "int":
        """


        colind(self) -> [int]
        colind(self, int col) -> int



        """
        return _casadi.GenDM_colind(self, *args)


    def sparsity(self, *args) -> "casadi::Sparsity const":
        """


        sparsity(self) -> Sparsity



        """
        return _casadi.GenDM_sparsity(self, *args)


    def sym(*args) -> "std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >":
        """


        sym(str name, int nrow, int ncol) -> DM
        sym(str name, (int,int) rc) -> DM
        sym(str name, Sparsity sp) -> DM
        sym(str name, Sparsity sp, int p) -> [DM]
        sym(str name, int nrow, int ncol, int p) -> [DM]
        sym(str name, Sparsity sp, int p, int r) -> [[DM]]
        sym(str name, int nrow, int ncol, int p, int r) -> [[DM]]



        """
        return _casadi.GenDM_sym(*args)

    sym = staticmethod(sym)

    def zeros(*args) -> "casadi::Matrix< double >":
        """


        zeros(int nrow, int ncol) -> DM
        zeros((int,int) rc) -> DM
        zeros(Sparsity sp) -> DM



        """
        return _casadi.GenDM_zeros(*args)

    zeros = staticmethod(zeros)

    def ones(*args) -> "casadi::Matrix< double >":
        """


        ones(int nrow, int ncol) -> DM
        ones((int,int) rc) -> DM
        ones(Sparsity sp) -> DM



        """
        return _casadi.GenDM_ones(*args)

    ones = staticmethod(ones)

    def __init__(self, *args):
        """


        GenDM()
        GenDM(GenDM other)



        """
        this = _casadi.new_GenDM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_GenDM
GenDM_swigregister = _casadi.GenDM_swigregister
GenDM_swigregister(GenDM)

def GenDM_sym(*args) -> "std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >":
    """


    sym(str name, int nrow, int ncol) -> DM
    sym(str name, (int,int) rc) -> DM
    sym(str name, Sparsity sp) -> DM
    sym(str name, Sparsity sp, int p) -> [DM]
    sym(str name, int nrow, int ncol, int p) -> [DM]
    sym(str name, Sparsity sp, int p, int r) -> [[DM]]
    sym(str name, int nrow, int ncol, int p, int r) -> [[DM]]



    """
    return _casadi.GenDM_sym(*args)

def GenDM_zeros(*args) -> "casadi::Matrix< double >":
    """


    zeros(int nrow, int ncol) -> DM
    zeros((int,int) rc) -> DM
    zeros(Sparsity sp) -> DM



    """
    return _casadi.GenDM_zeros(*args)

def GenDM_ones(*args) -> "casadi::Matrix< double >":
    """


    ones(int nrow, int ncol) -> DM
    ones((int,int) rc) -> DM
    ones(Sparsity sp) -> DM



    """
    return _casadi.GenDM_ones(*args)

class GenSX(GenericMatrixCommon, SpSX):
    """
      Matrix base class.



    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [GenericMatrixCommon, SpSX]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenSX, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericMatrixCommon, SpSX]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenSX, name)
    __repr__ = _swig_repr

    def nnz(self, *args) -> "int":
        """


        nnz(self) -> int



        """
        return _casadi.GenSX_nnz(self, *args)


    def nnz_lower(self, *args) -> "int":
        """


        nnz_lower(self) -> int



        """
        return _casadi.GenSX_nnz_lower(self, *args)


    def nnz_upper(self, *args) -> "int":
        """


        nnz_upper(self) -> int



        """
        return _casadi.GenSX_nnz_upper(self, *args)


    def nnz_diag(self, *args) -> "int":
        """


        nnz_diag(self) -> int



        """
        return _casadi.GenSX_nnz_diag(self, *args)


    def numel(self, *args) -> "int":
        """


        numel(self) -> int



        """
        return _casadi.GenSX_numel(self, *args)


    def size1(self, *args) -> "int":
        """


        size1(self) -> int



        """
        return _casadi.GenSX_size1(self, *args)


    def size2(self, *args) -> "int":
        """


        size2(self) -> int



        """
        return _casadi.GenSX_size2(self, *args)


    def dim(self, *args) -> "std::string":
        """


        dim(self) -> str



        """
        return _casadi.GenSX_dim(self, *args)


    def size(self, *args) -> "int":
        """


        size(self) -> (int,int)
        size(self, int axis) -> int



        """
        return _casadi.GenSX_size(self, *args)


    def is_empty(self, *args) -> "bool":
        """


        is_empty(self, bool both) -> bool



        """
        return _casadi.GenSX_is_empty(self, *args)


    def is_dense(self, *args) -> "bool":
        """


        is_dense(self) -> bool



        """
        return _casadi.GenSX_is_dense(self, *args)


    def is_scalar(self, *args) -> "bool":
        """


        is_scalar(self, bool scalar_and_dense) -> bool



        """
        return _casadi.GenSX_is_scalar(self, *args)


    def is_square(self, *args) -> "bool":
        """


        is_square(self) -> bool



        """
        return _casadi.GenSX_is_square(self, *args)


    def is_vector(self, *args) -> "bool":
        """


        is_vector(self) -> bool



        """
        return _casadi.GenSX_is_vector(self, *args)


    def is_row(self, *args) -> "bool":
        """


        is_row(self) -> bool



        """
        return _casadi.GenSX_is_row(self, *args)


    def is_column(self, *args) -> "bool":
        """


        is_column(self) -> bool



        """
        return _casadi.GenSX_is_column(self, *args)


    def is_triu(self, *args) -> "bool":
        """


        is_triu(self) -> bool



        """
        return _casadi.GenSX_is_triu(self, *args)


    def is_tril(self, *args) -> "bool":
        """


        is_tril(self) -> bool



        """
        return _casadi.GenSX_is_tril(self, *args)


    def row(self, *args) -> "int":
        """


        row(self) -> [int]
        row(self, int el) -> int



        """
        return _casadi.GenSX_row(self, *args)


    def colind(self, *args) -> "int":
        """


        colind(self) -> [int]
        colind(self, int col) -> int



        """
        return _casadi.GenSX_colind(self, *args)


    def sparsity(self, *args) -> "casadi::Sparsity const":
        """


        sparsity(self) -> Sparsity



        """
        return _casadi.GenSX_sparsity(self, *args)


    def sym(*args) -> "std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >":
        """


        sym(str name, int nrow, int ncol) -> SX
        sym(str name, (int,int) rc) -> SX
        sym(str name, Sparsity sp) -> SX
        sym(str name, Sparsity sp, int p) -> [SX]
        sym(str name, int nrow, int ncol, int p) -> [SX]
        sym(str name, Sparsity sp, int p, int r) -> [SX]]
        sym(str name, int nrow, int ncol, int p, int r) -> [SX]]



        """
        return _casadi.GenSX_sym(*args)

    sym = staticmethod(sym)

    def zeros(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        zeros(int nrow, int ncol) -> SX
        zeros((int,int) rc) -> SX
        zeros(Sparsity sp) -> SX



        """
        return _casadi.GenSX_zeros(*args)

    zeros = staticmethod(zeros)

    def ones(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        ones(int nrow, int ncol) -> SX
        ones((int,int) rc) -> SX
        ones(Sparsity sp) -> SX



        """
        return _casadi.GenSX_ones(*args)

    ones = staticmethod(ones)

    def __init__(self, *args):
        """


        GenSX()
        GenSX(GenSX other)



        """
        this = _casadi.new_GenSX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_GenSX
GenSX_swigregister = _casadi.GenSX_swigregister
GenSX_swigregister(GenSX)

def GenSX_sym(*args) -> "std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >":
    """


    sym(str name, int nrow, int ncol) -> SX
    sym(str name, (int,int) rc) -> SX
    sym(str name, Sparsity sp) -> SX
    sym(str name, Sparsity sp, int p) -> [SX]
    sym(str name, int nrow, int ncol, int p) -> [SX]
    sym(str name, Sparsity sp, int p, int r) -> [SX]]
    sym(str name, int nrow, int ncol, int p, int r) -> [SX]]



    """
    return _casadi.GenSX_sym(*args)

def GenSX_zeros(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    zeros(int nrow, int ncol) -> SX
    zeros((int,int) rc) -> SX
    zeros(Sparsity sp) -> SX



    """
    return _casadi.GenSX_zeros(*args)

def GenSX_ones(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    ones(int nrow, int ncol) -> SX
    ones((int,int) rc) -> SX
    ones(Sparsity sp) -> SX



    """
    return _casadi.GenSX_ones(*args)

class GenMX(GenericMatrixCommon, SpMX):
    """
      Matrix base class.



    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [GenericMatrixCommon, SpMX]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenMX, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericMatrixCommon, SpMX]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenMX, name)
    __repr__ = _swig_repr

    def nnz(self, *args) -> "int":
        """


        nnz(self) -> int



        """
        return _casadi.GenMX_nnz(self, *args)


    def nnz_lower(self, *args) -> "int":
        """


        nnz_lower(self) -> int



        """
        return _casadi.GenMX_nnz_lower(self, *args)


    def nnz_upper(self, *args) -> "int":
        """


        nnz_upper(self) -> int



        """
        return _casadi.GenMX_nnz_upper(self, *args)


    def nnz_diag(self, *args) -> "int":
        """


        nnz_diag(self) -> int



        """
        return _casadi.GenMX_nnz_diag(self, *args)


    def numel(self, *args) -> "int":
        """


        numel(self) -> int



        """
        return _casadi.GenMX_numel(self, *args)


    def size1(self, *args) -> "int":
        """


        size1(self) -> int



        """
        return _casadi.GenMX_size1(self, *args)


    def size2(self, *args) -> "int":
        """


        size2(self) -> int



        """
        return _casadi.GenMX_size2(self, *args)


    def dim(self, *args) -> "std::string":
        """


        dim(self) -> str



        """
        return _casadi.GenMX_dim(self, *args)


    def size(self, *args) -> "int":
        """


        size(self) -> (int,int)
        size(self, int axis) -> int



        """
        return _casadi.GenMX_size(self, *args)


    def is_empty(self, *args) -> "bool":
        """


        is_empty(self, bool both) -> bool



        """
        return _casadi.GenMX_is_empty(self, *args)


    def is_dense(self, *args) -> "bool":
        """


        is_dense(self) -> bool



        """
        return _casadi.GenMX_is_dense(self, *args)


    def is_scalar(self, *args) -> "bool":
        """


        is_scalar(self, bool scalar_and_dense) -> bool



        """
        return _casadi.GenMX_is_scalar(self, *args)


    def is_square(self, *args) -> "bool":
        """


        is_square(self) -> bool



        """
        return _casadi.GenMX_is_square(self, *args)


    def is_vector(self, *args) -> "bool":
        """


        is_vector(self) -> bool



        """
        return _casadi.GenMX_is_vector(self, *args)


    def is_row(self, *args) -> "bool":
        """


        is_row(self) -> bool



        """
        return _casadi.GenMX_is_row(self, *args)


    def is_column(self, *args) -> "bool":
        """


        is_column(self) -> bool



        """
        return _casadi.GenMX_is_column(self, *args)


    def is_triu(self, *args) -> "bool":
        """


        is_triu(self) -> bool



        """
        return _casadi.GenMX_is_triu(self, *args)


    def is_tril(self, *args) -> "bool":
        """


        is_tril(self) -> bool



        """
        return _casadi.GenMX_is_tril(self, *args)


    def row(self, *args) -> "int":
        """


        row(self) -> [int]
        row(self, int el) -> int



        """
        return _casadi.GenMX_row(self, *args)


    def colind(self, *args) -> "int":
        """


        colind(self) -> [int]
        colind(self, int col) -> int



        """
        return _casadi.GenMX_colind(self, *args)


    def sparsity(self, *args) -> "casadi::Sparsity const":
        """


        sparsity(self) -> Sparsity



        """
        return _casadi.GenMX_sparsity(self, *args)


    def sym(*args) -> "std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >":
        """


        sym(str name, int nrow, int ncol) -> MX
        sym(str name, (int,int) rc) -> MX
        sym(str name, Sparsity sp) -> MX
        sym(str name, Sparsity sp, int p) -> [MX]
        sym(str name, int nrow, int ncol, int p) -> [MX]
        sym(str name, Sparsity sp, int p, int r) -> [[MX]]
        sym(str name, int nrow, int ncol, int p, int r) -> [[MX]]



        """
        return _casadi.GenMX_sym(*args)

    sym = staticmethod(sym)

    def zeros(*args) -> "casadi::MX":
        """


        zeros(int nrow, int ncol) -> MX
        zeros((int,int) rc) -> MX
        zeros(Sparsity sp) -> MX



        """
        return _casadi.GenMX_zeros(*args)

    zeros = staticmethod(zeros)

    def ones(*args) -> "casadi::MX":
        """


        ones(int nrow, int ncol) -> MX
        ones((int,int) rc) -> MX
        ones(Sparsity sp) -> MX



        """
        return _casadi.GenMX_ones(*args)

    ones = staticmethod(ones)

    def __init__(self, *args):
        """


        GenMX()
        GenMX(GenMX other)



        """
        this = _casadi.new_GenMX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_GenMX
GenMX_swigregister = _casadi.GenMX_swigregister
GenMX_swigregister(GenMX)

def GenMX_sym(*args) -> "std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >":
    """


    sym(str name, int nrow, int ncol) -> MX
    sym(str name, (int,int) rc) -> MX
    sym(str name, Sparsity sp) -> MX
    sym(str name, Sparsity sp, int p) -> [MX]
    sym(str name, int nrow, int ncol, int p) -> [MX]
    sym(str name, Sparsity sp, int p, int r) -> [[MX]]
    sym(str name, int nrow, int ncol, int p, int r) -> [[MX]]



    """
    return _casadi.GenMX_sym(*args)

def GenMX_zeros(*args) -> "casadi::MX":
    """


    zeros(int nrow, int ncol) -> MX
    zeros((int,int) rc) -> MX
    zeros(Sparsity sp) -> MX



    """
    return _casadi.GenMX_zeros(*args)

def GenMX_ones(*args) -> "casadi::MX":
    """


    ones(int nrow, int ncol) -> MX
    ones((int,int) rc) -> MX
    ones(Sparsity sp) -> MX



    """
    return _casadi.GenMX_ones(*args)

class GenericExpressionCommon(_object):
    """


    GenericExpressionCommon() -> 



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericExpressionCommon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericExpressionCommon, name)
    __repr__ = _swig_repr

    def __hash__(self): return SharedObject.__hash__(self)
    def __matmul__(x, y): return _casadi.mtimes(x, y)
    def __rmatmul__(x, y): return _casadi.mtimes(y, x)


    def __add__(x, y): return _casadi.plus(x, y)
    def __radd__(x, y): return _casadi.plus(y, x)
    def __sub__(x, y): return _casadi.minus(x, y)
    def __rsub__(x, y): return _casadi.minus(y, x)
    def __mul__(x, y): return _casadi.times(x, y)
    def __rmul__(x, y): return _casadi.times(y, x)
    def __div__(x, y): return _casadi.rdivide(x, y)
    def __rdiv__(x, y): return _casadi.rdivide(y, x)
    def __truediv__(x, y): return _casadi.rdivide(x, y)
    def __rtruediv__(x, y): return _casadi.rdivide(y, x)
    def __lt__(x, y): return _casadi.lt(x, y)
    def __rlt__(x, y): return _casadi.lt(y, x)
    def __le__(x, y): return _casadi.le(x, y)
    def __rle__(x, y): return _casadi.le(y, x)
    def __gt__(x, y): return _casadi.lt(y, x)
    def __rgt__(x, y): return _casadi.lt(x, y)
    def __ge__(x, y): return _casadi.le(y, x)
    def __rge__(x, y): return _casadi.le(x, y)
    def __eq__(x, y): return _casadi.eq(x, y)
    def __req__(x, y): return _casadi.eq(y, x)
    def __ne__(x, y): return _casadi.ne(x, y)
    def __rne__(x, y): return _casadi.ne(y, x)
    def __pow__(x, n): return _casadi.power(x, n)
    def __rpow__(n, x): return _casadi.power(x, n)
    def __arctan2__(x, y): return _casadi.atan2(x, y)
    def __rarctan2__(y, x): return _casadi.atan2(x, y)
    def fmin(x, y): return _casadi.fmin(x, y)
    def fmax(x, y): return _casadi.fmax(x, y)
    def __fmin__(x, y): return _casadi.fmin(x, y)
    def __rfmin__(y, x): return _casadi.fmin(x, y)
    def __fmax__(x, y): return _casadi.fmax(x, y)
    def __rfmax__(y, x): return _casadi.fmax(x, y)
    def logic_and(x, y): return _casadi.logic_and(x, y)
    def logic_or(x, y): return _casadi.logic_or(x, y)
    def fabs(x): return _casadi.fabs(x)
    def sqrt(x): return _casadi.sqrt(x)
    def sin(x): return _casadi.sin(x)
    def cos(x): return _casadi.cos(x)
    def tan(x): return _casadi.tan(x)
    def arcsin(x): return _casadi.asin(x)
    def arccos(x): return _casadi.acos(x)
    def arctan(x): return _casadi.atan(x)
    def sinh(x): return _casadi.sinh(x)
    def cosh(x): return _casadi.cosh(x)
    def tanh(x): return _casadi.tanh(x)
    def arcsinh(x): return _casadi.asinh(x)
    def arccosh(x): return _casadi.acosh(x)
    def arctanh(x): return _casadi.atanh(x)
    def exp(x): return _casadi.exp(x)
    def log(x): return _casadi.log(x)
    def log10(x): return _casadi.log10(x)
    def floor(x): return _casadi.floor(x)
    def ceil(x): return _casadi.ceil(x)
    def erf(x): return _casadi.erf(x)
    def sign(x): return _casadi.sign(x)
    def fmod(x, y): return _casadi.mod(x, y)
    def __copysign__(x, y): return _casadi.copysign(x, y)
    def __rcopysign__(y, x): return _casadi.copysign(x, y)
    def copysign(x, y): return _casadi.copysign(x, y)
    def rcopysign(y, x): return _casadi.copysign(x, y)
    def __constpow__(x, y): return _casadi.constpow(x, y)
    def __rconstpow__(y, x): return _casadi.constpow(x, y)
    def constpow(x, y): return _casadi.constpow(x, y)
    def rconstpow(y, x): return _casadi.constpow(x, y)


    def __init__(self, *args):
        """


        GenericExpressionCommon()
        GenericExpressionCommon(GenericExpressionCommon other)



        """
        this = _casadi.new_GenericExpressionCommon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_GenericExpressionCommon
GenericExpressionCommon_swigregister = _casadi.GenericExpressionCommon_swigregister
GenericExpressionCommon_swigregister(GenericExpressionCommon)

class ExpIM(GenericExpressionCommon):
    """
      Expression interface.



    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [GenericExpressionCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpIM, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericExpressionCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpIM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        ExpIM()
        ExpIM(ExpIM other)



        """
        this = _casadi.new_ExpIM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_ExpIM
ExpIM_swigregister = _casadi.ExpIM_swigregister
ExpIM_swigregister(ExpIM)

class ExpDM(GenericExpressionCommon):
    """
      Expression interface.



    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [GenericExpressionCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpDM, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericExpressionCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpDM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        ExpDM()
        ExpDM(ExpDM other)



        """
        this = _casadi.new_ExpDM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_ExpDM
ExpDM_swigregister = _casadi.ExpDM_swigregister
ExpDM_swigregister(ExpDM)

class ExpSX(GenericExpressionCommon):
    """
      Expression interface.



    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [GenericExpressionCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpSX, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericExpressionCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpSX, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        ExpSX()
        ExpSX(ExpSX other)



        """
        this = _casadi.new_ExpSX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_ExpSX
ExpSX_swigregister = _casadi.ExpSX_swigregister
ExpSX_swigregister(ExpSX)

class ExpMX(GenericExpressionCommon):
    """
      Expression interface.



    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [GenericExpressionCommon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpMX, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericExpressionCommon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpMX, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        ExpMX()
        ExpMX(ExpMX other)



        """
        this = _casadi.new_ExpMX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_ExpMX
ExpMX_swigregister = _casadi.ExpMX_swigregister
ExpMX_swigregister(ExpMX)

IS_GLOBAL = _casadi.IS_GLOBAL
IS_MEMBER = _casadi.IS_MEMBER
IS_SPARSITY = _casadi.IS_SPARSITY
IS_DMATRIX = _casadi.IS_DMATRIX
IS_IMATRIX = _casadi.IS_IMATRIX
IS_SX = _casadi.IS_SX
IS_MX = _casadi.IS_MX
IS_DOUBLE = _casadi.IS_DOUBLE
class PrintSX(_object):
    """
      Base class for objects that have a natural string representation.



    Joel Andersson

    C++ includes: printable_object.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSX, name)
    __repr__ = _swig_repr

    def __str__(self, *args) -> "std::string":
        """


        __str__(self) -> str



        """
        return _casadi.PrintSX___str__(self, *args)


    def getRepresentation(self, *args) -> "std::string":
        """


        getRepresentation(self) -> str



        """
        return _casadi.PrintSX_getRepresentation(self, *args)


    def __init__(self, *args):
        """


        PrintSX()
        PrintSX(PrintSX other)



        """
        this = _casadi.new_PrintSX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_PrintSX
PrintSX_swigregister = _casadi.PrintSX_swigregister
PrintSX_swigregister(PrintSX)

class MatrixCommon(_object):
    """


    MatrixCommon() -> 



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixCommon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixCommon, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        MatrixCommon()
        MatrixCommon(MatrixCommon other)



        """
        this = _casadi.new_MatrixCommon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_MatrixCommon
MatrixCommon_swigregister = _casadi.MatrixCommon_swigregister
MatrixCommon_swigregister(MatrixCommon)


def is_slice(*args) -> "bool":
    """
      Is the IM a Slice.

      is_slice([int] v, bool ind1) -> bool
        Check if an index vector can be represented more efficiently as a slice.
      is_slice(IM x, bool ind1) -> bool



    > is_slice(IM x, bool ind1)
    ------------------------------------------------------------------------


    Is the IM a Slice.


    > is_slice([int] v, bool ind1)
    ------------------------------------------------------------------------


    Check if an index vector can be represented more efficiently as a slice.




    """
    return _casadi.is_slice(*args)

def to_slice(*args) -> "casadi::Slice":
    """
      Convert IM to Slice.

      to_slice([int] v, bool ind1) -> Slice
        Construct from an index vector (requires is_slice(v) to be true)
      to_slice(IM x, bool ind1) -> Slice



    > to_slice(IM x, bool ind1)
    ------------------------------------------------------------------------


    Convert IM to Slice.


    > to_slice([int] v, bool ind1)
    ------------------------------------------------------------------------


    Construct from an index vector (requires is_slice(v) to be true)




    """
    return _casadi.to_slice(*args)
class DM(MatrixCommon, ExpDM, GenDM, PrintDM):
    """
      Sparse matrix class. SX and DM are specializations.



    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero.  Matrix<Scalar> is polymorphic with a
    std::vector<Scalar> that contain all non-identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [MatrixCommon, ExpDM, GenDM, PrintDM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DM, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixCommon, ExpDM, GenDM, PrintDM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DM, name)
    __repr__ = _swig_repr

    def sanity_check(self, *args) -> "void":
        """


        sanity_check(self, bool complete)



        """
        return _casadi.DM_sanity_check(self, *args)


    def has_nz(self, *args) -> "bool":
        """


        has_nz(self, int rr, int cc) -> bool



        """
        return _casadi.DM_has_nz(self, *args)


    def __bool__(self, *args) -> "bool":
        """
        [INTERNAL] 

        __bool__(self) -> bool



        """
        return _casadi.DM___bool__(self, *args)


    def get(self, *args) -> "void":
        """


        get(self, bool ind1, Sparsity sp) -> DM
        get(self, bool ind1, Slice rr) -> DM
        get(self, bool ind1, IM rr) -> DM
        get(self, bool ind1, Slice rr, Slice cc) -> DM
        get(self, bool ind1, Slice rr, IM cc) -> DM
        get(self, bool ind1, IM rr, Slice cc) -> DM
        get(self, bool ind1, IM rr, IM cc) -> DM



        """
        return _casadi.DM_get(self, *args)


    def set(self, *args) -> "void":
        """


        set(self, DM m, bool ind1, Sparsity sp)
        set(self, DM m, bool ind1, Slice rr)
        set(self, DM m, bool ind1, IM rr)
        set(self, DM m, bool ind1, Slice rr, Slice cc)
        set(self, DM m, bool ind1, Slice rr, IM cc)
        set(self, DM m, bool ind1, IM rr, Slice cc)
        set(self, DM m, bool ind1, IM rr, IM cc)



        """
        return _casadi.DM_set(self, *args)


    def get_nz(self, *args) -> "void":
        """


        get_nz(self, bool ind1, Slice k) -> DM
        get_nz(self, bool ind1, IM k) -> DM



        """
        return _casadi.DM_get_nz(self, *args)


    def set_nz(self, *args) -> "void":
        """


        set_nz(self, DM m, bool ind1, Slice k)
        set_nz(self, DM m, bool ind1, IM k)



        """
        return _casadi.DM_set_nz(self, *args)


    def __pos__(self, *args) -> "casadi::Matrix< double >":
        """


        __pos__(self) -> DM



        """
        return _casadi.DM___pos__(self, *args)


    def __neg__(self, *args) -> "casadi::Matrix< double >":
        """


        __neg__(self) -> DM



        """
        return _casadi.DM___neg__(self, *args)


    def binary(*args) -> "casadi::Matrix< double >":
        """


        binary(int op, DM x, DM y) -> DM



        """
        return _casadi.DM_binary(*args)

    binary = staticmethod(binary)

    def unary(*args) -> "casadi::Matrix< double >":
        """


        unary(int op, DM x) -> DM



        """
        return _casadi.DM_unary(*args)

    unary = staticmethod(unary)

    def scalar_matrix(*args) -> "casadi::Matrix< double >":
        """


        scalar_matrix(int op, DM x, DM y) -> DM



        """
        return _casadi.DM_scalar_matrix(*args)

    scalar_matrix = staticmethod(scalar_matrix)

    def matrix_scalar(*args) -> "casadi::Matrix< double >":
        """


        matrix_scalar(int op, DM x, DM y) -> DM



        """
        return _casadi.DM_matrix_scalar(*args)

    matrix_scalar = staticmethod(matrix_scalar)

    def matrix_matrix(*args) -> "casadi::Matrix< double >":
        """


        matrix_matrix(int op, DM x, DM y) -> DM



        """
        return _casadi.DM_matrix_matrix(*args)

    matrix_matrix = staticmethod(matrix_matrix)

    def printme(self, *args) -> "casadi::Matrix< double >":
        """


        printme(self, DM y) -> DM



        """
        return _casadi.DM_printme(self, *args)


    def set_max_depth(*args) -> "void":
        """


        set_max_depth(int eq_depth)



        """
        return _casadi.DM_set_max_depth(*args)

    set_max_depth = staticmethod(set_max_depth)

    def get_max_depth(*args) -> "int":
        """


        get_max_depth() -> int



        """
        return _casadi.DM_get_max_depth(*args)

    get_max_depth = staticmethod(get_max_depth)

    def setEqualityCheckingDepth(*args) -> "void":
        """


        setEqualityCheckingDepth(int eq_depth)



        """
        return _casadi.DM_setEqualityCheckingDepth(*args)

    setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)

    def getEqualityCheckingDepth(*args) -> "int":
        """


        getEqualityCheckingDepth() -> int



        """
        return _casadi.DM_getEqualityCheckingDepth(*args)

    getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)

    def get_input(*args) -> "std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >":
        """


        get_input(Function f) -> [DM]



        """
        return _casadi.DM_get_input(*args)

    get_input = staticmethod(get_input)

    def get_free(*args) -> "std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >":
        """


        get_free(Function f) -> [DM]



        """
        return _casadi.DM_get_free(*args)

    get_free = staticmethod(get_free)

    def type_name(*args) -> "std::string":
        """


        type_name() -> str



        """
        return _casadi.DM_type_name(*args)

    type_name = staticmethod(type_name)

    def print_split(self, *args) -> "void":
        """


        print_split(self) -> ([str] OUTPUT, [str] OUTPUT)



        """
        return _casadi.DM_print_split(self, *args)


    def print_scalar(self, *args) -> "void":
        """


        print_scalar(self, bool trailing_newline)



        """
        return _casadi.DM_print_scalar(self, *args)


    def print_vector(self, *args) -> "void":
        """


        print_vector(self, bool trailing_newline)



        """
        return _casadi.DM_print_vector(self, *args)


    def print_dense(self, *args) -> "void":
        """


        print_dense(self, bool trailing_newline)



        """
        return _casadi.DM_print_dense(self, *args)


    def print_sparse(self, *args) -> "void":
        """


        print_sparse(self, bool trailing_newline)



        """
        return _casadi.DM_print_sparse(self, *args)


    def clear(self, *args) -> "void":
        """


        clear(self)



        """
        return _casadi.DM_clear(self, *args)


    def resize(self, *args) -> "void":
        """


        resize(self, int nrow, int ncol)



        """
        return _casadi.DM_resize(self, *args)


    def reserve(self, *args) -> "void":
        """


        reserve(self, int nnz)
        reserve(self, int nnz, int ncol)



        """
        return _casadi.DM_reserve(self, *args)


    def erase(self, *args) -> "void":
        """


        erase(self, [int] rr, bool ind1)
        erase(self, [int] rr, [int] cc, bool ind1)



        """
        return _casadi.DM_erase(self, *args)


    def remove(self, *args) -> "void":
        """


        remove(self, [int] rr, [int] cc)



        """
        return _casadi.DM_remove(self, *args)


    def enlarge(self, *args) -> "void":
        """


        enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)



        """
        return _casadi.DM_enlarge(self, *args)


    def sparsity(self, *args) -> "casadi::Sparsity":
        """


        sparsity(self) -> Sparsity



        """
        return _casadi.DM_sparsity(self, *args)


    def triplet(*args) -> "casadi::Matrix< double >":
        """


        triplet([int] row, [int] col, DM d) -> DM
        triplet([int] row, [int] col, DM d, (int,int) rc) -> DM
        triplet([int] row, [int] col, DM d, int nrow, int ncol) -> DM



        """
        return _casadi.DM_triplet(*args)

    triplet = staticmethod(triplet)

    def inf(*args) -> "casadi::Matrix< double >":
        """


        inf(int nrow, int ncol) -> DM
        inf((int,int) rc) -> DM
        inf(Sparsity sp) -> DM



        """
        return _casadi.DM_inf(*args)

    inf = staticmethod(inf)

    def nan(*args) -> "casadi::Matrix< double >":
        """


        nan(int nrow, int ncol) -> DM
        nan((int,int) rc) -> DM
        nan(Sparsity sp) -> DM



        """
        return _casadi.DM_nan(*args)

    nan = staticmethod(nan)

    def eye(*args) -> "casadi::Matrix< double >":
        """


        eye(int ncol) -> DM



        """
        return _casadi.DM_eye(*args)

    eye = staticmethod(eye)

    def element_hash(self, *args) -> "size_t":
        """


        element_hash(self) -> size_t



        """
        return _casadi.DM_element_hash(self, *args)


    def is_regular(self, *args) -> "bool":
        """


        is_regular(self) -> bool



        """
        return _casadi.DM_is_regular(self, *args)


    def is_smooth(self, *args) -> "bool":
        """


        is_smooth(self) -> bool



        """
        return _casadi.DM_is_smooth(self, *args)


    def is_leaf(self, *args) -> "bool":
        """


        is_leaf(self) -> bool



        """
        return _casadi.DM_is_leaf(self, *args)


    def is_commutative(self, *args) -> "bool":
        """


        is_commutative(self) -> bool



        """
        return _casadi.DM_is_commutative(self, *args)


    def is_symbolic(self, *args) -> "bool":
        """


        is_symbolic(self) -> bool



        """
        return _casadi.DM_is_symbolic(self, *args)


    def is_valid_input(self, *args) -> "bool":
        """


        is_valid_input(self) -> bool



        """
        return _casadi.DM_is_valid_input(self, *args)


    def has_duplicates(self, *args) -> "bool":
        """


        has_duplicates(self) -> bool



        """
        return _casadi.DM_has_duplicates(self, *args)


    def reset_input(self, *args) -> "void":
        """


        reset_input(self)



        """
        return _casadi.DM_reset_input(self, *args)


    def is_constant(self, *args) -> "bool":
        """


        is_constant(self) -> bool



        """
        return _casadi.DM_is_constant(self, *args)


    def is_integer(self, *args) -> "bool":
        """


        is_integer(self) -> bool



        """
        return _casadi.DM_is_integer(self, *args)


    def is_zero(self, *args) -> "bool":
        """


        is_zero(self) -> bool



        """
        return _casadi.DM_is_zero(self, *args)


    def is_one(self, *args) -> "bool":
        """


        is_one(self) -> bool



        """
        return _casadi.DM_is_one(self, *args)


    def is_minus_one(self, *args) -> "bool":
        """


        is_minus_one(self) -> bool



        """
        return _casadi.DM_is_minus_one(self, *args)


    def is_identity(self, *args) -> "bool":
        """


        is_identity(self) -> bool



        """
        return _casadi.DM_is_identity(self, *args)


    def has_zeros(self, *args) -> "bool":
        """


        has_zeros(self) -> bool



        """
        return _casadi.DM_has_zeros(self, *args)


    def nonzeros(self, *args) -> "std::vector< double,std::allocator< double > >":
        """


        nonzeros(self) -> [float]



        """
        return _casadi.DM_nonzeros(self, *args)


    def __float__(self, *args) -> "double":
        """


        __float__(self) -> float



        """
        return _casadi.DM___float__(self, *args)


    def __int__(self, *args) -> "int":
        """


        __int__(self) -> int



        """
        return _casadi.DM___int__(self, *args)


    def name(self, *args) -> "std::string":
        """


        name(self) -> str



        """
        return _casadi.DM_name(self, *args)


    def dep(self, *args) -> "casadi::Matrix< double >":
        """


        dep(self, int ch) -> DM



        """
        return _casadi.DM_dep(self, *args)


    def n_dep(self, *args) -> "int":
        """


        n_dep(self) -> int



        """
        return _casadi.DM_n_dep(self, *args)


    def set_precision(*args) -> "void":
        """


        set_precision(int precision)



        """
        return _casadi.DM_set_precision(*args)

    set_precision = staticmethod(set_precision)

    def set_width(*args) -> "void":
        """


        set_width(int width)



        """
        return _casadi.DM_set_width(*args)

    set_width = staticmethod(set_width)

    def set_scientific(*args) -> "void":
        """


        set_scientific(bool scientific)



        """
        return _casadi.DM_set_scientific(*args)

    set_scientific = staticmethod(set_scientific)

    def __init__(self, *args):
        """


        DM()
        DM(Sparsity sp)
        DM(float val)
        DM([[float]] m)
        DM([int] x)
        DM(IM x)
        DM(DM m)
        DM([SXElem] x)
        DM(SX x)
        DM(int nrow, int ncol)
        DM(Sparsity sp, DM d)



        """
        this = _casadi.new_DM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def assign(self, *args) -> "void":
        """


        assign(self, DM rhs)



        """
        return _casadi.DM_assign(self, *args)


    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi.reshape(self,arg)

    @property
    def T(self):
        return _casadi.transpose(self)

    def __getitem__(self, s):
          if isinstance(s, tuple) and len(s)==2:
            if s[1] is None: raise TypeError("Cannot slice with None")
            return self.get(False, s[0], s[1])
          return self.get(False, s)

    def __setitem__(self,s,val):
          if isinstance(s,tuple) and len(s)==2:
            return self.set(val, False, s[0], s[1])
          return self.set(val, False, s)

    @property
    def nz(self):
      return NZproxy(self)



    def full(self, *args) -> "PyObject *":
        """


        full(self) -> PyObject *



        """
        return _casadi.DM_full(self, *args)



    __array_priority__ = 999.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.full()



    def __array_custom__(self,*args,**kwargs):
      if "dtype" in kwargs and not(isinstance(kwargs["dtype"],n.double)):
        return n.array(self.full(),dtype=kwargs["dtype"])
      else:
        return self.full()


    def sparse(self):
      import numpy as n
      import warnings
      with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        from scipy.sparse import csc_matrix
      return csc_matrix( (self.nonzeros(),self.row(),self.colind()), shape = self.shape, dtype=n.double )

    def tocsc(self):
      return self.sparse()



    def __bool__(self):
      if self.numel()!=1:
        raise Exception("Only a scalar can be cast to a float")
      if self.nnz()==0:
        return False
      return float(self)!=0


    def __abs__(self):
      return abs(float(self))


    def __setstate__(self, state):
        sp = Sparsity.__new__(Sparsity)
        sp.__setstate__(state["sparsity"])
        self.__init__(sp,state["data"])

    def __getstate__(self):
        return {"sparsity" : self.sparsity().__getstate__(), "data": numpy.array(self.nonzeros(),dtype=float)}

    __swig_destroy__ = _casadi.delete_DM
DM_swigregister = _casadi.DM_swigregister
DM_swigregister(DM)

def DM_binary(*args) -> "casadi::Matrix< double >":
    """


    binary(int op, DM x, DM y) -> DM



    """
    return _casadi.DM_binary(*args)

def DM_unary(*args) -> "casadi::Matrix< double >":
    """


    unary(int op, DM x) -> DM



    """
    return _casadi.DM_unary(*args)

def DM_scalar_matrix(*args) -> "casadi::Matrix< double >":
    """


    scalar_matrix(int op, DM x, DM y) -> DM



    """
    return _casadi.DM_scalar_matrix(*args)

def DM_matrix_scalar(*args) -> "casadi::Matrix< double >":
    """


    matrix_scalar(int op, DM x, DM y) -> DM



    """
    return _casadi.DM_matrix_scalar(*args)

def DM_matrix_matrix(*args) -> "casadi::Matrix< double >":
    """


    matrix_matrix(int op, DM x, DM y) -> DM



    """
    return _casadi.DM_matrix_matrix(*args)

def DM_set_max_depth(*args) -> "void":
    """


    set_max_depth(int eq_depth)



    """
    return _casadi.DM_set_max_depth(*args)

def DM_get_max_depth(*args) -> "int":
    """


    get_max_depth() -> int



    """
    return _casadi.DM_get_max_depth(*args)

def DM_setEqualityCheckingDepth(*args) -> "void":
    """


    setEqualityCheckingDepth(int eq_depth)



    """
    return _casadi.DM_setEqualityCheckingDepth(*args)

def DM_getEqualityCheckingDepth(*args) -> "int":
    """


    getEqualityCheckingDepth() -> int



    """
    return _casadi.DM_getEqualityCheckingDepth(*args)

def DM_get_input(*args) -> "std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >":
    """


    get_input(Function f) -> [DM]



    """
    return _casadi.DM_get_input(*args)

def DM_get_free(*args) -> "std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >":
    """


    get_free(Function f) -> [DM]



    """
    return _casadi.DM_get_free(*args)

def DM_type_name(*args) -> "std::string":
    """


    type_name() -> str



    """
    return _casadi.DM_type_name(*args)

def DM_triplet(*args) -> "casadi::Matrix< double >":
    """


    triplet([int] row, [int] col, DM d) -> DM
    triplet([int] row, [int] col, DM d, (int,int) rc) -> DM
    triplet([int] row, [int] col, DM d, int nrow, int ncol) -> DM



    """
    return _casadi.DM_triplet(*args)

def DM_inf(*args) -> "casadi::Matrix< double >":
    """


    inf(int nrow, int ncol) -> DM
    inf((int,int) rc) -> DM
    inf(Sparsity sp) -> DM



    """
    return _casadi.DM_inf(*args)

def DM_nan(*args) -> "casadi::Matrix< double >":
    """


    nan(int nrow, int ncol) -> DM
    nan((int,int) rc) -> DM
    nan(Sparsity sp) -> DM



    """
    return _casadi.DM_nan(*args)

def DM_eye(*args) -> "casadi::Matrix< double >":
    """


    eye(int ncol) -> DM



    """
    return _casadi.DM_eye(*args)

def DM_set_precision(*args) -> "void":
    """


    set_precision(int precision)



    """
    return _casadi.DM_set_precision(*args)

def DM_set_width(*args) -> "void":
    """


    set_width(int width)



    """
    return _casadi.DM_set_width(*args)

def DM_set_scientific(*args) -> "void":
    """


    set_scientific(bool scientific)



    """
    return _casadi.DM_set_scientific(*args)

class IM(MatrixCommon, ExpIM, GenIM, PrintIM):
    """
      Sparse matrix class. SX and DM are specializations.



    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero.  Matrix<Scalar> is polymorphic with a
    std::vector<Scalar> that contain all non-identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [MatrixCommon, ExpIM, GenIM, PrintIM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IM, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixCommon, ExpIM, GenIM, PrintIM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IM, name)
    __repr__ = _swig_repr

    def sanity_check(self, *args) -> "void":
        """


        sanity_check(self, bool complete)



        """
        return _casadi.IM_sanity_check(self, *args)


    def has_nz(self, *args) -> "bool":
        """


        has_nz(self, int rr, int cc) -> bool



        """
        return _casadi.IM_has_nz(self, *args)


    def __bool__(self, *args) -> "bool":
        """
        [INTERNAL] 

        __bool__(self) -> bool



        """
        return _casadi.IM___bool__(self, *args)


    def get(self, *args) -> "void":
        """


        get(self, bool ind1, Sparsity sp) -> IM
        get(self, bool ind1, Slice rr) -> IM
        get(self, bool ind1, IM rr) -> IM
        get(self, bool ind1, Slice rr, Slice cc) -> IM
        get(self, bool ind1, Slice rr, IM cc) -> IM
        get(self, bool ind1, IM rr, Slice cc) -> IM
        get(self, bool ind1, IM rr, IM cc) -> IM



        """
        return _casadi.IM_get(self, *args)


    def set(self, *args) -> "void":
        """


        set(self, IM m, bool ind1, Sparsity sp)
        set(self, IM m, bool ind1, Slice rr)
        set(self, IM m, bool ind1, IM rr)
        set(self, IM m, bool ind1, Slice rr, Slice cc)
        set(self, IM m, bool ind1, Slice rr, IM cc)
        set(self, IM m, bool ind1, IM rr, Slice cc)
        set(self, IM m, bool ind1, IM rr, IM cc)



        """
        return _casadi.IM_set(self, *args)


    def get_nz(self, *args) -> "void":
        """


        get_nz(self, bool ind1, Slice k) -> IM
        get_nz(self, bool ind1, IM k) -> IM



        """
        return _casadi.IM_get_nz(self, *args)


    def set_nz(self, *args) -> "void":
        """


        set_nz(self, IM m, bool ind1, Slice k)
        set_nz(self, IM m, bool ind1, IM k)



        """
        return _casadi.IM_set_nz(self, *args)


    def __pos__(self, *args) -> "casadi::Matrix< int >":
        """


        __pos__(self) -> IM



        """
        return _casadi.IM___pos__(self, *args)


    def __neg__(self, *args) -> "casadi::Matrix< int >":
        """


        __neg__(self) -> IM



        """
        return _casadi.IM___neg__(self, *args)


    def binary(*args) -> "casadi::Matrix< int >":
        """


        binary(int op, IM x, IM y) -> IM



        """
        return _casadi.IM_binary(*args)

    binary = staticmethod(binary)

    def unary(*args) -> "casadi::Matrix< int >":
        """


        unary(int op, IM x) -> IM



        """
        return _casadi.IM_unary(*args)

    unary = staticmethod(unary)

    def scalar_matrix(*args) -> "casadi::Matrix< int >":
        """


        scalar_matrix(int op, IM x, IM y) -> IM



        """
        return _casadi.IM_scalar_matrix(*args)

    scalar_matrix = staticmethod(scalar_matrix)

    def matrix_scalar(*args) -> "casadi::Matrix< int >":
        """


        matrix_scalar(int op, IM x, IM y) -> IM



        """
        return _casadi.IM_matrix_scalar(*args)

    matrix_scalar = staticmethod(matrix_scalar)

    def matrix_matrix(*args) -> "casadi::Matrix< int >":
        """


        matrix_matrix(int op, IM x, IM y) -> IM



        """
        return _casadi.IM_matrix_matrix(*args)

    matrix_matrix = staticmethod(matrix_matrix)

    def printme(self, *args) -> "casadi::Matrix< int >":
        """


        printme(self, IM y) -> IM



        """
        return _casadi.IM_printme(self, *args)


    def set_max_depth(*args) -> "void":
        """


        set_max_depth(int eq_depth)



        """
        return _casadi.IM_set_max_depth(*args)

    set_max_depth = staticmethod(set_max_depth)

    def get_max_depth(*args) -> "int":
        """


        get_max_depth() -> int



        """
        return _casadi.IM_get_max_depth(*args)

    get_max_depth = staticmethod(get_max_depth)

    def setEqualityCheckingDepth(*args) -> "void":
        """


        setEqualityCheckingDepth(int eq_depth)



        """
        return _casadi.IM_setEqualityCheckingDepth(*args)

    setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)

    def getEqualityCheckingDepth(*args) -> "int":
        """


        getEqualityCheckingDepth() -> int



        """
        return _casadi.IM_getEqualityCheckingDepth(*args)

    getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)

    def get_input(*args) -> "std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >":
        """


        get_input(Function f) -> [IM]



        """
        return _casadi.IM_get_input(*args)

    get_input = staticmethod(get_input)

    def get_free(*args) -> "std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >":
        """


        get_free(Function f) -> [IM]



        """
        return _casadi.IM_get_free(*args)

    get_free = staticmethod(get_free)

    def type_name(*args) -> "std::string":
        """


        type_name() -> str



        """
        return _casadi.IM_type_name(*args)

    type_name = staticmethod(type_name)

    def print_split(self, *args) -> "void":
        """


        print_split(self) -> ([str] OUTPUT, [str] OUTPUT)



        """
        return _casadi.IM_print_split(self, *args)


    def print_scalar(self, *args) -> "void":
        """


        print_scalar(self, bool trailing_newline)



        """
        return _casadi.IM_print_scalar(self, *args)


    def print_vector(self, *args) -> "void":
        """


        print_vector(self, bool trailing_newline)



        """
        return _casadi.IM_print_vector(self, *args)


    def print_dense(self, *args) -> "void":
        """


        print_dense(self, bool trailing_newline)



        """
        return _casadi.IM_print_dense(self, *args)


    def print_sparse(self, *args) -> "void":
        """


        print_sparse(self, bool trailing_newline)



        """
        return _casadi.IM_print_sparse(self, *args)


    def clear(self, *args) -> "void":
        """


        clear(self)



        """
        return _casadi.IM_clear(self, *args)


    def resize(self, *args) -> "void":
        """


        resize(self, int nrow, int ncol)



        """
        return _casadi.IM_resize(self, *args)


    def reserve(self, *args) -> "void":
        """


        reserve(self, int nnz)
        reserve(self, int nnz, int ncol)



        """
        return _casadi.IM_reserve(self, *args)


    def erase(self, *args) -> "void":
        """


        erase(self, [int] rr, bool ind1)
        erase(self, [int] rr, [int] cc, bool ind1)



        """
        return _casadi.IM_erase(self, *args)


    def remove(self, *args) -> "void":
        """


        remove(self, [int] rr, [int] cc)



        """
        return _casadi.IM_remove(self, *args)


    def enlarge(self, *args) -> "void":
        """


        enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)



        """
        return _casadi.IM_enlarge(self, *args)


    def sparsity(self, *args) -> "casadi::Sparsity":
        """


        sparsity(self) -> Sparsity



        """
        return _casadi.IM_sparsity(self, *args)


    def triplet(*args) -> "casadi::Matrix< int >":
        """


        triplet([int] row, [int] col, IM d) -> IM
        triplet([int] row, [int] col, IM d, (int,int) rc) -> IM
        triplet([int] row, [int] col, IM d, int nrow, int ncol) -> IM



        """
        return _casadi.IM_triplet(*args)

    triplet = staticmethod(triplet)

    def inf(*args) -> "casadi::Matrix< int >":
        """


        inf(int nrow, int ncol) -> IM
        inf((int,int) rc) -> IM
        inf(Sparsity sp) -> IM



        """
        return _casadi.IM_inf(*args)

    inf = staticmethod(inf)

    def nan(*args) -> "casadi::Matrix< int >":
        """


        nan(int nrow, int ncol) -> IM
        nan((int,int) rc) -> IM
        nan(Sparsity sp) -> IM



        """
        return _casadi.IM_nan(*args)

    nan = staticmethod(nan)

    def eye(*args) -> "casadi::Matrix< int >":
        """


        eye(int ncol) -> IM



        """
        return _casadi.IM_eye(*args)

    eye = staticmethod(eye)

    def element_hash(self, *args) -> "size_t":
        """


        element_hash(self) -> size_t



        """
        return _casadi.IM_element_hash(self, *args)


    def is_regular(self, *args) -> "bool":
        """


        is_regular(self) -> bool



        """
        return _casadi.IM_is_regular(self, *args)


    def is_smooth(self, *args) -> "bool":
        """


        is_smooth(self) -> bool



        """
        return _casadi.IM_is_smooth(self, *args)


    def is_leaf(self, *args) -> "bool":
        """


        is_leaf(self) -> bool



        """
        return _casadi.IM_is_leaf(self, *args)


    def is_commutative(self, *args) -> "bool":
        """


        is_commutative(self) -> bool



        """
        return _casadi.IM_is_commutative(self, *args)


    def is_symbolic(self, *args) -> "bool":
        """


        is_symbolic(self) -> bool



        """
        return _casadi.IM_is_symbolic(self, *args)


    def is_valid_input(self, *args) -> "bool":
        """


        is_valid_input(self) -> bool



        """
        return _casadi.IM_is_valid_input(self, *args)


    def has_duplicates(self, *args) -> "bool":
        """


        has_duplicates(self) -> bool



        """
        return _casadi.IM_has_duplicates(self, *args)


    def reset_input(self, *args) -> "void":
        """


        reset_input(self)



        """
        return _casadi.IM_reset_input(self, *args)


    def is_constant(self, *args) -> "bool":
        """


        is_constant(self) -> bool



        """
        return _casadi.IM_is_constant(self, *args)


    def is_integer(self, *args) -> "bool":
        """


        is_integer(self) -> bool



        """
        return _casadi.IM_is_integer(self, *args)


    def is_zero(self, *args) -> "bool":
        """


        is_zero(self) -> bool



        """
        return _casadi.IM_is_zero(self, *args)


    def is_one(self, *args) -> "bool":
        """


        is_one(self) -> bool



        """
        return _casadi.IM_is_one(self, *args)


    def is_minus_one(self, *args) -> "bool":
        """


        is_minus_one(self) -> bool



        """
        return _casadi.IM_is_minus_one(self, *args)


    def is_identity(self, *args) -> "bool":
        """


        is_identity(self) -> bool



        """
        return _casadi.IM_is_identity(self, *args)


    def has_zeros(self, *args) -> "bool":
        """


        has_zeros(self) -> bool



        """
        return _casadi.IM_has_zeros(self, *args)


    def nonzeros(self, *args) -> "std::vector< int,std::allocator< int > >":
        """


        nonzeros(self) -> [int]



        """
        return _casadi.IM_nonzeros(self, *args)


    def __float__(self, *args) -> "double":
        """


        __float__(self) -> float



        """
        return _casadi.IM___float__(self, *args)


    def __int__(self, *args) -> "int":
        """


        __int__(self) -> int



        """
        return _casadi.IM___int__(self, *args)


    def name(self, *args) -> "std::string":
        """


        name(self) -> str



        """
        return _casadi.IM_name(self, *args)


    def dep(self, *args) -> "casadi::Matrix< int >":
        """


        dep(self, int ch) -> IM



        """
        return _casadi.IM_dep(self, *args)


    def n_dep(self, *args) -> "int":
        """


        n_dep(self) -> int



        """
        return _casadi.IM_n_dep(self, *args)


    def set_precision(*args) -> "void":
        """


        set_precision(int precision)



        """
        return _casadi.IM_set_precision(*args)

    set_precision = staticmethod(set_precision)

    def set_width(*args) -> "void":
        """


        set_width(int width)



        """
        return _casadi.IM_set_width(*args)

    set_width = staticmethod(set_width)

    def set_scientific(*args) -> "void":
        """


        set_scientific(bool scientific)



        """
        return _casadi.IM_set_scientific(*args)

    set_scientific = staticmethod(set_scientific)

    def __init__(self, *args):
        """


        IM()
        IM(Sparsity sp)
        IM(float val)
        IM([[float]] m)
        IM([float] x)
        IM(IM m)
        IM(DM x)
        IM([SXElem] x)
        IM(SX x)
        IM(int nrow, int ncol)
        IM(Sparsity sp, IM d)



        """
        this = _casadi.new_IM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def assign(self, *args) -> "void":
        """


        assign(self, IM rhs)



        """
        return _casadi.IM_assign(self, *args)


    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi.reshape(self,arg)

    @property
    def T(self):
        return _casadi.transpose(self)

    def __getitem__(self, s):
          if isinstance(s, tuple) and len(s)==2:
            if s[1] is None: raise TypeError("Cannot slice with None")
            return self.get(False, s[0], s[1])
          return self.get(False, s)

    def __setitem__(self,s,val):
          if isinstance(s,tuple) and len(s)==2:
            return self.set(val, False, s[0], s[1])
          return self.set(val, False, s)

    @property
    def nz(self):
      return NZproxy(self)



    def full(self, *args) -> "PyObject *":
        """


        full(self) -> PyObject *



        """
        return _casadi.IM_full(self, *args)



    __array_priority__ = 998.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.full()



    def __abs__(self):
      return abs(int(self))


    def __setstate__(self, state):
        sp = Sparsity.__new__(Sparsity)
        sp.__setstate__(state["sparsity"])
        self.__init__(sp,state["data"])

    def __getstate__(self):
        return {"sparsity" : self.sparsity().__getstate__(), "data": numpy.array(self.nonzeros(),dtype=int)}

    __swig_destroy__ = _casadi.delete_IM
IM_swigregister = _casadi.IM_swigregister
IM_swigregister(IM)

def IM_binary(*args) -> "casadi::Matrix< int >":
    """


    binary(int op, IM x, IM y) -> IM



    """
    return _casadi.IM_binary(*args)

def IM_unary(*args) -> "casadi::Matrix< int >":
    """


    unary(int op, IM x) -> IM



    """
    return _casadi.IM_unary(*args)

def IM_scalar_matrix(*args) -> "casadi::Matrix< int >":
    """


    scalar_matrix(int op, IM x, IM y) -> IM



    """
    return _casadi.IM_scalar_matrix(*args)

def IM_matrix_scalar(*args) -> "casadi::Matrix< int >":
    """


    matrix_scalar(int op, IM x, IM y) -> IM



    """
    return _casadi.IM_matrix_scalar(*args)

def IM_matrix_matrix(*args) -> "casadi::Matrix< int >":
    """


    matrix_matrix(int op, IM x, IM y) -> IM



    """
    return _casadi.IM_matrix_matrix(*args)

def IM_set_max_depth(*args) -> "void":
    """


    set_max_depth(int eq_depth)



    """
    return _casadi.IM_set_max_depth(*args)

def IM_get_max_depth(*args) -> "int":
    """


    get_max_depth() -> int



    """
    return _casadi.IM_get_max_depth(*args)

def IM_setEqualityCheckingDepth(*args) -> "void":
    """


    setEqualityCheckingDepth(int eq_depth)



    """
    return _casadi.IM_setEqualityCheckingDepth(*args)

def IM_getEqualityCheckingDepth(*args) -> "int":
    """


    getEqualityCheckingDepth() -> int



    """
    return _casadi.IM_getEqualityCheckingDepth(*args)

def IM_get_input(*args) -> "std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >":
    """


    get_input(Function f) -> [IM]



    """
    return _casadi.IM_get_input(*args)

def IM_get_free(*args) -> "std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >":
    """


    get_free(Function f) -> [IM]



    """
    return _casadi.IM_get_free(*args)

def IM_type_name(*args) -> "std::string":
    """


    type_name() -> str



    """
    return _casadi.IM_type_name(*args)

def IM_triplet(*args) -> "casadi::Matrix< int >":
    """


    triplet([int] row, [int] col, IM d) -> IM
    triplet([int] row, [int] col, IM d, (int,int) rc) -> IM
    triplet([int] row, [int] col, IM d, int nrow, int ncol) -> IM



    """
    return _casadi.IM_triplet(*args)

def IM_inf(*args) -> "casadi::Matrix< int >":
    """


    inf(int nrow, int ncol) -> IM
    inf((int,int) rc) -> IM
    inf(Sparsity sp) -> IM



    """
    return _casadi.IM_inf(*args)

def IM_nan(*args) -> "casadi::Matrix< int >":
    """


    nan(int nrow, int ncol) -> IM
    nan((int,int) rc) -> IM
    nan(Sparsity sp) -> IM



    """
    return _casadi.IM_nan(*args)

def IM_eye(*args) -> "casadi::Matrix< int >":
    """


    eye(int ncol) -> IM



    """
    return _casadi.IM_eye(*args)

def IM_set_precision(*args) -> "void":
    """


    set_precision(int precision)



    """
    return _casadi.IM_set_precision(*args)

def IM_set_width(*args) -> "void":
    """


    set_width(int width)



    """
    return _casadi.IM_set_width(*args)

def IM_set_scientific(*args) -> "void":
    """


    set_scientific(bool scientific)



    """
    return _casadi.IM_set_scientific(*args)

class SXElem(_object):
    """


    SXElem() -> 



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXElem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SXElem, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        SXElem()
        SXElem(SXElem other)



        """
        this = _casadi.new_SXElem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SXElem
SXElem_swigregister = _casadi.SXElem_swigregister
SXElem_swigregister(SXElem)



try:
  import numpy

  def constpow(x,y):
    pass

  constpow=numpy.frompyfunc(constpow,2,1)
except:
  pass

class SX(MatrixCommon, ExpSX, GenSX, PrintSX):
    """
      Sparse matrix class. SX and DM are specializations.



    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero.  Matrix<Scalar> is polymorphic with a
    std::vector<Scalar> that contain all non-identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [MatrixCommon, ExpSX, GenSX, PrintSX]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SX, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixCommon, ExpSX, GenSX, PrintSX]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SX, name)
    __repr__ = _swig_repr

    def sanity_check(self, *args) -> "void":
        """


        sanity_check(self, bool complete)



        """
        return _casadi.SX_sanity_check(self, *args)


    def has_nz(self, *args) -> "bool":
        """


        has_nz(self, int rr, int cc) -> bool



        """
        return _casadi.SX_has_nz(self, *args)


    def __bool__(self, *args) -> "bool":
        """
        [INTERNAL] 

        __bool__(self) -> bool



        """
        return _casadi.SX___bool__(self, *args)


    def get(self, *args) -> "void":
        """


        get(self, bool ind1, Sparsity sp) -> SX
        get(self, bool ind1, Slice rr) -> SX
        get(self, bool ind1, IM rr) -> SX
        get(self, bool ind1, Slice rr, Slice cc) -> SX
        get(self, bool ind1, Slice rr, IM cc) -> SX
        get(self, bool ind1, IM rr, Slice cc) -> SX
        get(self, bool ind1, IM rr, IM cc) -> SX



        """
        return _casadi.SX_get(self, *args)


    def set(self, *args) -> "void":
        """


        set(self, SX m, bool ind1, Sparsity sp)
        set(self, SX m, bool ind1, Slice rr)
        set(self, SX m, bool ind1, IM rr)
        set(self, SX m, bool ind1, Slice rr, Slice cc)
        set(self, SX m, bool ind1, Slice rr, IM cc)
        set(self, SX m, bool ind1, IM rr, Slice cc)
        set(self, SX m, bool ind1, IM rr, IM cc)



        """
        return _casadi.SX_set(self, *args)


    def get_nz(self, *args) -> "void":
        """


        get_nz(self, bool ind1, Slice k) -> SX
        get_nz(self, bool ind1, IM k) -> SX



        """
        return _casadi.SX_get_nz(self, *args)


    def set_nz(self, *args) -> "void":
        """


        set_nz(self, SX m, bool ind1, Slice k)
        set_nz(self, SX m, bool ind1, IM k)



        """
        return _casadi.SX_set_nz(self, *args)


    def __pos__(self, *args) -> "casadi::Matrix< casadi::SXElem >":
        """


        __pos__(self) -> SX



        """
        return _casadi.SX___pos__(self, *args)


    def __neg__(self, *args) -> "casadi::Matrix< casadi::SXElem >":
        """


        __neg__(self) -> SX



        """
        return _casadi.SX___neg__(self, *args)


    def binary(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        binary(int op, SX x, SX y) -> SX



        """
        return _casadi.SX_binary(*args)

    binary = staticmethod(binary)

    def unary(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        unary(int op, SX x) -> SX



        """
        return _casadi.SX_unary(*args)

    unary = staticmethod(unary)

    def scalar_matrix(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        scalar_matrix(int op, SX x, SX y) -> SX



        """
        return _casadi.SX_scalar_matrix(*args)

    scalar_matrix = staticmethod(scalar_matrix)

    def matrix_scalar(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        matrix_scalar(int op, SX x, SX y) -> SX



        """
        return _casadi.SX_matrix_scalar(*args)

    matrix_scalar = staticmethod(matrix_scalar)

    def matrix_matrix(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        matrix_matrix(int op, SX x, SX y) -> SX



        """
        return _casadi.SX_matrix_matrix(*args)

    matrix_matrix = staticmethod(matrix_matrix)

    def printme(self, *args) -> "casadi::Matrix< casadi::SXElem >":
        """


        printme(self, SX y) -> SX



        """
        return _casadi.SX_printme(self, *args)


    def set_max_depth(*args) -> "void":
        """


        set_max_depth(int eq_depth)



        """
        return _casadi.SX_set_max_depth(*args)

    set_max_depth = staticmethod(set_max_depth)

    def get_max_depth(*args) -> "int":
        """


        get_max_depth() -> int



        """
        return _casadi.SX_get_max_depth(*args)

    get_max_depth = staticmethod(get_max_depth)

    def setEqualityCheckingDepth(*args) -> "void":
        """


        setEqualityCheckingDepth(int eq_depth)



        """
        return _casadi.SX_setEqualityCheckingDepth(*args)

    setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)

    def getEqualityCheckingDepth(*args) -> "int":
        """


        getEqualityCheckingDepth() -> int



        """
        return _casadi.SX_getEqualityCheckingDepth(*args)

    getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)

    def get_input(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
        """


        get_input(Function f) -> [SX]



        """
        return _casadi.SX_get_input(*args)

    get_input = staticmethod(get_input)

    def get_free(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
        """


        get_free(Function f) -> [SX]



        """
        return _casadi.SX_get_free(*args)

    get_free = staticmethod(get_free)

    def type_name(*args) -> "std::string":
        """


        type_name() -> str



        """
        return _casadi.SX_type_name(*args)

    type_name = staticmethod(type_name)

    def print_split(self, *args) -> "void":
        """


        print_split(self) -> ([str] OUTPUT, [str] OUTPUT)



        """
        return _casadi.SX_print_split(self, *args)


    def print_scalar(self, *args) -> "void":
        """


        print_scalar(self, bool trailing_newline)



        """
        return _casadi.SX_print_scalar(self, *args)


    def print_vector(self, *args) -> "void":
        """


        print_vector(self, bool trailing_newline)



        """
        return _casadi.SX_print_vector(self, *args)


    def print_dense(self, *args) -> "void":
        """


        print_dense(self, bool trailing_newline)



        """
        return _casadi.SX_print_dense(self, *args)


    def print_sparse(self, *args) -> "void":
        """


        print_sparse(self, bool trailing_newline)



        """
        return _casadi.SX_print_sparse(self, *args)


    def clear(self, *args) -> "void":
        """


        clear(self)



        """
        return _casadi.SX_clear(self, *args)


    def resize(self, *args) -> "void":
        """


        resize(self, int nrow, int ncol)



        """
        return _casadi.SX_resize(self, *args)


    def reserve(self, *args) -> "void":
        """


        reserve(self, int nnz)
        reserve(self, int nnz, int ncol)



        """
        return _casadi.SX_reserve(self, *args)


    def erase(self, *args) -> "void":
        """


        erase(self, [int] rr, bool ind1)
        erase(self, [int] rr, [int] cc, bool ind1)



        """
        return _casadi.SX_erase(self, *args)


    def remove(self, *args) -> "void":
        """


        remove(self, [int] rr, [int] cc)



        """
        return _casadi.SX_remove(self, *args)


    def enlarge(self, *args) -> "void":
        """


        enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)



        """
        return _casadi.SX_enlarge(self, *args)


    def sparsity(self, *args) -> "casadi::Sparsity":
        """


        sparsity(self) -> Sparsity



        """
        return _casadi.SX_sparsity(self, *args)


    def triplet(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        triplet([int] row, [int] col, SX d) -> SX
        triplet([int] row, [int] col, SX d, (int,int) rc) -> SX
        triplet([int] row, [int] col, SX d, int nrow, int ncol) -> SX



        """
        return _casadi.SX_triplet(*args)

    triplet = staticmethod(triplet)

    def inf(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        inf(int nrow, int ncol) -> SX
        inf((int,int) rc) -> SX
        inf(Sparsity sp) -> SX



        """
        return _casadi.SX_inf(*args)

    inf = staticmethod(inf)

    def nan(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        nan(int nrow, int ncol) -> SX
        nan((int,int) rc) -> SX
        nan(Sparsity sp) -> SX



        """
        return _casadi.SX_nan(*args)

    nan = staticmethod(nan)

    def eye(*args) -> "casadi::Matrix< casadi::SXElem >":
        """


        eye(int ncol) -> SX



        """
        return _casadi.SX_eye(*args)

    eye = staticmethod(eye)

    def element_hash(self, *args) -> "size_t":
        """


        element_hash(self) -> size_t



        """
        return _casadi.SX_element_hash(self, *args)


    def is_regular(self, *args) -> "bool":
        """


        is_regular(self) -> bool



        """
        return _casadi.SX_is_regular(self, *args)


    def is_smooth(self, *args) -> "bool":
        """


        is_smooth(self) -> bool



        """
        return _casadi.SX_is_smooth(self, *args)


    def is_leaf(self, *args) -> "bool":
        """


        is_leaf(self) -> bool



        """
        return _casadi.SX_is_leaf(self, *args)


    def is_commutative(self, *args) -> "bool":
        """


        is_commutative(self) -> bool



        """
        return _casadi.SX_is_commutative(self, *args)


    def is_symbolic(self, *args) -> "bool":
        """


        is_symbolic(self) -> bool



        """
        return _casadi.SX_is_symbolic(self, *args)


    def is_valid_input(self, *args) -> "bool":
        """


        is_valid_input(self) -> bool



        """
        return _casadi.SX_is_valid_input(self, *args)


    def has_duplicates(self, *args) -> "bool":
        """


        has_duplicates(self) -> bool



        """
        return _casadi.SX_has_duplicates(self, *args)


    def reset_input(self, *args) -> "void":
        """


        reset_input(self)



        """
        return _casadi.SX_reset_input(self, *args)


    def is_constant(self, *args) -> "bool":
        """


        is_constant(self) -> bool



        """
        return _casadi.SX_is_constant(self, *args)


    def is_integer(self, *args) -> "bool":
        """


        is_integer(self) -> bool



        """
        return _casadi.SX_is_integer(self, *args)


    def is_zero(self, *args) -> "bool":
        """


        is_zero(self) -> bool



        """
        return _casadi.SX_is_zero(self, *args)


    def is_one(self, *args) -> "bool":
        """


        is_one(self) -> bool



        """
        return _casadi.SX_is_one(self, *args)


    def is_minus_one(self, *args) -> "bool":
        """


        is_minus_one(self) -> bool



        """
        return _casadi.SX_is_minus_one(self, *args)


    def is_identity(self, *args) -> "bool":
        """


        is_identity(self) -> bool



        """
        return _casadi.SX_is_identity(self, *args)


    def has_zeros(self, *args) -> "bool":
        """


        has_zeros(self) -> bool



        """
        return _casadi.SX_has_zeros(self, *args)


    def nonzeros(self, *args) -> "std::vector< casadi::SXElem,std::allocator< casadi::SXElem > >":
        """


        nonzeros(self) -> [SXElem]



        """
        return _casadi.SX_nonzeros(self, *args)


    def __float__(self, *args) -> "double":
        """


        __float__(self) -> float



        """
        return _casadi.SX___float__(self, *args)


    def __int__(self, *args) -> "int":
        """


        __int__(self) -> int



        """
        return _casadi.SX___int__(self, *args)


    def name(self, *args) -> "std::string":
        """


        name(self) -> str



        """
        return _casadi.SX_name(self, *args)


    def dep(self, *args) -> "casadi::Matrix< casadi::SXElem >":
        """


        dep(self, int ch) -> SX



        """
        return _casadi.SX_dep(self, *args)


    def n_dep(self, *args) -> "int":
        """


        n_dep(self) -> int



        """
        return _casadi.SX_n_dep(self, *args)


    def set_precision(*args) -> "void":
        """


        set_precision(int precision)



        """
        return _casadi.SX_set_precision(*args)

    set_precision = staticmethod(set_precision)

    def set_width(*args) -> "void":
        """


        set_width(int width)



        """
        return _casadi.SX_set_width(*args)

    set_width = staticmethod(set_width)

    def set_scientific(*args) -> "void":
        """


        set_scientific(bool scientific)



        """
        return _casadi.SX_set_scientific(*args)

    set_scientific = staticmethod(set_scientific)

    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi.reshape(self,arg)

    @property
    def T(self):
        return _casadi.transpose(self)

    def __getitem__(self, s):
          if isinstance(s, tuple) and len(s)==2:
            if s[1] is None: raise TypeError("Cannot slice with None")
            return self.get(False, s[0], s[1])
          return self.get(False, s)

    def __setitem__(self,s,val):
          if isinstance(s,tuple) and len(s)==2:
            return self.set(val, False, s[0], s[1])
          return self.set(val, False, s)

    @property
    def nz(self):
      return NZproxy(self)




    __array_priority__ = 1001.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.full()



    def __init__(self, *args):
        """


        SX()
        SX(Sparsity sp)
        SX(float val)
        SX([[float]] m)
        SX([float] x)
        SX([int] x)
        SX(IM x)
        SX(DM x)
        SX(SX m)
        SX(int nrow, int ncol)
        SX(Sparsity sp, SX d)



        """
        this = _casadi.new_SX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_SX
SX_swigregister = _casadi.SX_swigregister
SX_swigregister(SX)

def SX_binary(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    binary(int op, SX x, SX y) -> SX



    """
    return _casadi.SX_binary(*args)

def SX_unary(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    unary(int op, SX x) -> SX



    """
    return _casadi.SX_unary(*args)

def SX_scalar_matrix(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    scalar_matrix(int op, SX x, SX y) -> SX



    """
    return _casadi.SX_scalar_matrix(*args)

def SX_matrix_scalar(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    matrix_scalar(int op, SX x, SX y) -> SX



    """
    return _casadi.SX_matrix_scalar(*args)

def SX_matrix_matrix(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    matrix_matrix(int op, SX x, SX y) -> SX



    """
    return _casadi.SX_matrix_matrix(*args)

def SX_set_max_depth(*args) -> "void":
    """


    set_max_depth(int eq_depth)



    """
    return _casadi.SX_set_max_depth(*args)

def SX_get_max_depth(*args) -> "int":
    """


    get_max_depth() -> int



    """
    return _casadi.SX_get_max_depth(*args)

def SX_setEqualityCheckingDepth(*args) -> "void":
    """


    setEqualityCheckingDepth(int eq_depth)



    """
    return _casadi.SX_setEqualityCheckingDepth(*args)

def SX_getEqualityCheckingDepth(*args) -> "int":
    """


    getEqualityCheckingDepth() -> int



    """
    return _casadi.SX_getEqualityCheckingDepth(*args)

def SX_get_input(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
    """


    get_input(Function f) -> [SX]



    """
    return _casadi.SX_get_input(*args)

def SX_get_free(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
    """


    get_free(Function f) -> [SX]



    """
    return _casadi.SX_get_free(*args)

def SX_type_name(*args) -> "std::string":
    """


    type_name() -> str



    """
    return _casadi.SX_type_name(*args)

def SX_triplet(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    triplet([int] row, [int] col, SX d) -> SX
    triplet([int] row, [int] col, SX d, (int,int) rc) -> SX
    triplet([int] row, [int] col, SX d, int nrow, int ncol) -> SX



    """
    return _casadi.SX_triplet(*args)

def SX_inf(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    inf(int nrow, int ncol) -> SX
    inf((int,int) rc) -> SX
    inf(Sparsity sp) -> SX



    """
    return _casadi.SX_inf(*args)

def SX_nan(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    nan(int nrow, int ncol) -> SX
    nan((int,int) rc) -> SX
    nan(Sparsity sp) -> SX



    """
    return _casadi.SX_nan(*args)

def SX_eye(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    eye(int ncol) -> SX



    """
    return _casadi.SX_eye(*args)

def SX_set_precision(*args) -> "void":
    """


    set_precision(int precision)



    """
    return _casadi.SX_set_precision(*args)

def SX_set_width(*args) -> "void":
    """


    set_width(int width)



    """
    return _casadi.SX_set_width(*args)

def SX_set_scientific(*args) -> "void":
    """


    set_scientific(bool scientific)



    """
    return _casadi.SX_set_scientific(*args)

class MX(ExpMX, GenMX, SharedObject):
    """
      MX - Matrix expression.



    The MX class is used to build up trees made up from MXNodes. It is a more
    general graph representation than the scalar expression, SX, and much less
    efficient for small objects. On the other hand, the class allows much more
    general operations than does SX, in particular matrix valued operations and
    calls to arbitrary differentiable functions.

    The MX class is designed to have identical syntax with the Matrix<> template
    class, and uses Matrix<double> as its internal representation of the values
    at a node. By keeping the syntaxes identical, it is possible to switch from
    one class to the other, as well as inlining MX functions to SXElem
    functions.

    Note that an operation is always "lazy", making a matrix multiplication
    will create a matrix multiplication node, not perform the actual
    multiplication.

    Joel Andersson

    C++ includes: mx.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [ExpMX, GenMX, SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MX, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpMX, GenMX, SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MX, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
          Create sparse matrix constant (also implicit type conversion)

          MX()
            Default constructor.
          MX(Sparsity sp)
            Create a sparse matrix from a sparsity pattern. Same as MX::ones(sparsity)
          MX(float x)
            Create scalar constant (also implicit type conversion)
          MX([float] x)
            Create vector constant (also implicit type conversion)
          MX(DM x)
          MX(MX x)
            Copy constructor.
          MX(int nrow, int ncol)
            Create a sparse matrix with all structural zeros.
          MX(Sparsity sp, MX val)
            Construct matrix with a given sparsity and nonzeros.



        > MX(Sparsity sp)
        ------------------------------------------------------------------------


        Create a sparse matrix from a sparsity pattern. Same as MX::ones(sparsity)


        > MX(Sparsity sp, MX val)
        ------------------------------------------------------------------------


        Construct matrix with a given sparsity and nonzeros.


        > MX()
        ------------------------------------------------------------------------


        Default constructor.


        > MX(float x)
        ------------------------------------------------------------------------


        Create scalar constant (also implicit type conversion)


        > MX([float] x)
        ------------------------------------------------------------------------


        Create vector constant (also implicit type conversion)


        > MX(DM x)
        ------------------------------------------------------------------------


        Create sparse matrix constant (also implicit type conversion)


        > MX(MX x)
        ------------------------------------------------------------------------


        Copy constructor.


        > MX(int nrow, int ncol)
        ------------------------------------------------------------------------


        Create a sparse matrix with all structural zeros.




        """
        this = _casadi.new_MX(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_MX

    def __bool__(self, *args) -> "bool":
        """
        Returns the truth value of an MX expression.

        __bool__(self) -> bool





        """
        return _casadi.MX___bool__(self, *args)


    def sparsity(self, *args) -> "casadi::Sparsity":
        """
        Get an owning reference to the sparsity pattern.

        sparsity(self) -> Sparsity





        """
        return _casadi.MX_sparsity(self, *args)


    def erase(self, *args) -> "void":
        """
          Erase a submatrix (leaving structural zeros in its place) Erase elements of

          erase(self, [int] rr, bool ind1)
          erase(self, [int] rr, [int] cc, bool ind1)
            Erase a submatrix (leaving structural zeros in its place) Erase rows and/or

        a matrix.


        > erase(self, [int] rr, bool ind1)
        ------------------------------------------------------------------------


        Erase a submatrix (leaving structural zeros in its place) Erase elements of
        a matrix.


        > erase(self, [int] rr, [int] cc, bool ind1)
        ------------------------------------------------------------------------


        Erase a submatrix (leaving structural zeros in its place) Erase rows and/or
        columns of a matrix.




        """
        return _casadi.MX_erase(self, *args)


    def enlarge(self, *args) -> "void":
        """
          Enlarge matrix Make the matrix larger by inserting empty rows and columns,

          enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)

        keeping the existing non-zeros.




        """
        return _casadi.MX_enlarge(self, *args)


    def __neg__(self, *args) -> "casadi::MX":
        """


        __neg__(self) -> MX



        """
        return _casadi.MX___neg__(self, *args)


    def dep(self, *args) -> "casadi::MX":
        """
        Get the nth dependency as MX.

        dep(self, int ch) -> MX





        """
        return _casadi.MX_dep(self, *args)


    def n_out(self, *args) -> "int":
        """
        Number of outputs.

        n_out(self) -> int





        """
        return _casadi.MX_n_out(self, *args)


    def getOutput(self, *args) -> "casadi::MX":
        """
        Get an output.

        getOutput(self, int oind) -> MX





        """
        return _casadi.MX_getOutput(self, *args)


    def n_dep(self, *args) -> "int":
        """
        Get the number of dependencies of a binary SXElem.

        n_dep(self) -> int





        """
        return _casadi.MX_n_dep(self, *args)


    def name(self, *args) -> "std::string":
        """
        Get the name.

        name(self) -> str





        """
        return _casadi.MX_name(self, *args)


    def __float__(self, *args) -> "double":
        """


        __float__(self) -> float



        """
        return _casadi.MX___float__(self, *args)


    def to_DM(self, *args) -> "casadi::Matrix< double >":
        """


        to_DM(self) -> DM



        """
        return _casadi.MX_to_DM(self, *args)


    def is_symbolic(self, *args) -> "bool":
        """
        Check if symbolic.

        is_symbolic(self) -> bool





        """
        return _casadi.MX_is_symbolic(self, *args)


    def is_constant(self, *args) -> "bool":
        """
        Check if constant.

        is_constant(self) -> bool





        """
        return _casadi.MX_is_constant(self, *args)


    def is_call(self, *args) -> "bool":
        """
        Check if evaluation.

        is_call(self) -> bool





        """
        return _casadi.MX_is_call(self, *args)


    def is_output(self, *args) -> "bool":
        """
        Check if evaluation output.

        is_output(self) -> bool





        """
        return _casadi.MX_is_output(self, *args)


    def get_output(self, *args) -> "int":
        """
          Get the index of evaluation output - only valid when is_calloutput() is

          get_output(self) -> int

        true.




        """
        return _casadi.MX_get_output(self, *args)


    def is_op(self, *args) -> "bool":
        """
        Is it a certain operation.

        is_op(self, int op) -> bool





        """
        return _casadi.MX_is_op(self, *args)


    def is_multiplication(self, *args) -> "bool":
        """
        Check if multiplication.

        is_multiplication(self) -> bool





        """
        return _casadi.MX_is_multiplication(self, *args)


    def is_commutative(self, *args) -> "bool":
        """
        Check if commutative operation.

        is_commutative(self) -> bool





        """
        return _casadi.MX_is_commutative(self, *args)


    def is_norm(self, *args) -> "bool":
        """
        Check if norm.

        is_norm(self) -> bool





        """
        return _casadi.MX_is_norm(self, *args)


    def is_valid_input(self, *args) -> "bool":
        """
          Check if matrix can be used to define function inputs. Valid inputs for

          is_valid_input(self) -> bool

        MXFunctions are combinations of Reshape, concatenations and SymbolicMX.




        """
        return _casadi.MX_is_valid_input(self, *args)


    def n_primitives(self, *args) -> "int":
        """
        Get the number of symbolic primitive Assumes is_valid_input() returns true.

        n_primitives(self) -> int





        """
        return _casadi.MX_n_primitives(self, *args)


    def primitives(self, *args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
        """
        Get symbolic primitives.

        primitives(self) -> [MX]





        """
        return _casadi.MX_primitives(self, *args)


    def split_primitives(self, *args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
        """
        Split up an expression along symbolic primitives.

        split_primitives(self, MX x) -> [MX]





        """
        return _casadi.MX_split_primitives(self, *args)


    def join_primitives(self, *args) -> "casadi::MX":
        """
        Join an expression along symbolic primitives.

        join_primitives(self, [MX] v) -> MX





        """
        return _casadi.MX_join_primitives(self, *args)


    def has_duplicates(self, *args) -> "bool":
        """
          [INTERNAL]  Detect duplicate symbolic expressions If there are symbolic

          has_duplicates(self) -> bool

        primitives appearing more than once, the function will return true and the
        names of the duplicate expressions will be printed to userOut<true,
        PL_WARN>(). Note: Will mark the node using MX::set_temp. Make sure to call
        reset_input() after usage.




        """
        return _casadi.MX_has_duplicates(self, *args)


    def reset_input(self, *args) -> "void":
        """
        [INTERNAL]  Reset the marker for an input expression.

        reset_input(self)





        """
        return _casadi.MX_reset_input(self, *args)


    def is_identity(self, *args) -> "bool":
        """
        check if identity

        is_identity(self) -> bool





        """
        return _casadi.MX_is_identity(self, *args)


    def is_zero(self, *args) -> "bool":
        """
        check if zero (note that false negative answers are possible)

        is_zero(self) -> bool





        """
        return _casadi.MX_is_zero(self, *args)


    def is_one(self, *args) -> "bool":
        """
        check if zero (note that false negative answers are possible)

        is_one(self) -> bool





        """
        return _casadi.MX_is_one(self, *args)


    def is_minus_one(self, *args) -> "bool":
        """
        check if zero (note that false negative answers are possible)

        is_minus_one(self) -> bool





        """
        return _casadi.MX_is_minus_one(self, *args)


    def is_transpose(self, *args) -> "bool":
        """
        Is the expression a transpose?

        is_transpose(self) -> bool





        """
        return _casadi.MX_is_transpose(self, *args)


    def is_regular(self, *args) -> "bool":
        """
        Checks if expression does not contain NaN or Inf.

        is_regular(self) -> bool





        """
        return _casadi.MX_is_regular(self, *args)


    def numFunctions(self, *args) -> "int":
        """
        Number of functions.

        numFunctions(self) -> int





        """
        return _casadi.MX_numFunctions(self, *args)


    def getFunction(self, *args) -> "casadi::Function":
        """
        Get function.

        getFunction(self, int i) -> Function





        """
        return _casadi.MX_getFunction(self, *args)


    def is_binary(self, *args) -> "bool":
        """
        Is binary operation.

        is_binary(self) -> bool





        """
        return _casadi.MX_is_binary(self, *args)


    def is_unary(self, *args) -> "bool":
        """
        Is unary operation.

        is_unary(self) -> bool





        """
        return _casadi.MX_is_unary(self, *args)


    def op(self, *args) -> "int":
        """
        Get operation type.

        op(self) -> int





        """
        return _casadi.MX_op(self, *args)


    def get_temp(self, *args) -> "int":
        """
        [INTERNAL]  Get the temporary variable

        get_temp(self) -> int





        """
        return _casadi.MX_get_temp(self, *args)


    def set_temp(self, *args) -> "void":
        """
        [INTERNAL]  Set the temporary variable.

        set_temp(self, int t)





        """
        return _casadi.MX_set_temp(self, *args)


    def binary(*args) -> "casadi::MX":
        """
        Create nodes by their ID.

        binary(int op, MX x, MX y) -> MX





        """
        return _casadi.MX_binary(*args)

    binary = staticmethod(binary)

    def unary(*args) -> "casadi::MX":
        """
        Create nodes by their ID.

        unary(int op, MX x) -> MX





        """
        return _casadi.MX_unary(*args)

    unary = staticmethod(unary)

    def inf(*args) -> "casadi::MX":
        """
        create a matrix with all inf

        inf(int nrow, int ncol) -> MX
        inf((int,int) rc) -> MX
        inf(Sparsity sp) -> MX





        """
        return _casadi.MX_inf(*args)

    inf = staticmethod(inf)

    def nan(*args) -> "casadi::MX":
        """
        create a matrix with all nan

        nan(int nrow, int ncol) -> MX
        nan((int,int) rc) -> MX
        nan(Sparsity sp) -> MX





        """
        return _casadi.MX_nan(*args)

    nan = staticmethod(nan)

    def eye(*args) -> "casadi::MX":
        """


        eye(int ncol) -> MX



        """
        return _casadi.MX_eye(*args)

    eye = staticmethod(eye)

    def get(self, *args) -> "void":
        """
          Get a submatrix, two arguments

          get(self, bool ind1, Sparsity sp) -> MX
            Get a submatrix, single argument
          get(self, bool ind1, Slice rr) -> MX
            Get a submatrix, single argument
          get(self, bool ind1, IM rr) -> MX
            Get a submatrix, single argument
          get(self, bool ind1, Slice rr, Slice cc) -> MX
          get(self, bool ind1, Slice rr, IM cc) -> MX
          get(self, bool ind1, IM rr, Slice cc) -> MX
          get(self, bool ind1, IM rr, IM cc) -> MX



        > get(self, bool ind1, Sparsity sp)
        > get(self, bool ind1, Slice rr)
        > get(self, bool ind1, IM rr)
        ------------------------------------------------------------------------


        Get a submatrix, single argument


        > get(self, bool ind1, Slice rr, Slice cc)
        > get(self, bool ind1, Slice rr, IM cc)
        > get(self, bool ind1, IM rr, Slice cc)
        > get(self, bool ind1, IM rr, IM cc)
        ------------------------------------------------------------------------


        Get a submatrix, two arguments




        """
        return _casadi.MX_get(self, *args)


    def set(self, *args) -> "void":
        """


          set(self, MX m, bool ind1, Sparsity sp)
            Set a submatrix, single argument
          set(self, MX m, bool ind1, Slice rr)
            Set a submatrix, single argument
          set(self, MX m, bool ind1, IM rr)
            Set a submatrix, single argument
          set(self, MX m, bool ind1, Slice rr, Slice cc)
          set(self, MX m, bool ind1, Slice rr, IM cc)
          set(self, MX m, bool ind1, IM rr, Slice cc)
          set(self, MX m, bool ind1, IM rr, IM cc)

        > set(self, MX m, bool ind1, Slice rr, Slice cc)
        > set(self, MX m, bool ind1, Slice rr, IM cc)
        > set(self, MX m, bool ind1, IM rr, Slice cc)
        > set(self, MX m, bool ind1, IM rr, IM cc)
        ------------------------------------------------------------------------



        > set(self, MX m, bool ind1, Sparsity sp)
        > set(self, MX m, bool ind1, Slice rr)
        > set(self, MX m, bool ind1, IM rr)
        ------------------------------------------------------------------------


        Set a submatrix, single argument




        """
        return _casadi.MX_set(self, *args)


    def get_nz(self, *args) -> "void":
        """
        Get a set of nonzeros

        get_nz(self, bool ind1, Slice kk) -> MX
        get_nz(self, bool ind1, IM kk) -> MX





        """
        return _casadi.MX_get_nz(self, *args)


    def set_nz(self, *args) -> "void":
        """
        Set a set of nonzeros

        set_nz(self, MX m, bool ind1, Slice kk)
        set_nz(self, MX m, bool ind1, IM kk)





        """
        return _casadi.MX_set_nz(self, *args)


    def einstein(*args) -> "casadi::MX":
        """
          Computes an einstein dense tensor contraction.

          einstein(MX A, MX B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> MX
          einstein(MX A, MX B, MX C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> MX


        Computes the product: C_c = A_a + B_b where a b c are index/einstein
        notation in an encoded form

        For example, an matrix-matrix product may be written as: C_ij = A_ik B_kj

        The encoded form uses strictly negative numbers to indicate labels. For the
        above example, we would have: a {-1, -3} b {-3, -2} c {-1 -2}




        """
        return _casadi.MX_einstein(*args)

    einstein = staticmethod(einstein)

    def printme(self, *args) -> "casadi::MX":
        """


        printme(self, MX y) -> MX



        """
        return _casadi.MX_printme(self, *args)


    def attachAssert(self, *args) -> "casadi::MX":
        """
          returns itself, but with an assertion attached

          attachAssert(self, MX y, str fail_message) -> MX


        If y does not evaluate to 1, a runtime error is raised




        """
        return _casadi.MX_attachAssert(self, *args)


    def monitor(self, *args) -> "casadi::MX":
        """
          Monitor an expression Returns itself, but with the side effect of printing

          monitor(self, str comment) -> MX

        the nonzeros along with a comment.




        """
        return _casadi.MX_monitor(self, *args)


    def mapping(self, *args) -> "casadi::Matrix< int >":
        """
        Get an IM representation of a GetNonzeros or SetNonzeros node.

        mapping(self) -> IM





        """
        return _casadi.MX_mapping(self, *args)


    def set_max_depth(*args) -> "void":
        """


        set_max_depth(int eq_depth)



        """
        return _casadi.MX_set_max_depth(*args)

    set_max_depth = staticmethod(set_max_depth)

    def get_max_depth(*args) -> "int":
        """


        get_max_depth() -> int



        """
        return _casadi.MX_get_max_depth(*args)

    get_max_depth = staticmethod(get_max_depth)

    def setEqualityCheckingDepth(*args) -> "void":
        """


        setEqualityCheckingDepth(int eq_depth)



        """
        return _casadi.MX_setEqualityCheckingDepth(*args)

    setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)

    def getEqualityCheckingDepth(*args) -> "int":
        """


        getEqualityCheckingDepth() -> int



        """
        return _casadi.MX_getEqualityCheckingDepth(*args)

    getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)

    def test_cast(*args) -> "bool":
        """


        test_cast(casadi::SharedObjectInternal const * ptr) -> bool



        """
        return _casadi.MX_test_cast(*args)

    test_cast = staticmethod(test_cast)

    def get_input(*args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
        """


        get_input(Function f) -> [MX]



        """
        return _casadi.MX_get_input(*args)

    get_input = staticmethod(get_input)

    def get_free(*args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
        """


        get_free(Function f) -> [MX]



        """
        return _casadi.MX_get_free(*args)

    get_free = staticmethod(get_free)

    def type_name(*args) -> "std::string":
        """


        type_name() -> str



        """
        return _casadi.MX_type_name(*args)

    type_name = staticmethod(type_name)

    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi.reshape(self,arg)

    @property
    def T(self):
        return _casadi.transpose(self)

    def __getitem__(self, s):
          if isinstance(s, tuple) and len(s)==2:
            if s[1] is None: raise TypeError("Cannot slice with None")
            return self.get(False, s[0], s[1])
          return self.get(False, s)

    def __setitem__(self,s,val):
          if isinstance(s,tuple) and len(s)==2:
            return self.set(val, False, s[0], s[1])
          return self.set(val, False, s)

    @property
    def nz(self):
      return NZproxy(self)




    __array_priority__ = 1002.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.full()


MX_swigregister = _casadi.MX_swigregister
MX_swigregister(MX)

def MX_binary(*args) -> "casadi::MX":
    """
    Create nodes by their ID.

    binary(int op, MX x, MX y) -> MX





    """
    return _casadi.MX_binary(*args)

def MX_unary(*args) -> "casadi::MX":
    """
    Create nodes by their ID.

    unary(int op, MX x) -> MX





    """
    return _casadi.MX_unary(*args)

def MX_inf(*args) -> "casadi::MX":
    """
    create a matrix with all inf

    inf(int nrow, int ncol) -> MX
    inf((int,int) rc) -> MX
    inf(Sparsity sp) -> MX





    """
    return _casadi.MX_inf(*args)

def MX_nan(*args) -> "casadi::MX":
    """
    create a matrix with all nan

    nan(int nrow, int ncol) -> MX
    nan((int,int) rc) -> MX
    nan(Sparsity sp) -> MX





    """
    return _casadi.MX_nan(*args)

def MX_eye(*args) -> "casadi::MX":
    """


    eye(int ncol) -> MX



    """
    return _casadi.MX_eye(*args)

def MX_einstein(*args) -> "casadi::MX":
    """
      Computes an einstein dense tensor contraction.

      einstein(MX A, MX B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> MX
      einstein(MX A, MX B, MX C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> MX


    Computes the product: C_c = A_a + B_b where a b c are index/einstein
    notation in an encoded form

    For example, an matrix-matrix product may be written as: C_ij = A_ik B_kj

    The encoded form uses strictly negative numbers to indicate labels. For the
    above example, we would have: a {-1, -3} b {-3, -2} c {-1 -2}




    """
    return _casadi.MX_einstein(*args)

def MX_set_max_depth(*args) -> "void":
    """


    set_max_depth(int eq_depth)



    """
    return _casadi.MX_set_max_depth(*args)

def MX_get_max_depth(*args) -> "int":
    """


    get_max_depth() -> int



    """
    return _casadi.MX_get_max_depth(*args)

def MX_setEqualityCheckingDepth(*args) -> "void":
    """


    setEqualityCheckingDepth(int eq_depth)



    """
    return _casadi.MX_setEqualityCheckingDepth(*args)

def MX_getEqualityCheckingDepth(*args) -> "int":
    """


    getEqualityCheckingDepth() -> int



    """
    return _casadi.MX_getEqualityCheckingDepth(*args)

def MX_test_cast(*args) -> "bool":
    """


    test_cast(casadi::SharedObjectInternal const * ptr) -> bool



    """
    return _casadi.MX_test_cast(*args)

def MX_get_input(*args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
    """


    get_input(Function f) -> [MX]



    """
    return _casadi.MX_get_input(*args)

def MX_get_free(*args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
    """


    get_free(Function f) -> [MX]



    """
    return _casadi.MX_get_free(*args)

def MX_type_name(*args) -> "std::string":
    """


    type_name() -> str



    """
    return _casadi.MX_type_name(*args)


def attach_return_type(f,t):
  if not(hasattr(f,'func_annotations')):
    f.func_annotations = {}
  if not(isinstance(getattr(f,'func_annotations'),dict)):
    raise Exception("Cannot annotate this python Method to be a sparsitygenerator. Method has func_annotations attribute with unknown type.")
  f.func_annotations["return"] = t
  return f

def pyevaluate(f):
  return attach_return_type(f,None)

def pycallback(f):
  return attach_return_type(f,int)


def pyfunction(inputs,outputs):
  def wrap(f):

    @pyevaluate
    def fcustom(f2):
      res = f([f2.getInput(i) for i in range(f2.n_in())])
      if not isinstance(res,list):
        res = [res]
      for i in range(f2.n_out()):
        f2.setOutput(res[i],i)
    import warnings

    with warnings.catch_warnings():
      warnings.filterwarnings("ignore",category=DeprecationWarning)
      Fun = CustomFunction("CustomFunction",fcustom,inputs,outputs)
      return Fun

  return wrap

def PyFunction(name, obj, inputs, outputs, opts={}):
    @pyevaluate
    def fcustom(f):
      res = [f.getOutput(i) for i in range(f.n_out())]
      obj.evaluate([f.getInput(i) for i in range(f.n_in())],res)
      for i in range(f.n_out()): f.setOutput(res[i], i)

    import warnings

    with warnings.catch_warnings():
      warnings.filterwarnings("ignore",category=DeprecationWarning)
      return CustomFunction("CustomFunction", fcustom,
                            inputs, outputs, opts)


class Function(SharedObject):
    """
      General function.



    A general function $f$ in casadi can be multi-input, multi-output. Number of
    inputs: nin n_in() Number of outputs: nout n_out()  We can view this
    function as a being composed of a ( nin, nout) grid of single-input, single-
    output primitive functions. Each such primitive function $f_ {i, j}
    \\forall i \\in [0, nin-1], j \\in [0, nout-1]$ can map as $\\mathbf
    {R}^{n, m}\\to\\mathbf{R}^{p, q}$, in which n, m, p, q can take
    different values for every (i, j) pair.  When passing input, you specify
    which partition $i$ is active. You pass the numbers vectorized, as a vector
    of size $(n*m)$. When requesting output, you specify which partition $j$ is
    active. You get the numbers vectorized, as a vector of size $(p*q)$.  To
    calculate Jacobians, you need to have $(m=1, q=1)$.

    Write the Jacobian as $J_ {i, j} = \\nabla f_{i, j} = \\frac
    {\\partial f_{i, j}(\\vec{x})}{\\partial \\vec{x}}$.

    We have the following relationships for function mapping from a row vector
    to a row vector:

    $ \\vec {s}_f = \\nabla f_{i, j} . \\vec{v}$ $ \\vec {s}_a =
    (\\nabla f_{i, j})^T . \\vec{w}$

    Some quantities in these formulas must be transposed: input col: transpose $
    \\vec {v} $ and $\\vec{s}_a$ output col: transpose $ \\vec {w} $ and
    $\\vec{s}_f$  NOTE: Functions are allowed to modify their input arguments
    when evaluating: implicitFunction, IDAS solver Further releases may disallow
    this.

    Joel Andersson >List of available options

    +------------------+-----------------+------------------+------------------+
    |        Id        |      Type       |   Description    |     Used in      |
    +==================+=================+==================+==================+
    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |
    |                  |                 | for derivative   | Internal         |
    |                  |                 | calculation.When |                  |
    |                  |                 | there is an      |                  |
    |                  |                 | option of either |                  |
    |                  |                 | using forward or |                  |
    |                  |                 | reverse mode     |                  |
    |                  |                 | directional      |                  |
    |                  |                 | derivatives, the |                  |
    |                  |                 | condition ad_wei |                  |
    |                  |                 | ght*nf<=(1-ad_we |                  |
    |                  |                 | ight)*na is used |                  |
    |                  |                 | where nf and na  |                  |
    |                  |                 | are estimates of |                  |
    |                  |                 | the number of    |                  |
    |                  |                 | forward/reverse  |                  |
    |                  |                 | mode directional |                  |
    |                  |                 | derivatives      |                  |
    |                  |                 | needed. By       |                  |
    |                  |                 | default,         |                  |
    |                  |                 | ad_weight is     |                  |
    |                  |                 | calculated       |                  |
    |                  |                 | automatically,   |                  |
    |                  |                 | but this can be  |                  |
    |                  |                 | overridden by    |                  |
    |                  |                 | setting this     |                  |
    |                  |                 | option. In       |                  |
    |                  |                 | particular, 0    |                  |
    |                  |                 | means forcing    |                  |
    |                  |                 | forward mode and |                  |
    |                  |                 | 1 forcing        |                  |
    |                  |                 | reverse mode.    |                  |
    |                  |                 | Leave unset for  |                  |
    |                  |                 | (class specific) |                  |
    |                  |                 | heuristics.      |                  |
    +------------------+-----------------+------------------+------------------+
    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |
    |                  |                 | for sparsity     | Internal         |
    |                  |                 | pattern          |                  |
    |                  |                 | calculation calc |                  |
    |                  |                 | ulation.Override |                  |
    |                  |                 | s default        |                  |
    |                  |                 | behavior. Set to |                  |
    |                  |                 | 0 and 1 to force |                  |
    |                  |                 | forward and      |                  |
    |                  |                 | reverse mode     |                  |
    |                  |                 | respectively.    |                  |
    |                  |                 | Cf. option       |                  |
    |                  |                 | "ad_weight".     |                  |
    +------------------+-----------------+------------------+------------------+
    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |
    |                  |                 | compiler plugin  | Internal         |
    |                  |                 | to be used.      |                  |
    +------------------+-----------------+------------------+------------------+
    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |
    |                  |                 | a derivative of  | Internal         |
    |                  |                 | another          |                  |
    |                  |                 | function. The    |                  |
    |                  |                 | type of          |                  |
    |                  |                 | derivative       |                  |
    |                  |                 | (directional     |                  |
    |                  |                 | derivative,      |                  |
    |                  |                 | Jacobian) is     |                  |
    |                  |                 | inferred from    |                  |
    |                  |                 | the function     |                  |
    |                  |                 | name.            |                  |
    +------------------+-----------------+------------------+------------------+
    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |
    |                  |                 | option           | Internal         |
    |                  |                 | (ignored):       |                  |
    |                  |                 | Statistics are   |                  |
    |                  |                 | now always       |                  |
    |                  |                 | collected.       |                  |
    +------------------+-----------------+------------------+------------------+
    | input_scheme     | OT_STRINGVECTOR | Custom input     | casadi::Function |
    |                  |                 | scheme           | Internal         |
    +------------------+-----------------+------------------+------------------+
    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |
    |                  |                 | when the         | Internal         |
    |                  |                 | numerical values |                  |
    |                  |                 | of the inputs    |                  |
    |                  |                 | don't make sense |                  |
    +------------------+-----------------+------------------+------------------+
    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |
    |                  |                 | for a number of  | Internal         |
    |                  |                 | forward/reverse  |                  |
    |                  |                 | directions, it   |                  |
    |                  |                 | may be cheaper   |                  |
    |                  |                 | to compute first |                  |
    |                  |                 | the full         |                  |
    |                  |                 | jacobian and     |                  |
    |                  |                 | then multiply    |                  |
    |                  |                 | with seeds,      |                  |
    |                  |                 | rather than      |                  |
    |                  |                 | obtain the       |                  |
    |                  |                 | requested        |                  |
    |                  |                 | directions in a  |                  |
    |                  |                 | straightforward  |                  |
    |                  |                 | manner. Casadi   |                  |
    |                  |                 | uses a heuristic |                  |
    |                  |                 | to decide which  |                  |
    |                  |                 | is cheaper. A    |                  |
    |                  |                 | high value of    |                  |
    |                  |                 | 'jac_penalty'    |                  |
    |                  |                 | makes it less    |                  |
    |                  |                 | likely for the   |                  |
    |                  |                 | heurstic to      |                  |
    |                  |                 | chose the full   |                  |
    |                  |                 | Jacobian         |                  |
    |                  |                 | strategy. The    |                  |
    |                  |                 | special value -1 |                  |
    |                  |                 | indicates never  |                  |
    |                  |                 | to use the full  |                  |
    |                  |                 | Jacobian         |                  |
    |                  |                 | strategy         |                  |
    +------------------+-----------------+------------------+------------------+
    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |
    |                  |                 | compiler to      | Internal         |
    |                  |                 | speed up the     |                  |
    |                  |                 | evaluation       |                  |
    +------------------+-----------------+------------------+------------------+
    | jit_options      | OT_DICT         | Options to be    | casadi::Function |
    |                  |                 | passed to the    | Internal         |
    |                  |                 | jit compiler.    |                  |
    +------------------+-----------------+------------------+------------------+
    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |
    |                  |                 | maximum number   | Internal         |
    |                  |                 | of directions    |                  |
    |                  |                 | for derivative   |                  |
    |                  |                 | functions.       |                  |
    |                  |                 | Overrules the    |                  |
    |                  |                 | builtin optimize |                  |
    |                  |                 | d_num_dir.       |                  |
    +------------------+-----------------+------------------+------------------+
    | output_scheme    | OT_STRINGVECTOR | Custom output    | casadi::Function |
    |                  |                 | scheme           | Internal         |
    +------------------+-----------------+------------------+------------------+
    | print_time       | OT_BOOL         | print            | casadi::Function |
    |                  |                 | information      | Internal         |
    |                  |                 | about execution  |                  |
    |                  |                 | time             |                  |
    +------------------+-----------------+------------------+------------------+
    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |
    |                  |                 | when NaN or Inf  | Internal         |
    |                  |                 | appears during   |                  |
    |                  |                 | evaluation       |                  |
    +------------------+-----------------+------------------+------------------+
    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |
    |                  |                 | field that can   | Internal         |
    |                  |                 | be used to       |                  |
    |                  |                 | identify the     |                  |
    |                  |                 | function or pass |                  |
    |                  |                 | additional       |                  |
    |                  |                 | information      |                  |
    +------------------+-----------------+------------------+------------------+
    | verbose          | OT_BOOL         | Verbose          | casadi::Function |
    |                  |                 | evaluation  for  | Internal         |
    |                  |                 | debugging        |                  |
    +------------------+-----------------+------------------+------------------+

    C++ includes: function.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Function, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Function, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi.delete_Function

    def expand(self, *args) -> "casadi::Function":
        """
        Expand a function to SX.

        expand(self) -> Function
        expand(self, str name, dict opts) -> Function





        """
        return _casadi.Function_expand(self, *args)


    def n_in(self, *args) -> "int":
        """
        Get the number of function inputs.

        n_in(self) -> int





        """
        return _casadi.Function_n_in(self, *args)


    def n_out(self, *args) -> "int":
        """
        Get the number of function outputs.

        n_out(self) -> int





        """
        return _casadi.Function_n_out(self, *args)


    def size1_in(self, *args) -> "int":
        """
        Get input dimension.

        size1_in(self, int ind) -> int
        size1_in(self, str iname) -> int





        """
        return _casadi.Function_size1_in(self, *args)


    def size2_in(self, *args) -> "int":
        """
        Get input dimension.

        size2_in(self, int ind) -> int
        size2_in(self, str iname) -> int





        """
        return _casadi.Function_size2_in(self, *args)


    def size_in(self, *args) -> "std::pair< int,int >":
        """
        Get input dimension.

        size_in(self, int ind) -> (int,int)
        size_in(self, str iname) -> (int,int)





        """
        return _casadi.Function_size_in(self, *args)


    def size1_out(self, *args) -> "int":
        """
        Get output dimension.

        size1_out(self, int ind) -> int
        size1_out(self, str oname) -> int





        """
        return _casadi.Function_size1_out(self, *args)


    def size2_out(self, *args) -> "int":
        """
        Get output dimension.

        size2_out(self, int ind) -> int
        size2_out(self, str oname) -> int





        """
        return _casadi.Function_size2_out(self, *args)


    def size_out(self, *args) -> "std::pair< int,int >":
        """
        Get output dimension.

        size_out(self, int ind) -> (int,int)
        size_out(self, str oname) -> (int,int)





        """
        return _casadi.Function_size_out(self, *args)


    def nnz_in(self, *args) -> "int":
        """
          Get number of input nonzeros.

          nnz_in(self) -> int
          nnz_in(self, int ind) -> int
          nnz_in(self, str iname) -> int


        For a particular input or for all of the inputs




        """
        return _casadi.Function_nnz_in(self, *args)


    def nnz_out(self, *args) -> "int":
        """
          Get number of output nonzeros.

          nnz_out(self) -> int
          nnz_out(self, int ind) -> int
          nnz_out(self, str oname) -> int


        For a particular output or for all of the outputs




        """
        return _casadi.Function_nnz_out(self, *args)


    def numel_in(self, *args) -> "int":
        """
          Get number of input elements.

          numel_in(self) -> int
          numel_in(self, int ind) -> int
          numel_in(self, str iname) -> int


        For a particular input or for all of the inputs




        """
        return _casadi.Function_numel_in(self, *args)


    def numel_out(self, *args) -> "int":
        """
          Get number of output elements.

          numel_out(self) -> int
          numel_out(self, int ind) -> int
          numel_out(self, str oname) -> int


        For a particular output or for all of the outputs




        """
        return _casadi.Function_numel_out(self, *args)


    def name_in(self, *args) -> "std::string":
        """
          Get input scheme name by index.

          name_in(self) -> [str]
            Get input scheme.
          name_in(self, int ind) -> str



        > name_in(self, int ind)
        ------------------------------------------------------------------------


        Get input scheme name by index.


        > name_in(self)
        ------------------------------------------------------------------------


        Get input scheme.




        """
        return _casadi.Function_name_in(self, *args)


    def name_out(self, *args) -> "std::string":
        """
          Get output scheme name by index.

          name_out(self) -> [str]
            Get output scheme.
          name_out(self, int ind) -> str



        > name_out(self, int ind)
        ------------------------------------------------------------------------


        Get output scheme name by index.


        > name_out(self)
        ------------------------------------------------------------------------


        Get output scheme.




        """
        return _casadi.Function_name_out(self, *args)


    def index_in(self, *args) -> "int":
        """
          Find the index for a string describing a particular entry of an input

          index_in(self, str name) -> int

        scheme.

        example: schemeEntry("x_opt") -> returns NLPSOL_X if FunctionInternal
        adheres to SCHEME_NLPINput




        """
        return _casadi.Function_index_in(self, *args)


    def index_out(self, *args) -> "int":
        """
          Find the index for a string describing a particular entry of an output

          index_out(self, str name) -> int

        scheme.

        example: schemeEntry("x_opt") -> returns NLPSOL_X if FunctionInternal
        adheres to SCHEME_NLPINput




        """
        return _casadi.Function_index_out(self, *args)


    def default_in(self, *args) -> "double":
        """
        Get default input value (NOTE: constant reference)

        default_in(self, int ind) -> float





        """
        return _casadi.Function_default_in(self, *args)


    def sparsity_in(self, *args) -> "casadi::Sparsity const &":
        """
        Get sparsity of a given input.

        sparsity_in(self, int ind) -> Sparsity
        sparsity_in(self, str iname) -> Sparsity





        """
        return _casadi.Function_sparsity_in(self, *args)


    def sparsity_out(self, *args) -> "casadi::Sparsity const &":
        """
        Get sparsity of a given output.

        sparsity_out(self, int ind) -> Sparsity
        sparsity_out(self, str iname) -> Sparsity





        """
        return _casadi.Function_sparsity_out(self, *args)


    def factory(self, *args) -> "casadi::Function":
        """


        factory(self, str name, [str] s_in, [str] s_out, casadi::Function::AuxOut const & aux, dict opts) -> Function



        """
        return _casadi.Function_factory(self, *args)


    def oracle(self, *args) -> "casadi::Function":
        """
        Get oracle.

        oracle(self) -> Function





        """
        return _casadi.Function_oracle(self, *args)


    def wrap(self, *args) -> "casadi::Function":
        """
        Wrap in an Function instance consisting of only one MX call.

        wrap(self) -> Function





        """
        return _casadi.Function_wrap(self, *args)


    def which_depends(self, *args) -> "std::vector< bool,std::allocator< bool > >":
        """
          Which variables enter with some order.

          which_depends(self, str s_in, [str] s_out, int order, bool tr) -> [bool]


        Parameters:
        -----------

        order:  Only 1 (linear) and 2 (nonlinear) allowed

        tr:  Flip the relationship. Return which expressions contain the variables




        """
        return _casadi.Function_which_depends(self, *args)


    def print_dimensions(self, *args) -> "void":
        """
        Print dimensions of inputs and outputs.

        print_dimensions(self)





        """
        return _casadi.Function_print_dimensions(self, *args)


    def print_options(self, *args) -> "void":
        """
        Print options to a stream.

        print_options(self)





        """
        return _casadi.Function_print_options(self, *args)


    def print_option(self, *args) -> "void":
        """
        Print all information there is to know about a certain option.

        print_option(self, str name)





        """
        return _casadi.Function_print_option(self, *args)


    def print_free(self, *args) -> "void":
        """
        Print free variables.

        print_free(self)





        """
        return _casadi.Function_print_free(self, *args)


    def jacobian_old(self, *args) -> "casadi::Function":
        """
          Generate a Jacobian function of output oind with respect to input iind.

          jacobian_old(self, int iind, int oind, bool compact, bool symmetric) -> Function


        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output Legacy function: To be deprecated in a future
        version of CasADi. Exists only for compatibility with Function::jacobian
        pre-CasADi 3.2




        """
        return _casadi.Function_jacobian_old(self, *args)


    def hessian_old(self, *args) -> "casadi::Function":
        """
          Generate a Hessian function of output oind with respect to input iind.

          hessian_old(self, int iind, int oind) -> Function


        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output Legacy function: To be deprecated in a future
        version of CasADi. Exists only for compatibility with Function::hessian pre-
        CasADi 3.2




        """
        return _casadi.Function_hessian_old(self, *args)


    def fullJacobian(self, *args) -> "casadi::Function":
        """
          Generate a Jacobian function of all the inputs elements with respect to all

          fullJacobian(self) -> Function

        the output elements). Legacy function: To be deprecated.




        """
        return _casadi.Function_fullJacobian(self, *args)


    def jacobian(self, *args) -> "casadi::Function":
        """
          [INTERNAL]  Generate a Jacobian function of output oind with respect to

          jacobian(self, int iind, int oind, bool compact, bool symmetric) -> Function
            [DEPRECATED] Alias of Function::jacobian_old This function is of internal
          jacobian(self, str iind, int oind, bool compact, bool symmetric) -> Function
          jacobian(self, int iind, str oind, bool compact, bool symmetric) -> Function
          jacobian(self, str iind, str oind, bool compact, bool symmetric) -> Function

        input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output Legacy function: To be deprecated in a future
        version of CasADi. Exists only for compatibility with Function::jacobian
        pre-CasADi 3.2


        > jacobian(self, int iind, int oind, bool compact, bool symmetric)
        ------------------------------------------------------------------------


        [DEPRECATED] Alias of Function::jacobian_old This function is of internal
        character and should be avoided, if possible. The preferred way is to use
        unction::factory instead. This function will change behavior in the next
        version of CasADi.


        > jacobian(self, str iind, int oind, bool compact, bool symmetric)
        > jacobian(self, int iind, str oind, bool compact, bool symmetric)
        > jacobian(self, str iind, str oind, bool compact, bool symmetric)
        ------------------------------------------------------------------------


        [INTERNAL]  Generate a Jacobian function of output oind with respect to
        input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output Legacy function: To be deprecated in a future
        version of CasADi. Exists only for compatibility with Function::jacobian
        pre-CasADi 3.2




        """
        return _casadi.Function_jacobian(self, *args)


    def setJacobian(self, *args) -> "void":
        """
          [DEPRECATED] Set the Jacobian function of output oind with respect to input

          setJacobian(self, Function jac, int iind, int oind, bool compact)

        iind NOTE: Does not take ownership, only weak references to the Jacobians
        are kept internally




        """
        return _casadi.Function_setJacobian(self, *args)


    def setFullJacobian(self, *args) -> "void":
        """
          [DEPRECATED] Set the Jacobian of all the input nonzeros with respect to all

          setFullJacobian(self, Function jac)

        output nonzeros NOTE: Does not take ownership, only weak references to the
        Jacobian are kept internally




        """
        return _casadi.Function_setFullJacobian(self, *args)


    def gradient(self, *args) -> "casadi::Function":
        """
        [DEPRECATED] Use Function::factory instead

        gradient(self, int iind, int oind) -> Function
        gradient(self, str iind, int oind) -> Function
        gradient(self, int iind, str oind) -> Function
        gradient(self, str iind, str oind) -> Function





        """
        return _casadi.Function_gradient(self, *args)


    def tangent(self, *args) -> "casadi::Function":
        """
        [DEPRECATED] Use Function::factory instead

        tangent(self, int iind, int oind) -> Function
        tangent(self, str iind, int oind) -> Function
        tangent(self, int iind, str oind) -> Function
        tangent(self, str iind, str oind) -> Function





        """
        return _casadi.Function_tangent(self, *args)


    def hessian(self, *args) -> "casadi::Function":
        """
          [DEPRECATED] Alias of Function::jacobian_old This function is of internal

          hessian(self, int iind, int oind) -> Function
          hessian(self, str iind, int oind) -> Function
          hessian(self, int iind, str oind) -> Function
          hessian(self, str iind, str oind) -> Function

        character and should be avoided, if possible. The preferred way is to use
        unction::factory instead. This function will change behavior in the next
        version of CasADi.




        """
        return _casadi.Function_hessian(self, *args)


    def call(self, *args) -> "void":
        """
        Evaluate the function symbolically or numerically.

        call(self, dict:DM arg, bool always_inline, bool never_inline) -> dict:DM
        call(self, [DM] arg, bool always_inline, bool never_inline) -> [DM]
        call(self, [SX] arg, bool always_inline, bool never_inline) -> [SX]
        call(self, dict:SX arg, bool always_inline, bool never_inline) -> dict:SX
        call(self, dict:MX arg, bool always_inline, bool never_inline) -> dict:MX
        call(self, [MX] arg, bool always_inline, bool never_inline) -> [MX]





        """
        return _casadi.Function_call(self, *args)


    def mapsum(self, *args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
        """
          Evaluate symbolically in parallel and sum (matrix graph)

          mapsum(self, [MX] arg, str parallelization) -> [MX]


        Parameters:
        -----------

        parallelization:  Type of parallelization used: unroll|serial|openmp




        """
        return _casadi.Function_mapsum(self, *args)


    def mapaccum(self, *args) -> "casadi::Function":
        """
          Create a mapaccumulated version of this function.

          mapaccum(self, str name, int n, int n_accum, dict opts) -> Function
          mapaccum(self, str name, int n, [int] accum_in, [int] accum_out, dict opts) -> Function
          mapaccum(self, str name, int n, [str] accum_in, [str] accum_out, dict opts) -> Function


        Suppose the function has a signature of:

        ::

             f: (x, u) -> (x_next , y )




        The the mapaccumulated version has the signature:

        ::

             F: (x0, U) -> (X , Y )

              with
                  U: horzcat([u0, u1, ..., u_(N-1)])
                  X: horzcat([x1, x2, ..., x_N])
                  Y: horzcat([y0, y1, ..., y_(N-1)])

              and
                  x1, y0 <- f(x0, u0)
                  x2, y1 <- f(x1, u1)
                  ...
                  x_N, y_(N-1) <- f(x_(N-1), u_(N-1))







        """
        return _casadi.Function_mapaccum(self, *args)


    def map(self, *args) -> "casadi::Function":
        """
          Map with reduction A subset of the inputs are non-repeated and a subset of

          map(self, int n, str parallelization) -> Function
            Create a mapped version of this function.
          map(self, str name, str parallelization, int n, [int] reduce_in, [int] reduce_out, dict opts) -> Function
          map(self, str name, str parallelization, int n, [str] reduce_in, [str] reduce_out, dict opts) -> Function

        the outputs summed up.


        > map(self, int n, str parallelization)
        ------------------------------------------------------------------------


        Create a mapped version of this function.

        Suppose the function has a signature of:

        ::

             f: (a, p) -> ( s )




        The the mapped version has the signature:

        ::

             F: (A, P) -> (S )

              with
                  A: horzcat([a0, a1, ..., a_(N-1)])
                  P: horzcat([p0, p1, ..., p_(N-1)])
                  S: horzcat([s0, s1, ..., s_(N-1)])
              and
                  s0 <- f(a0, p0)
                  s1 <- f(a1, p1)
                  ...
                  s_(N-1) <- f(a_(N-1), p_(N-1))




        Parameters:
        -----------

        parallelization:  Type of parallelization used: unroll|serial|openmp


        > map(self, str name, str parallelization, int n, [int] reduce_in, [int] reduce_out, dict opts)
        > map(self, str name, str parallelization, int n, [str] reduce_in, [str] reduce_out, dict opts)
        ------------------------------------------------------------------------


        Map with reduction A subset of the inputs are non-repeated and a subset of
        the outputs summed up.




        """
        return _casadi.Function_map(self, *args)


    def slice(self, *args) -> "casadi::Function":
        """
        returns a new function with a selection of inputs/outputs of the original

        slice(self, str name, [int] order_in, [int] order_out, dict opts) -> Function





        """
        return _casadi.Function_slice(self, *args)


    def conditional(*args) -> "casadi::Function":
        """


        conditional(str name, [Function] f, Function f_def, dict opts) -> Function



        """
        return _casadi.Function_conditional(*args)

    conditional = staticmethod(conditional)

    def bspline(*args) -> "casadi::Function":
        """


        bspline(str name, [[float]] knots, [float] coeffs, [int] degree, int m, dict opts) -> Function



        """
        return _casadi.Function_bspline(*args)

    bspline = staticmethod(bspline)

    def bspline_dual(*args) -> "casadi::Function":
        """


        bspline_dual(str name, [[float]] knots, [float] x, [int] degree, int m, bool reverse, dict opts) -> Function



        """
        return _casadi.Function_bspline_dual(*args)

    bspline_dual = staticmethod(bspline_dual)

    def if_else(*args) -> "casadi::Function":
        """


        if_else(str name, Function f_true, Function f_false, dict opts) -> Function



        """
        return _casadi.Function_if_else(*args)

    if_else = staticmethod(if_else)

    def forward(self, *args) -> "casadi::Function":
        """
          Get a function that calculates nfwd forward derivatives.

          forward(self, int nfwd) -> Function


        Returns a function with n_in + n_out + n_in inputs and nfwd outputs. The
        first n_in inputs correspond to nondifferentiated inputs. The next n_out
        inputs correspond to nondifferentiated outputs. and the last n_in inputs
        correspond to forward seeds, stacked horizontally The n_out outputs
        correspond to forward sensitivities, stacked horizontally. * (n_in = n_in(),
        n_out = n_out())

        The functions returned are cached, meaning that if called multiple timed
        with the same value, then multiple references to the same function will be
        returned.




        """
        return _casadi.Function_forward(self, *args)


    def reverse(self, *args) -> "casadi::Function":
        """
          Get a function that calculates nadj adjoint derivatives.

          reverse(self, int nadj) -> Function


        Returns a function with n_in + n_out + n_out inputs and n_in outputs. The
        first n_in inputs correspond to nondifferentiated inputs. The next n_out
        inputs correspond to nondifferentiated outputs. and the last n_out inputs
        correspond to adjoint seeds, stacked horizontally The n_in outputs
        correspond to adjoint sensitivities, stacked horizontally. * (n_in = n_in(),
        n_out = n_out())

        (n_in = n_in(), n_out = n_out())

        The functions returned are cached, meaning that if called multiple timed
        with the same value, then multiple references to the same function will be
        returned.




        """
        return _casadi.Function_reverse(self, *args)


    def sparsity_jac(self, *args) -> "casadi::Sparsity const":
        """
          [INTERNAL] 

          sparsity_jac(self, int iind) -> Sparsity
          sparsity_jac(self, str iind, int oind, bool compact, bool symmetric) -> Sparsity
            Get, if necessary generate, the sparsity of a Jacobian block
          sparsity_jac(self, int iind, int oind, bool compact, bool symmetric) -> Sparsity
            Get, if necessary generate, the sparsity of a Jacobian block
          sparsity_jac(self, int iind, str oind, bool compact, bool symmetric) -> Sparsity
            Get, if necessary generate, the sparsity of a Jacobian block
          sparsity_jac(self, str iind, str oind, bool compact, bool symmetric) -> Sparsity
            Get, if necessary generate, the sparsity of a Jacobian block

        > sparsity_jac(self, str iind, int oind, bool compact, bool symmetric)
        > sparsity_jac(self, int iind, int oind, bool compact, bool symmetric)
        > sparsity_jac(self, int iind, str oind, bool compact, bool symmetric)
        > sparsity_jac(self, str iind, str oind, bool compact, bool symmetric)
        ------------------------------------------------------------------------


        Get, if necessary generate, the sparsity of a Jacobian block


        > sparsity_jac(self, int iind)
        ------------------------------------------------------------------------


        [INTERNAL] 


        """
        return _casadi.Function_sparsity_jac(self, *args)


    def set_jac_sparsity(self, *args) -> "void":
        """
        [DEPRECATED] Generate the sparsity of a Jacobian block

        set_jac_sparsity(self, Sparsity sp, int iind, int oind, bool compact)
        set_jac_sparsity(self, Sparsity sp, int iind, str oind, bool compact)
        set_jac_sparsity(self, Sparsity sp, str iind, int oind, bool compact)
        set_jac_sparsity(self, Sparsity sp, str iind, str oind, bool compact)





        """
        return _casadi.Function_set_jac_sparsity(self, *args)


    def generate(self, *args) -> "std::string":
        """
        Export / Generate C code for the function.

        generate(self, dict opts) -> str
        generate(self, str fname, dict opts) -> str





        """
        return _casadi.Function_generate(self, *args)


    def generate_dependencies(self, *args) -> "std::string":
        """
        Export / Generate C code for the dependency function.

        generate_dependencies(self, str fname, dict opts) -> str





        """
        return _casadi.Function_generate_dependencies(self, *args)


    def stats(self, *args) -> "casadi::Dict":
        """
        Get all statistics obtained at the end of the last evaluate call.

        stats(self, int mem) -> dict





        """
        return _casadi.Function_stats(self, *args)


    def sx_in(self, *args) -> "std::vector< casadi::SX,std::allocator< casadi::SX > > const":
        """
          Get symbolic primitives equivalent to the input expressions There is no

          sx_in(self) -> [SX]
          sx_in(self, int iind) -> SX
          sx_in(self, str iname) -> SX

        guarantee that subsequent calls return unique answers.




        """
        return _casadi.Function_sx_in(self, *args)


    def mx_in(self, *args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > > const":
        """
          Get symbolic primitives equivalent to the input expressions There is no

          mx_in(self) -> [MX]
          mx_in(self, int ind) -> MX
          mx_in(self, str iname) -> MX

        guarantee that subsequent calls return unique answers.




        """
        return _casadi.Function_mx_in(self, *args)


    def sx_out(self, *args) -> "std::vector< casadi::SX,std::allocator< casadi::SX > > const":
        """
          Get symbolic primitives equivalent to the output expressions There is no

          sx_out(self) -> [SX]
          sx_out(self, int oind) -> SX
          sx_out(self, str oname) -> SX

        guarantee that subsequent calls return unique answers.




        """
        return _casadi.Function_sx_out(self, *args)


    def mx_out(self, *args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > > const":
        """
          Get symbolic primitives equivalent to the output expressions There is no

          mx_out(self) -> [MX]
          mx_out(self, int ind) -> MX
          mx_out(self, str oname) -> MX

        guarantee that subsequent calls return unique answers.




        """
        return _casadi.Function_mx_out(self, *args)


    def free_sx(self, *args) -> "std::vector< casadi::SX,std::allocator< casadi::SX > >":
        """
        Get all the free variables of the function.

        free_sx(self) -> [SX]





        """
        return _casadi.Function_free_sx(self, *args)


    def free_mx(self, *args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
        """
        Get all the free variables of the function.

        free_mx(self) -> [MX]





        """
        return _casadi.Function_free_mx(self, *args)


    def has_free(self, *args) -> "bool":
        """
        Does the function have free variables.

        has_free(self) -> bool





        """
        return _casadi.Function_has_free(self, *args)


    def generate_lifted(self, *args) -> "void":
        """
        Extract the functions needed for the Lifted Newton method.

        generate_lifted(self) -> (Function OUTPUT, Function OUTPUT)





        """
        return _casadi.Function_generate_lifted(self, *args)


    def getAlgorithmSize(self, *args) -> "int":
        """
        Get the number of atomic operations.

        getAlgorithmSize(self) -> int





        """
        return _casadi.Function_getAlgorithmSize(self, *args)


    def getWorkSize(self, *args) -> "int":
        """
        Get the length of the work vector.

        getWorkSize(self) -> int





        """
        return _casadi.Function_getWorkSize(self, *args)


    def getAtomicOperation(self, *args) -> "int":
        """
        Get an atomic operation operator index.

        getAtomicOperation(self, int k) -> int





        """
        return _casadi.Function_getAtomicOperation(self, *args)


    def getAtomicInput(self, *args) -> "std::pair< int,int >":
        """
        Get the (integer) input arguments of an atomic operation.

        getAtomicInput(self, int k) -> (int,int)





        """
        return _casadi.Function_getAtomicInput(self, *args)


    def getAtomicInputReal(self, *args) -> "double":
        """
        Get the floating point output argument of an atomic operation.

        getAtomicInputReal(self, int k) -> float





        """
        return _casadi.Function_getAtomicInputReal(self, *args)


    def getAtomicOutput(self, *args) -> "int":
        """
        Get the (integer) output argument of an atomic operation.

        getAtomicOutput(self, int k) -> int





        """
        return _casadi.Function_getAtomicOutput(self, *args)


    def n_nodes(self, *args) -> "int":
        """
        Number of nodes in the algorithm.

        n_nodes(self) -> int





        """
        return _casadi.Function_n_nodes(self, *args)


    def spCanEvaluate(self, *args) -> "bool":
        """
          [INTERNAL]  Is the class able to propagate seeds through the algorithm?

          spCanEvaluate(self, bool fwd) -> bool


        (for usage, see the example propagating_sparsity.cpp)




        """
        return _casadi.Function_spCanEvaluate(self, *args)


    def sz_arg(self, *args) -> "size_t":
        """
        [INTERNAL]  Get required length of arg field.

        sz_arg(self) -> size_t





        """
        return _casadi.Function_sz_arg(self, *args)


    def sz_res(self, *args) -> "size_t":
        """
        [INTERNAL]  Get required length of res field.

        sz_res(self) -> size_t





        """
        return _casadi.Function_sz_res(self, *args)


    def sz_iw(self, *args) -> "size_t":
        """
        [INTERNAL]  Get required length of iw field.

        sz_iw(self) -> size_t





        """
        return _casadi.Function_sz_iw(self, *args)


    def sz_w(self, *args) -> "size_t":
        """
        [INTERNAL]  Get required length of w field.

        sz_w(self) -> size_t





        """
        return _casadi.Function_sz_w(self, *args)


    def checkInputs(self, *args) -> "void":
        """
        [INTERNAL]  Check if the numerical values of the supplied bounds make sense.

        checkInputs(self)





        """
        return _casadi.Function_checkInputs(self, *args)


    def name(self, *args) -> "std::string":
        """
        Name of the function.

        name(self) -> str





        """
        return _casadi.Function_name(self, *args)


    def type_name(self, *args) -> "std::string":
        """
        Get type name.

        type_name(self) -> str





        """
        return _casadi.Function_type_name(self, *args)


    def is_a(self, *args) -> "bool":
        """
          Check if the function is of a particular type Optionally check if name

          is_a(self, str type, bool recursive) -> bool

        matches one of the base classes (default true)




        """
        return _casadi.Function_is_a(self, *args)


    def check_name(*args) -> "bool":
        """


        check_name(str name) -> bool



        """
        return _casadi.Function_check_name(*args)

    check_name = staticmethod(check_name)

    def fix_name(*args) -> "std::string":
        """


        fix_name(str name) -> str



        """
        return _casadi.Function_fix_name(*args)

    fix_name = staticmethod(fix_name)

    def assert_size_in(self, *args) -> "void":
        """
        Assert that an input dimension is equal so some given value.

        assert_size_in(self, int i, int nrow, int ncol)





        """
        return _casadi.Function_assert_size_in(self, *args)


    def assert_size_out(self, *args) -> "void":
        """
        Assert that an output dimension is equal so some given value.

        assert_size_out(self, int i, int nrow, int ncol)





        """
        return _casadi.Function_assert_size_out(self, *args)


    def checkout(self, *args) -> "int":
        """
        Checkout a memory object.

        checkout(self) -> int





        """
        return _casadi.Function_checkout(self, *args)


    def release(self, *args) -> "void":
        """
        Release a memory object.

        release(self, int mem)





        """
        return _casadi.Function_release(self, *args)


    def get_function(self, *args) -> "casadi::Function":
        """


        get_function(self) -> [str]
        get_function(self, str name) -> Function



        """
        return _casadi.Function_get_function(self, *args)


    def has_function(self, *args) -> "bool":
        """


        has_function(self, str fname) -> bool



        """
        return _casadi.Function_has_function(self, *args)


    def rootfinder_fun(self, *args) -> "casadi::Function":
        """
        [DEPRECATED] Use oracle() instead

        rootfinder_fun(self) -> Function





        """
        return _casadi.Function_rootfinder_fun(self, *args)


    def conic_debug(self, *args) -> "void":
        """
        Generate native code in the interfaced language for debugging

        conic_debug(self, std::ostream & file)
        conic_debug(self, str filename)





        """
        return _casadi.Function_conic_debug(self, *args)


    def __call__(self, *args, **kwargs):
    # Either named inputs or ordered inputs
      if len(args)>0 and len(kwargs)>0:
        raise SyntaxError('Function evaluation requires all arguments to be named or none')
      if len(args)>0:
    # Ordered inputs -> return tuple
        ret = self.call(args)
        if len(ret)==0:
          return None
        elif len(ret)==1:
          return ret[0]
        else:
          return tuple(ret)
      else:
    # Named inputs -> return dictionary
        return self.call(kwargs)


    def __init__(self, *args):
        """


          Function()
            Default constructor, null pointer.
          Function(str fname)
            Construct from a file.
          Function(Function other)
          Function(str name, [SX] arg, [SX] res, dict opts)
            Construct an SX function.
          Function(str name, [MX] arg, [MX] res, dict opts)
            Construct an MX function.
          Function(str name, dict:SX dict, [str] argn, [str] resn, dict opts)
            Construct an SX function.
          Function(str name, dict:MX dict, [str] argn, [str] resn, dict opts)
            Construct an MX function.
          Function(str name, [SX] arg, [SX] res, [str] argn, [str] resn, dict opts)
            Construct an SX function.
          Function(str name, [MX] arg, [MX] res, [str] argn, [str] resn, dict opts)
            Construct an MX function.

        > Function(Function other)
        ------------------------------------------------------------------------

        > Function()
        ------------------------------------------------------------------------


        Default constructor, null pointer.


        > Function(str fname)
        ------------------------------------------------------------------------


        Construct from a file.


        > Function(str name, [SX] arg, [SX] res, dict opts)
        > Function(str name, dict:SX dict, [str] argn, [str] resn, dict opts)
        > Function(str name, [SX] arg, [SX] res, [str] argn, [str] resn, dict opts)
        ------------------------------------------------------------------------


        Construct an SX function.


        > Function(str name, [MX] arg, [MX] res, dict opts)
        > Function(str name, dict:MX dict, [str] argn, [str] resn, dict opts)
        > Function(str name, [MX] arg, [MX] res, [str] argn, [str] resn, dict opts)
        ------------------------------------------------------------------------


        Construct an MX function.




        """
        this = _casadi.new_Function(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Function_swigregister = _casadi.Function_swigregister
Function_swigregister(Function)

def Function_conditional(*args) -> "casadi::Function":
    """


    conditional(str name, [Function] f, Function f_def, dict opts) -> Function



    """
    return _casadi.Function_conditional(*args)

def Function_bspline(*args) -> "casadi::Function":
    """


    bspline(str name, [[float]] knots, [float] coeffs, [int] degree, int m, dict opts) -> Function



    """
    return _casadi.Function_bspline(*args)

def Function_bspline_dual(*args) -> "casadi::Function":
    """


    bspline_dual(str name, [[float]] knots, [float] x, [int] degree, int m, bool reverse, dict opts) -> Function



    """
    return _casadi.Function_bspline_dual(*args)

def Function_if_else(*args) -> "casadi::Function":
    """


    if_else(str name, Function f_true, Function f_false, dict opts) -> Function



    """
    return _casadi.Function_if_else(*args)

def Function_check_name(*args) -> "bool":
    """


    check_name(str name) -> bool



    """
    return _casadi.Function_check_name(*args)

def Function_fix_name(*args) -> "std::string":
    """


    fix_name(str name) -> str



    """
    return _casadi.Function_fix_name(*args)


def external(*args) -> "casadi::Function":
    """
      Load a just-in-time compiled external function File name given.

      external(str name, dict opts) -> Function
        Load an external function File name is assumed to be ./<f_name>.so.
      external(str name, Importer compiler, dict opts) -> Function
      external(str name, str bin_name, dict opts) -> Function
        Load an external function File name given.



    > external(str name, str bin_name, dict opts)
    ------------------------------------------------------------------------


    Load an external function File name given.


    > external(str name, dict opts)
    ------------------------------------------------------------------------


    Load an external function File name is assumed to be ./<f_name>.so.


    > external(str name, Importer compiler, dict opts)
    ------------------------------------------------------------------------


    Load a just-in-time compiled external function File name given.




    """
    return _casadi.external(*args)

def jit(*args) -> "casadi::Function":
    """
      Create a just-in-time compiled function from a C/C++ language string The

      jit(str name, int n_in, int n_out, str body, dict opts) -> Function

    function can an arbitrary number of inputs and outputs that must all be
    scalar-valued. Only specify the function body, assuming that the inputs are
    stored in an array named 'arg' and the outputs stored in an array named
    'res'. The data type used must be 'real_t', which is typically equal to
    'double` or another data type with the same API as 'double'.

    The final generated function will have a structure similar to:

    void fname(const real_t* arg, real_t* res) { <FUNCTION_BODY> }




    """
    return _casadi.jit(*args)

def integrator(*args) -> "casadi::Function":
    """


      integrator(str name, str solver, dict:SX dae, dict opts) -> Function
        Create an ODE/DAE integrator Solves an initial value problem (IVP) coupled
      integrator(str name, str solver, dict:MX dae, dict opts) -> Function

    > integrator(str name, str solver, dict:MX dae, dict opts)
    ------------------------------------------------------------------------



    > integrator(str name, str solver, dict:SX dae, dict opts)
    ------------------------------------------------------------------------


    Create an ODE/DAE integrator Solves an initial value problem (IVP) coupled
    to a terminal value problem with differential equation given as an implicit
    ODE coupled to an algebraic equation and a set of quadratures:



    ::

      Initial conditions at t=t0
      x(t0)  = x0
      q(t0)  = 0

      Forward integration from t=t0 to t=tf
      der(x) = function(x, z, p, t)                  Forward ODE
      0 = fz(x, z, p, t)                  Forward algebraic equations
      der(q) = fq(x, z, p, t)                  Forward quadratures

      Terminal conditions at t=tf
      rx(tf)  = rx0
      rq(tf)  = 0

      Backward integration from t=tf to t=t0
      der(rx) = gx(rx, rz, rp, x, z, p, t)        Backward ODE
      0 = gz(rx, rz, rp, x, z, p, t)        Backward algebraic equations
      der(rq) = gq(rx, rz, rp, x, z, p, t)        Backward quadratures

      where we assume that both the forward and backwards integrations are index-1
      (i.e. dfz/dz, dgz/drz are invertible) and furthermore that
      gx, gz and gq have a linear dependency on rx, rz and rp.



    General information
    ===================



    >List of available options

    +------------------+-----------------+------------------+------------------+
    |        Id        |      Type       |   Description    |     Used in      |
    +==================+=================+==================+==================+
    | augmented_option | OT_DICT         | Options to be    | casadi::Integrat |
    | s                |                 | passed down to   | or               |
    |                  |                 | the augmented    |                  |
    |                  |                 | integrator, if   |                  |
    |                  |                 | one is           |                  |
    |                  |                 | constructed.     |                  |
    +------------------+-----------------+------------------+------------------+
    | common_options   | OT_DICT         | Options for      | casadi::OracleFu |
    |                  |                 | auto-generated   | nction           |
    |                  |                 | functions        |                  |
    +------------------+-----------------+------------------+------------------+
    | expand           | OT_BOOL         | Replace MX with  | casadi::Integrat |
    |                  |                 | SX expressions   | or               |
    |                  |                 | in problem       |                  |
    |                  |                 | formulation      |                  |
    |                  |                 | [false]          |                  |
    +------------------+-----------------+------------------+------------------+
    | grid             | OT_DOUBLEVECTOR | Time grid        | casadi::Integrat |
    |                  |                 |                  | or               |
    +------------------+-----------------+------------------+------------------+
    | monitor          | OT_STRINGVECTOR | Set of user      | casadi::OracleFu |
    |                  |                 | problem          | nction           |
    |                  |                 | functions to be  |                  |
    |                  |                 | monitored        |                  |
    +------------------+-----------------+------------------+------------------+
    | number_of_finite | OT_INT          | Number of finite | casadi::Integrat |
    | _elements        |                 | elements         | or               |
    +------------------+-----------------+------------------+------------------+
    | output_t0        | OT_BOOL         | Output the state | casadi::Integrat |
    |                  |                 | at the initial   | or               |
    |                  |                 | time             |                  |
    +------------------+-----------------+------------------+------------------+
    | print_stats      | OT_BOOL         | Print out        | casadi::Integrat |
    |                  |                 | statistics after | or               |
    |                  |                 | integration      |                  |
    +------------------+-----------------+------------------+------------------+
    | rootfinder       | OT_STRING       | An implicit      | casadi::Integrat |
    |                  |                 | function solver  | or               |
    +------------------+-----------------+------------------+------------------+
    | rootfinder_optio | OT_DICT         | Options to be    | casadi::Integrat |
    | ns               |                 | passed to the    | or               |
    |                  |                 | NLP Solver       |                  |
    +------------------+-----------------+------------------+------------------+
    | specific_options | OT_DICT         | Options for      | casadi::OracleFu |
    |                  |                 | specific auto-   | nction           |
    |                  |                 | generated        |                  |
    |                  |                 | functions,       |                  |
    |                  |                 | overwriting the  |                  |
    |                  |                 | defaults from    |                  |
    |                  |                 | common_options.  |                  |
    |                  |                 | Nested           |                  |
    |                  |                 | dictionary.      |                  |
    +------------------+-----------------+------------------+------------------+
    | t0               | OT_DOUBLE       | Beginning of the | casadi::Integrat |
    |                  |                 | time horizon     | or               |
    +------------------+-----------------+------------------+------------------+
    | tf               | OT_DOUBLE       | End of the time  | casadi::Integrat |
    |                  |                 | horizon          | or               |
    +------------------+-----------------+------------------+------------------+

    >Input scheme: casadi::IntegratorInput (INTEGRATOR_NUM_IN = 6)

    +----------------+-------+-------------------------------------------------+
    |   Full name    | Short |                   Description                   |
    +================+=======+=================================================+
    | INTEGRATOR_X0  | x0    | Differential state at the initial time.         |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_P   | p     | Parameters.                                     |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_Z0  | z0    | Initial guess for the algebraic variable.       |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_RX0 | rx0   | Backward differential state at the final time.  |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_RP  | rp    | Backward parameter vector.                      |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_RZ0 | rz0   | Initial guess for the backwards algebraic       |
    |                |       | variable.                                       |
    +----------------+-------+-------------------------------------------------+

    >Output scheme: casadi::IntegratorOutput (INTEGRATOR_NUM_OUT = 6)

    +----------------+-------+-------------------------------------------------+
    |   Full name    | Short |                   Description                   |
    +================+=======+=================================================+
    | INTEGRATOR_XF  | xf    | Differential state at the final time.           |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_QF  | qf    | Quadrature state at the final time.             |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_ZF  | zf    | Algebraic variable at the final time.           |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_RXF | rxf   | Backward differential state at the initial      |
    |                |       | time.                                           |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_RQF | rqf   | Backward quadrature state at the initial time.  |
    +----------------+-------+-------------------------------------------------+
    | INTEGRATOR_RZF | rzf   | Backward algebraic variable at the initial      |
    |                |       | time.                                           |
    +----------------+-------+-------------------------------------------------+

    List of plugins
    ===============



    - cvodes

    - idas

    - collocation

    - rk

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Integrator.doc("myextraplugin")



    --------------------------------------------------------------------------------

    cvodes
    ------



    Interface to CVodes from the Sundials suite.

    A call to evaluate will integrate to the end.

    You can retrieve the entire state trajectory as follows, after the evaluate
    call: Call reset. Then call integrate(t_i) and getOuput for a series of
    times t_i.

    >List of available options

    +----------------------------+-----------+---------------------------------+
    |             Id             |   Type    |           Description           |
    +============================+===========+=================================+
    | abstol                     | OT_DOUBLE | Absolute tolerence for the IVP  |
    |                            |           | solution                        |
    +----------------------------+-----------+---------------------------------+
    | disable_internal_warnings  | OT_BOOL   | Disable SUNDIALS internal       |
    |                            |           | warning messages                |
    +----------------------------+-----------+---------------------------------+
    | fsens_all_at_once          | OT_BOOL   | Calculate all right hand sides  |
    |                            |           | of the sensitivity equations at |
    |                            |           | once                            |
    +----------------------------+-----------+---------------------------------+
    | fsens_err_con              | OT_BOOL   | include the forward             |
    |                            |           | sensitivities in all error      |
    |                            |           | controls                        |
    +----------------------------+-----------+---------------------------------+
    | interpolation_type         | OT_STRING | Type of interpolation for the   |
    |                            |           | adjoint sensitivities           |
    +----------------------------+-----------+---------------------------------+
    | linear_multistep_method    | OT_STRING | Integrator scheme: BDF|adams    |
    +----------------------------+-----------+---------------------------------+
    | linear_solver              | OT_STRING | A custom linear solver creator  |
    |                            |           | function [default: csparse]     |
    +----------------------------+-----------+---------------------------------+
    | linear_solver_options      | OT_DICT   | Options to be passed to the     |
    |                            |           | linear solver                   |
    +----------------------------+-----------+---------------------------------+
    | max_krylov                 | OT_INT    | Maximum Krylov subspace size    |
    +----------------------------+-----------+---------------------------------+
    | max_multistep_order        | OT_INT    | Maximum order for the           |
    |                            |           | (variable-order) multistep      |
    |                            |           | method                          |
    +----------------------------+-----------+---------------------------------+
    | max_num_steps              | OT_INT    | Maximum number of integrator    |
    |                            |           | steps                           |
    +----------------------------+-----------+---------------------------------+
    | max_order                  | OT_DOUBLE | Maximum order                   |
    +----------------------------+-----------+---------------------------------+
    | newton_scheme              | OT_STRING | Linear solver scheme in the     |
    |                            |           | Newton method:                  |
    |                            |           | DIRECT|gmres|bcgstab|tfqmr      |
    +----------------------------+-----------+---------------------------------+
    | nonlin_conv_coeff          | OT_DOUBLE | Coefficient in the nonlinear    |
    |                            |           | convergence test                |
    +----------------------------+-----------+---------------------------------+
    | nonlinear_solver_iteration | OT_STRING | Nonlinear solver type:          |
    |                            |           | NEWTON|functional               |
    +----------------------------+-----------+---------------------------------+
    | quad_err_con               | OT_BOOL   | Should the quadratures affect   |
    |                            |           | the step size control           |
    +----------------------------+-----------+---------------------------------+
    | reltol                     | OT_DOUBLE | Relative tolerence for the IVP  |
    |                            |           | solution                        |
    +----------------------------+-----------+---------------------------------+
    | second_order_correction    | OT_BOOL   | Second order correction in the  |
    |                            |           | augmented system Jacobian       |
    |                            |           | [true]                          |
    +----------------------------+-----------+---------------------------------+
    | sensitivity_method         | OT_STRING | Sensitivity method:             |
    |                            |           | SIMULTANEOUS|staggered          |
    +----------------------------+-----------+---------------------------------+
    | step0                      | OT_DOUBLE | initial step size [default:     |
    |                            |           | 0/estimated]                    |
    +----------------------------+-----------+---------------------------------+
    | steps_per_checkpoint       | OT_INT    | Number of steps between two     |
    |                            |           | consecutive checkpoints         |
    +----------------------------+-----------+---------------------------------+
    | stop_at_end                | OT_BOOL   | Stop the integrator at the end  |
    |                            |           | of the interval                 |
    +----------------------------+-----------+---------------------------------+
    | use_preconditioner         | OT_BOOL   | Precondition the iterative      |
    |                            |           | solver [default: true]          |
    +----------------------------+-----------+---------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    idas
    ----



    Interface to IDAS from the Sundials suite.

    >List of available options

    +---------------------------+-----------------+----------------------------+
    |            Id             |      Type       |        Description         |
    +===========================+=================+============================+
    | abstol                    | OT_DOUBLE       | Absolute tolerence for the |
    |                           |                 | IVP solution               |
    +---------------------------+-----------------+----------------------------+
    | abstolv                   | OT_DOUBLEVECTOR | Absolute tolerarance for   |
    |                           |                 | each component             |
    +---------------------------+-----------------+----------------------------+
    | calc_ic                   | OT_BOOL         | Use IDACalcIC to get       |
    |                           |                 | consistent initial         |
    |                           |                 | conditions.                |
    +---------------------------+-----------------+----------------------------+
    | calc_icB                  | OT_BOOL         | Use IDACalcIC to get       |
    |                           |                 | consistent initial         |
    |                           |                 | conditions for backwards   |
    |                           |                 | system [default: equal to  |
    |                           |                 | calc_ic].                  |
    +---------------------------+-----------------+----------------------------+
    | cj_scaling                | OT_BOOL         | IDAS scaling on cj for the |
    |                           |                 | user-defined linear solver |
    |                           |                 | module                     |
    +---------------------------+-----------------+----------------------------+
    | disable_internal_warnings | OT_BOOL         | Disable SUNDIALS internal  |
    |                           |                 | warning messages           |
    +---------------------------+-----------------+----------------------------+
    | first_time                | OT_DOUBLE       | First requested time as a  |
    |                           |                 | fraction of the time       |
    |                           |                 | interval                   |
    +---------------------------+-----------------+----------------------------+
    | fsens_err_con             | OT_BOOL         | include the forward        |
    |                           |                 | sensitivities in all error |
    |                           |                 | controls                   |
    +---------------------------+-----------------+----------------------------+
    | init_xdot                 | OT_DOUBLEVECTOR | Initial values for the     |
    |                           |                 | state derivatives          |
    +---------------------------+-----------------+----------------------------+
    | interpolation_type        | OT_STRING       | Type of interpolation for  |
    |                           |                 | the adjoint sensitivities  |
    +---------------------------+-----------------+----------------------------+
    | linear_solver             | OT_STRING       | A custom linear solver     |
    |                           |                 | creator function [default: |
    |                           |                 | csparse]                   |
    +---------------------------+-----------------+----------------------------+
    | linear_solver_options     | OT_DICT         | Options to be passed to    |
    |                           |                 | the linear solver          |
    +---------------------------+-----------------+----------------------------+
    | max_krylov                | OT_INT          | Maximum Krylov subspace    |
    |                           |                 | size                       |
    +---------------------------+-----------------+----------------------------+
    | max_multistep_order       | OT_INT          | Maximum order for the      |
    |                           |                 | (variable-order) multistep |
    |                           |                 | method                     |
    +---------------------------+-----------------+----------------------------+
    | max_num_steps             | OT_INT          | Maximum number of          |
    |                           |                 | integrator steps           |
    +---------------------------+-----------------+----------------------------+
    | max_order                 | OT_DOUBLE       | Maximum order              |
    +---------------------------+-----------------+----------------------------+
    | max_step_size             | OT_DOUBLE       | Maximim step size          |
    +---------------------------+-----------------+----------------------------+
    | newton_scheme             | OT_STRING       | Linear solver scheme in    |
    |                           |                 | the Newton method:         |
    |                           |                 | DIRECT|gmres|bcgstab|tfqmr |
    +---------------------------+-----------------+----------------------------+
    | nonlin_conv_coeff         | OT_DOUBLE       | Coefficient in the         |
    |                           |                 | nonlinear convergence test |
    +---------------------------+-----------------+----------------------------+
    | quad_err_con              | OT_BOOL         | Should the quadratures     |
    |                           |                 | affect the step size       |
    |                           |                 | control                    |
    +---------------------------+-----------------+----------------------------+
    | reltol                    | OT_DOUBLE       | Relative tolerence for the |
    |                           |                 | IVP solution               |
    +---------------------------+-----------------+----------------------------+
    | second_order_correction   | OT_BOOL         | Second order correction in |
    |                           |                 | the augmented system       |
    |                           |                 | Jacobian [true]            |
    +---------------------------+-----------------+----------------------------+
    | sensitivity_method        | OT_STRING       | Sensitivity method:        |
    |                           |                 | SIMULTANEOUS|staggered     |
    +---------------------------+-----------------+----------------------------+
    | step0                     | OT_DOUBLE       | initial step size          |
    |                           |                 | [default: 0/estimated]     |
    +---------------------------+-----------------+----------------------------+
    | steps_per_checkpoint      | OT_INT          | Number of steps between    |
    |                           |                 | two consecutive            |
    |                           |                 | checkpoints                |
    +---------------------------+-----------------+----------------------------+
    | stop_at_end               | OT_BOOL         | Stop the integrator at the |
    |                           |                 | end of the interval        |
    +---------------------------+-----------------+----------------------------+
    | suppress_algebraic        | OT_BOOL         | Suppress algebraic         |
    |                           |                 | variables in the error     |
    |                           |                 | testing                    |
    +---------------------------+-----------------+----------------------------+
    | use_preconditioner        | OT_BOOL         | Precondition the iterative |
    |                           |                 | solver [default: true]     |
    +---------------------------+-----------------+----------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    collocation
    -----------



    Fixed-step implicit Runge-Kutta integrator ODE/DAE integrator based on
    collocation schemes

    The method is still under development

    >List of available options

    +---------------------------+-----------------+----------------------------+
    |            Id             |      Type       |        Description         |
    +===========================+=================+============================+
    | augmented_options         | OT_DICT         | Options to be passed down  |
    |                           |                 | to the augmented           |
    |                           |                 | integrator, if one is      |
    |                           |                 | constructed.               |
    +---------------------------+-----------------+----------------------------+
    | collocation_scheme        | OT_STRING       | Collocation scheme:        |
    |                           |                 | radau|legendre             |
    +---------------------------+-----------------+----------------------------+
    | expand                    | OT_BOOL         | Replace MX with SX         |
    |                           |                 | expressions in problem     |
    |                           |                 | formulation [false]        |
    +---------------------------+-----------------+----------------------------+
    | grid                      | OT_DOUBLEVECTOR | Time grid                  |
    +---------------------------+-----------------+----------------------------+
    | interpolation_order       | OT_INT          | Order of the interpolating |
    |                           |                 | polynomials                |
    +---------------------------+-----------------+----------------------------+
    | number_of_finite_elements | OT_INT          | Number of finite elements  |
    +---------------------------+-----------------+----------------------------+
    | output_t0                 | OT_BOOL         | Output the state at the    |
    |                           |                 | initial time               |
    +---------------------------+-----------------+----------------------------+
    | print_stats               | OT_BOOL         | Print out statistics after |
    |                           |                 | integration                |
    +---------------------------+-----------------+----------------------------+
    | rootfinder                | OT_STRING       | An implicit function       |
    |                           |                 | solver                     |
    +---------------------------+-----------------+----------------------------+
    | rootfinder_options        | OT_DICT         | Options to be passed to    |
    |                           |                 | the NLP Solver             |
    +---------------------------+-----------------+----------------------------+
    | t0                        | OT_DOUBLE       | Beginning of the time      |
    |                           |                 | horizon                    |
    +---------------------------+-----------------+----------------------------+
    | tf                        | OT_DOUBLE       | End of the time horizon    |
    +---------------------------+-----------------+----------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    rk --



    Fixed-step explicit Runge-Kutta integrator for ODEs Currently implements
    RK4.

    The method is still under development

    --------------------------------------------------------------------------------



    Joel Andersson




    """
    return _casadi.integrator(*args)

def has_integrator(*args) -> "bool":
    """
    Check if a particular plugin is available.

    has_integrator(str name) -> bool





    """
    return _casadi.has_integrator(*args)

def load_integrator(*args) -> "void":
    """
    Explicitly load a plugin dynamically.

    load_integrator(str name)





    """
    return _casadi.load_integrator(*args)

def doc_integrator(*args) -> "std::string":
    """
    Get the documentation string for a plugin.

    doc_integrator(str name) -> str





    """
    return _casadi.doc_integrator(*args)

def integrator_in(*args) -> "std::string":
    """
      Get integrator input scheme name by index.

      integrator_in() -> [str]
        Get input scheme of integrators.
      integrator_in(int ind) -> str



    > integrator_in()
    ------------------------------------------------------------------------


    Get input scheme of integrators.


    > integrator_in(int ind)
    ------------------------------------------------------------------------


    Get integrator input scheme name by index.




    """
    return _casadi.integrator_in(*args)

def integrator_out(*args) -> "std::string":
    """
      Get output scheme name by index.

      integrator_out() -> [str]
        Get integrator output scheme of integrators.
      integrator_out(int ind) -> str



    > integrator_out()
    ------------------------------------------------------------------------


    Get integrator output scheme of integrators.


    > integrator_out(int ind)
    ------------------------------------------------------------------------


    Get output scheme name by index.




    """
    return _casadi.integrator_out(*args)

def integrator_n_in(*args) -> "int":
    """
    Get the number of integrator inputs.

    integrator_n_in() -> int





    """
    return _casadi.integrator_n_in(*args)

def integrator_n_out(*args) -> "int":
    """
    Get the number of integrator outputs.

    integrator_n_out() -> int





    """
    return _casadi.integrator_n_out(*args)

def conic(*args) -> "casadi::Function":
    """
      Create a QP solver Solves the following strictly convex problem:

      conic(str name, str solver, dict:Sparsity qp, dict opts) -> Function




    ::

      min          1/2 x' H x + g' x
      x

      subject to
      LBA <= A x <= UBA
      LBX <= x   <= UBX

      with :
      H sparse (n x n) positive definite
      g dense  (n x 1)

      n: number of decision variables (x)
      nc: number of constraints (A)



    If H is not positive-definite, the solver should throw an error.

    General information
    ===================



    >List of available options

    +------------------+-----------------+------------------+------------------+
    |        Id        |      Type       |   Description    |     Used in      |
    +==================+=================+==================+==================+
    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |
    |                  |                 | for derivative   | Internal         |
    |                  |                 | calculation.When |                  |
    |                  |                 | there is an      |                  |
    |                  |                 | option of either |                  |
    |                  |                 | using forward or |                  |
    |                  |                 | reverse mode     |                  |
    |                  |                 | directional      |                  |
    |                  |                 | derivatives, the |                  |
    |                  |                 | condition ad_wei |                  |
    |                  |                 | ght*nf<=(1-ad_we |                  |
    |                  |                 | ight)*na is used |                  |
    |                  |                 | where nf and na  |                  |
    |                  |                 | are estimates of |                  |
    |                  |                 | the number of    |                  |
    |                  |                 | forward/reverse  |                  |
    |                  |                 | mode directional |                  |
    |                  |                 | derivatives      |                  |
    |                  |                 | needed. By       |                  |
    |                  |                 | default,         |                  |
    |                  |                 | ad_weight is     |                  |
    |                  |                 | calculated       |                  |
    |                  |                 | automatically,   |                  |
    |                  |                 | but this can be  |                  |
    |                  |                 | overridden by    |                  |
    |                  |                 | setting this     |                  |
    |                  |                 | option. In       |                  |
    |                  |                 | particular, 0    |                  |
    |                  |                 | means forcing    |                  |
    |                  |                 | forward mode and |                  |
    |                  |                 | 1 forcing        |                  |
    |                  |                 | reverse mode.    |                  |
    |                  |                 | Leave unset for  |                  |
    |                  |                 | (class specific) |                  |
    |                  |                 | heuristics.      |                  |
    +------------------+-----------------+------------------+------------------+
    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |
    |                  |                 | for sparsity     | Internal         |
    |                  |                 | pattern          |                  |
    |                  |                 | calculation calc |                  |
    |                  |                 | ulation.Override |                  |
    |                  |                 | s default        |                  |
    |                  |                 | behavior. Set to |                  |
    |                  |                 | 0 and 1 to force |                  |
    |                  |                 | forward and      |                  |
    |                  |                 | reverse mode     |                  |
    |                  |                 | respectively.    |                  |
    |                  |                 | Cf. option       |                  |
    |                  |                 | "ad_weight".     |                  |
    +------------------+-----------------+------------------+------------------+
    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |
    |                  |                 | compiler plugin  | Internal         |
    |                  |                 | to be used.      |                  |
    +------------------+-----------------+------------------+------------------+
    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |
    |                  |                 | a derivative of  | Internal         |
    |                  |                 | another          |                  |
    |                  |                 | function. The    |                  |
    |                  |                 | type of          |                  |
    |                  |                 | derivative       |                  |
    |                  |                 | (directional     |                  |
    |                  |                 | derivative,      |                  |
    |                  |                 | Jacobian) is     |                  |
    |                  |                 | inferred from    |                  |
    |                  |                 | the function     |                  |
    |                  |                 | name.            |                  |
    +------------------+-----------------+------------------+------------------+
    | discrete         | OT_BOOLVECTOR   | Indicates which  | casadi::Conic    |
    |                  |                 | of the variables |                  |
    |                  |                 | are discrete,    |                  |
    |                  |                 | i.e. integer-    |                  |
    |                  |                 | valued           |                  |
    +------------------+-----------------+------------------+------------------+
    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |
    |                  |                 | option           | Internal         |
    |                  |                 | (ignored):       |                  |
    |                  |                 | Statistics are   |                  |
    |                  |                 | now always       |                  |
    |                  |                 | collected.       |                  |
    +------------------+-----------------+------------------+------------------+
    | input_scheme     | OT_STRINGVECTOR | Custom input     | casadi::Function |
    |                  |                 | scheme           | Internal         |
    +------------------+-----------------+------------------+------------------+
    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |
    |                  |                 | when the         | Internal         |
    |                  |                 | numerical values |                  |
    |                  |                 | of the inputs    |                  |
    |                  |                 | don't make sense |                  |
    +------------------+-----------------+------------------+------------------+
    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |
    |                  |                 | for a number of  | Internal         |
    |                  |                 | forward/reverse  |                  |
    |                  |                 | directions, it   |                  |
    |                  |                 | may be cheaper   |                  |
    |                  |                 | to compute first |                  |
    |                  |                 | the full         |                  |
    |                  |                 | jacobian and     |                  |
    |                  |                 | then multiply    |                  |
    |                  |                 | with seeds,      |                  |
    |                  |                 | rather than      |                  |
    |                  |                 | obtain the       |                  |
    |                  |                 | requested        |                  |
    |                  |                 | directions in a  |                  |
    |                  |                 | straightforward  |                  |
    |                  |                 | manner. Casadi   |                  |
    |                  |                 | uses a heuristic |                  |
    |                  |                 | to decide which  |                  |
    |                  |                 | is cheaper. A    |                  |
    |                  |                 | high value of    |                  |
    |                  |                 | 'jac_penalty'    |                  |
    |                  |                 | makes it less    |                  |
    |                  |                 | likely for the   |                  |
    |                  |                 | heurstic to      |                  |
    |                  |                 | chose the full   |                  |
    |                  |                 | Jacobian         |                  |
    |                  |                 | strategy. The    |                  |
    |                  |                 | special value -1 |                  |
    |                  |                 | indicates never  |                  |
    |                  |                 | to use the full  |                  |
    |                  |                 | Jacobian         |                  |
    |                  |                 | strategy         |                  |
    +------------------+-----------------+------------------+------------------+
    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |
    |                  |                 | compiler to      | Internal         |
    |                  |                 | speed up the     |                  |
    |                  |                 | evaluation       |                  |
    +------------------+-----------------+------------------+------------------+
    | jit_options      | OT_DICT         | Options to be    | casadi::Function |
    |                  |                 | passed to the    | Internal         |
    |                  |                 | jit compiler.    |                  |
    +------------------+-----------------+------------------+------------------+
    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |
    |                  |                 | maximum number   | Internal         |
    |                  |                 | of directions    |                  |
    |                  |                 | for derivative   |                  |
    |                  |                 | functions.       |                  |
    |                  |                 | Overrules the    |                  |
    |                  |                 | builtin optimize |                  |
    |                  |                 | d_num_dir.       |                  |
    +------------------+-----------------+------------------+------------------+
    | output_scheme    | OT_STRINGVECTOR | Custom output    | casadi::Function |
    |                  |                 | scheme           | Internal         |
    +------------------+-----------------+------------------+------------------+
    | print_time       | OT_BOOL         | print            | casadi::Function |
    |                  |                 | information      | Internal         |
    |                  |                 | about execution  |                  |
    |                  |                 | time             |                  |
    +------------------+-----------------+------------------+------------------+
    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |
    |                  |                 | when NaN or Inf  | Internal         |
    |                  |                 | appears during   |                  |
    |                  |                 | evaluation       |                  |
    +------------------+-----------------+------------------+------------------+
    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |
    |                  |                 | field that can   | Internal         |
    |                  |                 | be used to       |                  |
    |                  |                 | identify the     |                  |
    |                  |                 | function or pass |                  |
    |                  |                 | additional       |                  |
    |                  |                 | information      |                  |
    +------------------+-----------------+------------------+------------------+
    | verbose          | OT_BOOL         | Verbose          | casadi::Function |
    |                  |                 | evaluation  for  | Internal         |
    |                  |                 | debugging        |                  |
    +------------------+-----------------+------------------+------------------+

    >Input scheme: casadi::ConicInput (CONIC_NUM_IN = 10)

    +--------------+--------+--------------------------------------------------+
    |  Full name   | Short  |                   Description                    |
    +==============+========+==================================================+
    | CONIC_H      | h      | The square matrix H: sparse, (n x n). Only the   |
    |              |        | lower triangular part is actually used. The      |
    |              |        | matrix is assumed to be symmetrical.             |
    +--------------+--------+--------------------------------------------------+
    | CONIC_G      | g      | The vector g: dense, (n x 1)                     |
    +--------------+--------+--------------------------------------------------+
    | CONIC_A      | a      | The matrix A: sparse, (nc x n) - product with x  |
    |              |        | must be dense.                                   |
    +--------------+--------+--------------------------------------------------+
    | CONIC_LBA    | lba    | dense, (nc x 1)                                  |
    +--------------+--------+--------------------------------------------------+
    | CONIC_UBA    | uba    | dense, (nc x 1)                                  |
    +--------------+--------+--------------------------------------------------+
    | CONIC_LBX    | lbx    | dense, (n x 1)                                   |
    +--------------+--------+--------------------------------------------------+
    | CONIC_UBX    | ubx    | dense, (n x 1)                                   |
    +--------------+--------+--------------------------------------------------+
    | CONIC_X0     | x0     | dense, (n x 1)                                   |
    +--------------+--------+--------------------------------------------------+
    | CONIC_LAM_X0 | lam_x0 | dense                                            |
    +--------------+--------+--------------------------------------------------+
    | CONIC_LAM_A0 | lam_a0 | dense                                            |
    +--------------+--------+--------------------------------------------------+

    >Output scheme: casadi::ConicOutput (CONIC_NUM_OUT = 4)

    +-------------+-------+---------------------------------------------------+
    |  Full name  | Short |                    Description                    |
    +=============+=======+===================================================+
    | CONIC_X     | x     | The primal solution.                              |
    +-------------+-------+---------------------------------------------------+
    | CONIC_COST  | cost  | The optimal cost.                                 |
    +-------------+-------+---------------------------------------------------+
    | CONIC_LAM_A | lam_a | The dual solution corresponding to linear bounds. |
    +-------------+-------+---------------------------------------------------+
    | CONIC_LAM_X | lam_x | The dual solution corresponding to simple bounds. |
    +-------------+-------+---------------------------------------------------+

    List of plugins
    ===============



    - clp

    - cplex

    - gurobi

    - hpmpc

    - ooqp

    - qpoases

    - sqic

    - nlpsol

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Conic.doc("myextraplugin")



    --------------------------------------------------------------------------------

    clp
    ---



    Interface to Clp solver for sparse Quadratic Programs

    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    cplex
    -----



    Interface to Cplex solver for sparse Quadratic Programs

    >List of available options

    +---------------+-----------+----------------------------------------------+
    |      Id       |   Type    |                 Description                  |
    +===============+===========+==============================================+
    | cplex         | OT_DICT   | Options to be passed to CPLEX                |
    +---------------+-----------+----------------------------------------------+
    | dep_check     | OT_INT    | Detect redundant constraints.                |
    +---------------+-----------+----------------------------------------------+
    | dump_filename | OT_STRING | The filename to dump to.                     |
    +---------------+-----------+----------------------------------------------+
    | dump_to_file  | OT_BOOL   | Dumps QP to file in CPLEX format.            |
    +---------------+-----------+----------------------------------------------+
    | qp_method     | OT_INT    | Determines which CPLEX algorithm to use.     |
    +---------------+-----------+----------------------------------------------+
    | tol           | OT_DOUBLE | Tolerance of solver                          |
    +---------------+-----------+----------------------------------------------+
    | warm_start    | OT_BOOL   | Use warm start with simplex methods (affects |
    |               |           | only the simplex methods).                   |
    +---------------+-----------+----------------------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    gurobi
    ------



    Interface to the GUROBI Solver for quadratic programming

    >List of available options

    +-------+-----------------+------------------------------------------------+
    |  Id   |      Type       |                  Description                   |
    +=======+=================+================================================+
    | vtype | OT_STRINGVECTOR | Type of variables:                             |
    |       |                 | [CONTINUOUS|binary|integer|semicont|semiint]   |
    +-------+-----------------+------------------------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    hpmpc
    -----



    Interface to HMPC Solver

    In order to use this interface, you must:

    Decision variables must only by state and control, and the variable ordering
    must be [x0 u0 x1 u1 ...]

    The constraints must be in order: [ gap0 lincon0 gap1 lincon1 ]

    gap: Ak+1 = Ak xk + Bk uk lincon: yk= Ck xk + Dk uk



    ::

             A0 B0 -I
             C0 D0
                    A1 B1 -I
                    C1 D1



    where I must be a diagonal sparse matrix Either supply all of N, nx, ng, nu
    options or rely on automatic detection

    >List of available options

    +----------------+--------------+------------------------------------------+
    |       Id       |     Type     |               Description                |
    +================+==============+==========================================+
    | N              | OT_INT       | OCP horizon                              |
    +----------------+--------------+------------------------------------------+
    | blasfeo_target | OT_STRING    | hpmpc target                             |
    +----------------+--------------+------------------------------------------+
    | inf            | OT_DOUBLE    | HPMPC cannot handle infinities.          |
    |                |              | Infinities will be replaced by this      |
    |                |              | option's value.                          |
    +----------------+--------------+------------------------------------------+
    | max_iter       | OT_INT       | Max number of iterations                 |
    +----------------+--------------+------------------------------------------+
    | mu0            | OT_DOUBLE    | Max element in cost function as estimate |
    |                |              | of max multiplier                        |
    +----------------+--------------+------------------------------------------+
    | ng             | OT_INTVECTOR | Number of non-dynamic constraints,       |
    |                |              | length N+1                               |
    +----------------+--------------+------------------------------------------+
    | nu             | OT_INTVECTOR | Number of controls, length N             |
    +----------------+--------------+------------------------------------------+
    | nx             | OT_INTVECTOR | Number of states, length N+1             |
    +----------------+--------------+------------------------------------------+
    | target         | OT_STRING    | hpmpc target                             |
    +----------------+--------------+------------------------------------------+
    | tol            | OT_DOUBLE    | Tolerance in the duality measure         |
    +----------------+--------------+------------------------------------------+
    | warm_start     | OT_BOOL      | Use warm-starting                        |
    +----------------+--------------+------------------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    ooqp
    ----



    Interface to the OOQP Solver for quadratic programming The current
    implementation assumes that OOQP is configured with the MA27 sparse linear
    solver.

    NOTE: when doing multiple calls to evaluate(), check if you need to
    reInit();

    >List of available options

    +-------------+-----------+------------------------------------------------+
    |     Id      |   Type    |                  Description                   |
    +=============+===========+================================================+
    | artol       | OT_DOUBLE | tolerance as provided with setArTol to OOQP    |
    +-------------+-----------+------------------------------------------------+
    | mutol       | OT_DOUBLE | tolerance as provided with setMuTol to OOQP    |
    +-------------+-----------+------------------------------------------------+
    | print_level | OT_INT    | Print level. OOQP listens to print_level 0, 10 |
    |             |           | and 100                                        |
    +-------------+-----------+------------------------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    qpoases
    -------



    Interface to QPOases Solver for quadratic programming

    >List of available options

    +-------------------------------+-----------+------------------------------+
    |              Id               |   Type    |         Description          |
    +===============================+===========+==============================+
    | CPUtime                       | OT_DOUBLE | The maximum allowed CPU time |
    |                               |           | in seconds for the whole     |
    |                               |           | initialisation (and the      |
    |                               |           | actually required one on     |
    |                               |           | output). Disabled if unset.  |
    +-------------------------------+-----------+------------------------------+
    | boundRelaxation               | OT_DOUBLE | Initial relaxation of bounds |
    |                               |           | to start homotopy and        |
    |                               |           | initial value for far        |
    |                               |           | bounds.                      |
    +-------------------------------+-----------+------------------------------+
    | boundTolerance                | OT_DOUBLE | If upper and lower bounds    |
    |                               |           | differ less than this        |
    |                               |           | tolerance, they are regarded |
    |                               |           | equal, i.e. as equality      |
    |                               |           | constraint.                  |
    +-------------------------------+-----------+------------------------------+
    | enableCholeskyRefactorisation | OT_INT    | Specifies the frequency of a |
    |                               |           | full re-factorisation of     |
    |                               |           | projected Hessian matrix: 0: |
    |                               |           | turns them off, 1: uses them |
    |                               |           | at each iteration etc.       |
    +-------------------------------+-----------+------------------------------+
    | enableDriftCorrection         | OT_INT    | Specifies the frequency of   |
    |                               |           | drift corrections: 0: turns  |
    |                               |           | them off.                    |
    +-------------------------------+-----------+------------------------------+
    | enableEqualities              | OT_BOOL   | Specifies whether equalities |
    |                               |           | should be treated as always  |
    |                               |           | active (True) or not (False) |
    +-------------------------------+-----------+------------------------------+
    | enableFarBounds               | OT_BOOL   | Enables the use of far       |
    |                               |           | bounds.                      |
    +-------------------------------+-----------+------------------------------+
    | enableFlippingBounds          | OT_BOOL   | Enables the use of flipping  |
    |                               |           | bounds.                      |
    +-------------------------------+-----------+------------------------------+
    | enableFullLITests             | OT_BOOL   | Enables condition-hardened   |
    |                               |           | (but more expensive) LI      |
    |                               |           | test.                        |
    +-------------------------------+-----------+------------------------------+
    | enableInertiaCorrection       | OT_BOOL   | Should working set be        |
    |                               |           | repaired when negative       |
    |                               |           | curvature is discovered      |
    |                               |           | during hotstart.             |
    +-------------------------------+-----------+------------------------------+
    | enableNZCTests                | OT_BOOL   | Enables nonzero curvature    |
    |                               |           | tests.                       |
    +-------------------------------+-----------+------------------------------+
    | enableRamping                 | OT_BOOL   | Enables ramping.             |
    +-------------------------------+-----------+------------------------------+
    | enableRegularisation          | OT_BOOL   | Enables automatic Hessian    |
    |                               |           | regularisation.              |
    +-------------------------------+-----------+------------------------------+
    | epsDen                        | OT_DOUBLE | Denominator tolerance for    |
    |                               |           | ratio tests.                 |
    +-------------------------------+-----------+------------------------------+
    | epsFlipping                   | OT_DOUBLE | Tolerance of squared         |
    |                               |           | Cholesky diagonal factor     |
    |                               |           | which triggers flipping      |
    |                               |           | bound.                       |
    +-------------------------------+-----------+------------------------------+
    | epsIterRef                    | OT_DOUBLE | Early termination tolerance  |
    |                               |           | for iterative refinement.    |
    +-------------------------------+-----------+------------------------------+
    | epsLITests                    | OT_DOUBLE | Tolerance for linear         |
    |                               |           | independence tests.          |
    +-------------------------------+-----------+------------------------------+
    | epsNZCTests                   | OT_DOUBLE | Tolerance for nonzero        |
    |                               |           | curvature tests.             |
    +-------------------------------+-----------+------------------------------+
    | epsNum                        | OT_DOUBLE | Numerator tolerance for      |
    |                               |           | ratio tests.                 |
    +-------------------------------+-----------+------------------------------+
    | epsRegularisation             | OT_DOUBLE | Scaling factor of identity   |
    |                               |           | matrix used for Hessian      |
    |                               |           | regularisation.              |
    +-------------------------------+-----------+------------------------------+
    | finalRamping                  | OT_DOUBLE | Final value for ramping      |
    |                               |           | strategy.                    |
    +-------------------------------+-----------+------------------------------+
    | growFarBounds                 | OT_DOUBLE | Factor to grow far bounds.   |
    +-------------------------------+-----------+------------------------------+
    | hessian_type                  | OT_STRING | Type of Hessian - see        |
    |                               |           | qpOASES documentation [UNKNO |
    |                               |           | WN|posdef|semidef|indef|zero |
    |                               |           | |identity]]                  |
    +-------------------------------+-----------+------------------------------+
    | initialFarBounds              | OT_DOUBLE | Initial size for far bounds. |
    +-------------------------------+-----------+------------------------------+
    | initialRamping                | OT_DOUBLE | Start value for ramping      |
    |                               |           | strategy.                    |
    +-------------------------------+-----------+------------------------------+
    | initialStatusBounds           | OT_STRING | Initial status of bounds at  |
    |                               |           | first iteration.             |
    +-------------------------------+-----------+------------------------------+
    | linsol_plugin                 | OT_STRING | Linear solver plugin         |
    +-------------------------------+-----------+------------------------------+
    | maxDualJump                   | OT_DOUBLE | Maximum allowed jump in dual |
    |                               |           | variables in linear          |
    |                               |           | independence tests.          |
    +-------------------------------+-----------+------------------------------+
    | maxPrimalJump                 | OT_DOUBLE | Maximum allowed jump in      |
    |                               |           | primal variables in nonzero  |
    |                               |           | curvature tests.             |
    +-------------------------------+-----------+------------------------------+
    | max_schur                     | OT_INT    | Maximal number of Schur      |
    |                               |           | updates [75]                 |
    +-------------------------------+-----------+------------------------------+
    | nWSR                          | OT_INT    | The maximum number of        |
    |                               |           | working set recalculations   |
    |                               |           | to be performed during the   |
    |                               |           | initial homotopy. Default is |
    |                               |           | 5(nx + nc)                   |
    +-------------------------------+-----------+------------------------------+
    | numRefinementSteps            | OT_INT    | Maximum number of iterative  |
    |                               |           | refinement steps.            |
    +-------------------------------+-----------+------------------------------+
    | numRegularisationSteps        | OT_INT    | Maximum number of successive |
    |                               |           | regularisation steps.        |
    +-------------------------------+-----------+------------------------------+
    | printLevel                    | OT_STRING | Defines the amount of text   |
    |                               |           | output during QP solution,   |
    |                               |           | see Section 5.7              |
    +-------------------------------+-----------+------------------------------+
    | schur                         | OT_BOOL   | Use Schur Complement         |
    |                               |           | Approach [false]             |
    +-------------------------------+-----------+------------------------------+
    | sparse                        | OT_BOOL   | Formulate the QP using       |
    |                               |           | sparse matrices. [false]     |
    +-------------------------------+-----------+------------------------------+
    | terminationTolerance          | OT_DOUBLE | Relative termination         |
    |                               |           | tolerance to stop homotopy.  |
    +-------------------------------+-----------+------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    sqic
    ----



    Interface to the SQIC solver for quadratic programming

    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    nlpsol
    ------



    Solve QPs using an Nlpsol Use the 'nlpsol' option to specify the NLP solver
    to use.

    >List of available options

    +----------------+-----------+---------------------------------+
    |       Id       |   Type    |           Description           |
    +================+===========+=================================+
    | nlpsol         | OT_STRING | Name of solver.                 |
    +----------------+-----------+---------------------------------+
    | nlpsol_options | OT_DICT   | Options to be passed to solver. |
    +----------------+-----------+---------------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson




    """
    return _casadi.conic(*args)

def qpsol(*args) -> "casadi::Function":
    """


    qpsol(str name, str solver, dict:SX qp, dict opts) -> Function
    qpsol(str name, str solver, dict:MX qp, dict opts) -> Function



    """
    return _casadi.qpsol(*args)

def conic_in(*args) -> "std::string":
    """
      Get QP solver input scheme name by index.

      conic_in() -> [str]
        Get input scheme of QP solvers.
      conic_in(int ind) -> str



    > conic_in()
    ------------------------------------------------------------------------


    Get input scheme of QP solvers.


    > conic_in(int ind)
    ------------------------------------------------------------------------


    Get QP solver input scheme name by index.




    """
    return _casadi.conic_in(*args)

def conic_out(*args) -> "std::string":
    """
      Get output scheme name by index.

      conic_out() -> [str]
        Get QP solver output scheme of QP solvers.
      conic_out(int ind) -> str



    > conic_out()
    ------------------------------------------------------------------------


    Get QP solver output scheme of QP solvers.


    > conic_out(int ind)
    ------------------------------------------------------------------------


    Get output scheme name by index.




    """
    return _casadi.conic_out(*args)

def conic_n_in(*args) -> "int":
    """
    Get the number of QP solver inputs.

    conic_n_in() -> int





    """
    return _casadi.conic_n_in(*args)

def conic_n_out(*args) -> "int":
    """
    Get the number of QP solver outputs.

    conic_n_out() -> int





    """
    return _casadi.conic_n_out(*args)

def conic_options(*args) -> "std::vector< std::string,std::allocator< std::string > >":
    """
    Get all options for a plugin.

    conic_options(str name) -> [str]





    """
    return _casadi.conic_options(*args)

def conic_option_type(*args) -> "std::string":
    """
    Get type info for a particular option.

    conic_option_type(str name, str op) -> str





    """
    return _casadi.conic_option_type(*args)

def conic_option_info(*args) -> "std::string":
    """
    Get documentation for a particular option.

    conic_option_info(str name, str op) -> str





    """
    return _casadi.conic_option_info(*args)

def has_conic(*args) -> "bool":
    """
    Check if a particular plugin is available.

    has_conic(str name) -> bool





    """
    return _casadi.has_conic(*args)

def load_conic(*args) -> "void":
    """
    Explicitly load a plugin dynamically.

    load_conic(str name)





    """
    return _casadi.load_conic(*args)

def doc_conic(*args) -> "std::string":
    """
    Get the documentation string for a plugin.

    doc_conic(str name) -> str





    """
    return _casadi.doc_conic(*args)

def nlpsol(*args) -> "casadi::Function":
    """


      nlpsol(str name, str solver, Importer compiler, dict opts) -> Function
      nlpsol(str name, str solver, NlpBuilder nl, dict opts) -> Function
      nlpsol(str name, str solver, dict:SX nlp, dict opts) -> Function
        Create an NLP solver Creates a solver for the following parametric nonlinear
      nlpsol(str name, str solver, dict:MX nlp, dict opts) -> Function
      nlpsol(str name, str solver, str fname, dict opts) -> Function

    > nlpsol(str name, str solver, dict:SX nlp, dict opts)
    ------------------------------------------------------------------------


    Create an NLP solver Creates a solver for the following parametric nonlinear
    program (NLP):

    ::

      min          F(x, p)
      x

      subject to
      LBX <=   x    <= UBX
      LBG <= G(x, p) <= UBG
      p  == P

      nx: number of decision variables
      ng: number of constraints
      np: number of parameters



    General information
    ===================



    >List of available options

    +------------------+-----------------+------------------+------------------+
    |        Id        |      Type       |   Description    |     Used in      |
    +==================+=================+==================+==================+
    | common_options   | OT_DICT         | Options for      | casadi::OracleFu |
    |                  |                 | auto-generated   | nction           |
    |                  |                 | functions        |                  |
    +------------------+-----------------+------------------+------------------+
    | discrete         | OT_BOOLVECTOR   | Indicates which  | casadi::Nlpsol   |
    |                  |                 | of the variables |                  |
    |                  |                 | are discrete,    |                  |
    |                  |                 | i.e. integer-    |                  |
    |                  |                 | valued           |                  |
    +------------------+-----------------+------------------+------------------+
    | eval_errors_fata | OT_BOOL         | When errors      | casadi::Nlpsol   |
    | l                |                 | occur during     |                  |
    |                  |                 | evaluation of    |                  |
    |                  |                 | f,g,...,stop the |                  |
    |                  |                 | iterations       |                  |
    +------------------+-----------------+------------------+------------------+
    | expand           | OT_BOOL         | Replace MX with  | casadi::Nlpsol   |
    |                  |                 | SX expressions   |                  |
    |                  |                 | in problem       |                  |
    |                  |                 | formulation      |                  |
    |                  |                 | [false]          |                  |
    +------------------+-----------------+------------------+------------------+
    | ignore_check_vec | OT_BOOL         | If set to true,  | casadi::Nlpsol   |
    |                  |                 | the input shape  |                  |
    |                  |                 | of F will not be |                  |
    |                  |                 | checked.         |                  |
    +------------------+-----------------+------------------+------------------+
    | iteration_callba | OT_FUNCTION     | A function that  | casadi::Nlpsol   |
    | ck               |                 | will be called   |                  |
    |                  |                 | at each          |                  |
    |                  |                 | iteration with   |                  |
    |                  |                 | the solver as    |                  |
    |                  |                 | input. Check     |                  |
    |                  |                 | documentation of |                  |
    |                  |                 | Callback .       |                  |
    +------------------+-----------------+------------------+------------------+
    | iteration_callba | OT_BOOL         | If set to true,  | casadi::Nlpsol   |
    | ck_ignore_errors |                 | errors thrown by |                  |
    |                  |                 | iteration_callba |                  |
    |                  |                 | ck will be       |                  |
    |                  |                 | ignored.         |                  |
    +------------------+-----------------+------------------+------------------+
    | iteration_callba | OT_INT          | Only call the    | casadi::Nlpsol   |
    | ck_step          |                 | callback         |                  |
    |                  |                 | function every   |                  |
    |                  |                 | few iterations.  |                  |
    +------------------+-----------------+------------------+------------------+
    | monitor          | OT_STRINGVECTOR | Set of user      | casadi::OracleFu |
    |                  |                 | problem          | nction           |
    |                  |                 | functions to be  |                  |
    |                  |                 | monitored        |                  |
    +------------------+-----------------+------------------+------------------+
    | specific_options | OT_DICT         | Options for      | casadi::OracleFu |
    |                  |                 | specific auto-   | nction           |
    |                  |                 | generated        |                  |
    |                  |                 | functions,       |                  |
    |                  |                 | overwriting the  |                  |
    |                  |                 | defaults from    |                  |
    |                  |                 | common_options.  |                  |
    |                  |                 | Nested           |                  |
    |                  |                 | dictionary.      |                  |
    +------------------+-----------------+------------------+------------------+
    | verbose_init     | OT_BOOL         | Print out timing | casadi::Nlpsol   |
    |                  |                 | information      |                  |
    |                  |                 | about the        |                  |
    |                  |                 | different stages |                  |
    |                  |                 | of               |                  |
    |                  |                 | initialization   |                  |
    +------------------+-----------------+------------------+------------------+
    | warn_initial_bou | OT_BOOL         | Warn if the      | casadi::Nlpsol   |
    | nds              |                 | initial guess    |                  |
    |                  |                 | does not satisfy |                  |
    |                  |                 | LBX and UBX      |                  |
    +------------------+-----------------+------------------+------------------+

    >Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)

    +---------------+--------+-------------------------------------------------+
    |   Full name   | Short  |                   Description                   |
    +===============+========+=================================================+
    | NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |
    |               |        | default -inf.                                   |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |
    |               |        | default +inf.                                   |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |
    |               |        | guess (nx x 1)                                  |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |
    |               |        | guess (ng x 1)                                  |
    +---------------+--------+-------------------------------------------------+

    >Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)

    +--------------+-------+---------------------------------------------------+
    |  Full name   | Short |                    Description                    |
    +==============+=======+===================================================+
    | NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |
    |              |       | 1)                                                |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |
    |              |       | 1)                                                |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |
    |              |       | x 1)                                              |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |
    |              |       | solution (nx x 1)                                 |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |
    |              |       | solution (ng x 1)                                 |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |
    |              |       | solution (np x 1)                                 |
    +--------------+-------+---------------------------------------------------+

    List of plugins
    ===============



    - blocksqp

    - bonmin

    - ipopt

    - knitro

    - snopt

    - worhp

    - scpgen

    - sqpmethod

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Nlpsol.doc("myextraplugin")



    --------------------------------------------------------------------------------

    blocksqp
    --------



    This is a modified version of blockSQP by Janka et al.

    Dennis Janka, Joel Andersson

    >List of available options

    +----------------------------+-----------+---------------------------------+
    |             Id             |   Type    |           Description           |
    +============================+===========+=================================+
    | block_hess                 | OT_INT    | Blockwise Hessian               |
    |                            |           | approximation?                  |
    +----------------------------+-----------+---------------------------------+
    | col_eps                    | OT_DOUBLE | Epsilon for COL scaling         |
    |                            |           | strategy                        |
    +----------------------------+-----------+---------------------------------+
    | col_tau1                   | OT_DOUBLE | tau1 for COL scaling strategy   |
    +----------------------------+-----------+---------------------------------+
    | col_tau2                   | OT_DOUBLE | tau2 for COL scaling strategy   |
    +----------------------------+-----------+---------------------------------+
    | conv_strategy              | OT_INT    | Convexification strategy        |
    +----------------------------+-----------+---------------------------------+
    | delta                      | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | delta_h0                   | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | eps                        | OT_DOUBLE | Values smaller than this are    |
    |                            |           | regarded as numerically zero    |
    +----------------------------+-----------+---------------------------------+
    | eta                        | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | fallback_scaling           | OT_INT    | If indefinite update is used,   |
    |                            |           | the type of fallback strategy   |
    +----------------------------+-----------+---------------------------------+
    | fallback_update            | OT_INT    | If indefinite update is used,   |
    |                            |           | the type of fallback strategy   |
    +----------------------------+-----------+---------------------------------+
    | gamma_f                    | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | gamma_theta                | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | globalization              | OT_BOOL   | Enable globalization            |
    +----------------------------+-----------+---------------------------------+
    | hess_damp                  | OT_INT    | Activate Powell damping for     |
    |                            |           | BFGS                            |
    +----------------------------+-----------+---------------------------------+
    | hess_damp_fac              | OT_DOUBLE | Damping factor for BFGS Powell  |
    |                            |           | modification                    |
    +----------------------------+-----------+---------------------------------+
    | hess_lim_mem               | OT_INT    | Full or limited memory          |
    +----------------------------+-----------+---------------------------------+
    | hess_memsize               | OT_INT    | Memory size for L-BFGS updates  |
    +----------------------------+-----------+---------------------------------+
    | hess_scaling               | OT_INT    | Scaling strategy for Hessian    |
    |                            |           | approximation                   |
    +----------------------------+-----------+---------------------------------+
    | hess_update                | OT_INT    | Type of Hessian approximation   |
    +----------------------------+-----------+---------------------------------+
    | ini_hess_diag              | OT_DOUBLE | Initial Hessian guess: diagonal |
    |                            |           | matrix diag(iniHessDiag)        |
    +----------------------------+-----------+---------------------------------+
    | kappa_f                    | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | kappa_minus                | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | kappa_plus                 | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | kappa_plus_max             | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | kappa_soc                  | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | linsol                     | OT_STRING | The linear solver to be used by |
    |                            |           | the QP method                   |
    +----------------------------+-----------+---------------------------------+
    | max_consec_reduced_steps   | OT_INT    | Maximum number of consecutive   |
    |                            |           | reduced steps                   |
    +----------------------------+-----------+---------------------------------+
    | max_consec_skipped_updates | OT_INT    | Maximum number of consecutive   |
    |                            |           | skipped updates                 |
    +----------------------------+-----------+---------------------------------+
    | max_conv_qp                | OT_INT    | How many additional QPs may be  |
    |                            |           | solved for convexification per  |
    |                            |           | iteration?                      |
    +----------------------------+-----------+---------------------------------+
    | max_it_qp                  | OT_INT    | Maximum number of QP iterations |
    |                            |           | per SQP iteration               |
    +----------------------------+-----------+---------------------------------+
    | max_iter                   | OT_INT    | Maximum number of SQP           |
    |                            |           | iterations                      |
    +----------------------------+-----------+---------------------------------+
    | max_line_search            | OT_INT    | Maximum number of steps in line |
    |                            |           | search                          |
    +----------------------------+-----------+---------------------------------+
    | max_soc_iter               | OT_INT    | Maximum number of SOC line      |
    |                            |           | search iterations               |
    +----------------------------+-----------+---------------------------------+
    | max_time_qp                | OT_DOUBLE | Maximum number of time in       |
    |                            |           | seconds per QP solve per SQP    |
    |                            |           | iteration                       |
    +----------------------------+-----------+---------------------------------+
    | nlinfeastol                | OT_DOUBLE | Nonlinear feasibility tolerance |
    +----------------------------+-----------+---------------------------------+
    | obj_lo                     | OT_DOUBLE | Lower bound on objective        |
    |                            |           | function [-inf]                 |
    +----------------------------+-----------+---------------------------------+
    | obj_up                     | OT_DOUBLE | Upper bound on objective        |
    |                            |           | function [inf]                  |
    +----------------------------+-----------+---------------------------------+
    | opttol                     | OT_DOUBLE | Optimality tolerance            |
    +----------------------------+-----------+---------------------------------+
    | print_header               | OT_BOOL   | Print solver header at startup  |
    +----------------------------+-----------+---------------------------------+
    | print_iteration            | OT_BOOL   | Print SQP iterations            |
    +----------------------------+-----------+---------------------------------+
    | qpsol                      | OT_STRING | The QP solver to be used by the |
    |                            |           | SQP method                      |
    +----------------------------+-----------+---------------------------------+
    | qpsol_options              | OT_DICT   | Options to be passed to the QP  |
    |                            |           | solver                          |
    +----------------------------+-----------+---------------------------------+
    | restore_feas               | OT_BOOL   | Use feasibility restoration     |
    |                            |           | phase                           |
    +----------------------------+-----------+---------------------------------+
    | s_f                        | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | s_theta                    | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | schur                      | OT_BOOL   | Use qpOASES Schur compliment    |
    |                            |           | approach                        |
    +----------------------------+-----------+---------------------------------+
    | skip_first_globalization   | OT_BOOL   | No globalization strategy in    |
    |                            |           | first iteration                 |
    +----------------------------+-----------+---------------------------------+
    | theta_max                  | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | theta_min                  | OT_DOUBLE | Filter line search parameter,   |
    |                            |           | cf. IPOPT paper                 |
    +----------------------------+-----------+---------------------------------+
    | warmstart                  | OT_BOOL   | Use warmstarting                |
    +----------------------------+-----------+---------------------------------+
    | which_second_derv          | OT_INT    | For which block should second   |
    |                            |           | derivatives be provided by the  |
    |                            |           | user                            |
    +----------------------------+-----------+---------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    bonmin
    ------



    When in warmstart mode, output NLPSOL_LAM_X may be used as input

    NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) ==
    output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will
    differ.

    For a good tutorial on BONMIN,
    seehttp://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf

    A good resource about the algorithms in BONMIN is: Wachter and L. T.
    Biegler, On the Implementation of an Interior-Point Filter Line-Search
    Algorithm for Large-Scale Nonlinear Programming, Mathematical Programming
    106(1), pp. 25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson
    Research Center, Yorktown, USA

    Caveats: with default options, multipliers for the decision variables are
    wrong for equality constraints. Change the 'fixed_variable_treatment' to
    'make_constraint' or 'relax_bounds' to obtain correct results.

    >List of available options

    +--------------------------+-------------+---------------------------------+
    |            Id            |    Type     |           Description           |
    +==========================+=============+=================================+
    | bonmin                   | OT_DICT     | Options to be passed to BONMIN  |
    +--------------------------+-------------+---------------------------------+
    | con_integer_md           | OT_DICT     | Integer metadata (a dictionary  |
    |                          |             | with lists of integers) about   |
    |                          |             | constraints to be passed to     |
    |                          |             | BONMIN                          |
    +--------------------------+-------------+---------------------------------+
    | con_numeric_md           | OT_DICT     | Numeric metadata (a dictionary  |
    |                          |             | with lists of reals) about      |
    |                          |             | constraints to be passed to     |
    |                          |             | BONMIN                          |
    +--------------------------+-------------+---------------------------------+
    | con_string_md            | OT_DICT     | String metadata (a dictionary   |
    |                          |             | with lists of strings) about    |
    |                          |             | constraints to be passed to     |
    |                          |             | BONMIN                          |
    +--------------------------+-------------+---------------------------------+
    | grad_f                   | OT_FUNCTION | Function for calculating the    |
    |                          |             | gradient of the objective       |
    |                          |             | (column, autogenerated by       |
    |                          |             | default)                        |
    +--------------------------+-------------+---------------------------------+
    | grad_f_options           | OT_DICT     | Options for the autogenerated   |
    |                          |             | gradient of the objective.      |
    +--------------------------+-------------+---------------------------------+
    | hess_lag                 | OT_FUNCTION | Function for calculating the    |
    |                          |             | Hessian of the Lagrangian       |
    |                          |             | (autogenerated by default)      |
    +--------------------------+-------------+---------------------------------+
    | hess_lag_options         | OT_DICT     | Options for the autogenerated   |
    |                          |             | Hessian of the Lagrangian.      |
    +--------------------------+-------------+---------------------------------+
    | jac_g                    | OT_FUNCTION | Function for calculating the    |
    |                          |             | Jacobian of the constraints     |
    |                          |             | (autogenerated by default)      |
    +--------------------------+-------------+---------------------------------+
    | jac_g_options            | OT_DICT     | Options for the autogenerated   |
    |                          |             | Jacobian of the constraints.    |
    +--------------------------+-------------+---------------------------------+
    | pass_nonlinear_variables | OT_BOOL     | Pass list of variables entering |
    |                          |             | nonlinearly to BONMIN           |
    +--------------------------+-------------+---------------------------------+
    | var_integer_md           | OT_DICT     | Integer metadata (a dictionary  |
    |                          |             | with lists of integers) about   |
    |                          |             | variables to be passed to       |
    |                          |             | BONMIN                          |
    +--------------------------+-------------+---------------------------------+
    | var_numeric_md           | OT_DICT     | Numeric metadata (a dictionary  |
    |                          |             | with lists of reals) about      |
    |                          |             | variables to be passed to       |
    |                          |             | BONMIN                          |
    +--------------------------+-------------+---------------------------------+
    | var_string_md            | OT_DICT     | String metadata (a dictionary   |
    |                          |             | with lists of strings) about    |
    |                          |             | variables to be passed to       |
    |                          |             | BONMIN                          |
    +--------------------------+-------------+---------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    ipopt
    -----



    When in warmstart mode, output NLPSOL_LAM_X may be used as input

    NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) ==
    output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will
    differ.

    For a good tutorial on IPOPT,
    seehttp://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf

    A good resource about the algorithms in IPOPT is: Wachter and L. T. Biegler,
    On the Implementation of an Interior-Point Filter Line-Search Algorithm for
    Large-Scale Nonlinear Programming, Mathematical Programming 106(1), pp.
    25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson Research Center,
    Yorktown, USA

    Caveats: with default options, multipliers for the decision variables are
    wrong for equality constraints. Change the 'fixed_variable_treatment' to
    'make_constraint' or 'relax_bounds' to obtain correct results.

    >List of available options

    +--------------------------+-------------+---------------------------------+
    |            Id            |    Type     |           Description           |
    +==========================+=============+=================================+
    | con_integer_md           | OT_DICT     | Integer metadata (a dictionary  |
    |                          |             | with lists of integers) about   |
    |                          |             | constraints to be passed to     |
    |                          |             | IPOPT                           |
    +--------------------------+-------------+---------------------------------+
    | con_numeric_md           | OT_DICT     | Numeric metadata (a dictionary  |
    |                          |             | with lists of reals) about      |
    |                          |             | constraints to be passed to     |
    |                          |             | IPOPT                           |
    +--------------------------+-------------+---------------------------------+
    | con_string_md            | OT_DICT     | String metadata (a dictionary   |
    |                          |             | with lists of strings) about    |
    |                          |             | constraints to be passed to     |
    |                          |             | IPOPT                           |
    +--------------------------+-------------+---------------------------------+
    | grad_f                   | OT_FUNCTION | Function for calculating the    |
    |                          |             | gradient of the objective       |
    |                          |             | (column, autogenerated by       |
    |                          |             | default)                        |
    +--------------------------+-------------+---------------------------------+
    | hess_lag                 | OT_FUNCTION | Function for calculating the    |
    |                          |             | Hessian of the Lagrangian       |
    |                          |             | (autogenerated by default)      |
    +--------------------------+-------------+---------------------------------+
    | ipopt                    | OT_DICT     | Options to be passed to IPOPT   |
    +--------------------------+-------------+---------------------------------+
    | jac_g                    | OT_FUNCTION | Function for calculating the    |
    |                          |             | Jacobian of the constraints     |
    |                          |             | (autogenerated by default)      |
    +--------------------------+-------------+---------------------------------+
    | pass_nonlinear_variables | OT_BOOL     | Pass list of variables entering |
    |                          |             | nonlinearly to IPOPT            |
    +--------------------------+-------------+---------------------------------+
    | var_integer_md           | OT_DICT     | Integer metadata (a dictionary  |
    |                          |             | with lists of integers) about   |
    |                          |             | variables to be passed to IPOPT |
    +--------------------------+-------------+---------------------------------+
    | var_numeric_md           | OT_DICT     | Numeric metadata (a dictionary  |
    |                          |             | with lists of reals) about      |
    |                          |             | variables to be passed to IPOPT |
    +--------------------------+-------------+---------------------------------+
    | var_string_md            | OT_DICT     | String metadata (a dictionary   |
    |                          |             | with lists of strings) about    |
    |                          |             | variables to be passed to IPOPT |
    +--------------------------+-------------+---------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    knitro
    ------



    KNITRO interface

    >List of available options

    +---------+--------------+--------------------------------+
    |   Id    |     Type     |          Description           |
    +=========+==============+================================+
    | contype | OT_INTVECTOR | Type of constraint             |
    +---------+--------------+--------------------------------+
    | knitro  | OT_DICT      | Options to be passed to KNITRO |
    +---------+--------------+--------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    snopt
    -----



    SNOPT interface

    >List of available options

    +-------+-----------+---------------------------------------------+
    |  Id   |   Type    |                 Description                 |
    +=======+===========+=============================================+
    | snopt | OT_DICT   | Options to be passed to SNOPT               |
    +-------+-----------+---------------------------------------------+
    | start | OT_STRING | Warm-start options for Worhp: cold|warm|hot |
    +-------+-----------+---------------------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    worhp
    -----



    WORHP interface

    Designed for Worhp 1.10

    >List of available options

    +-------+---------+-------------------------------+
    |  Id   |  Type   |          Description          |
    +=======+=========+===============================+
    | worhp | OT_DICT | Options to be passed to WORHP |
    +-------+---------+-------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    scpgen
    ------



    A structure-exploiting sequential quadratic programming (to be come
    sequential convex programming) method for nonlinear programming.

    >List of available options

    +-----------------------+-----------------+--------------------------------+
    |          Id           |      Type       |          Description           |
    +=======================+=================+================================+
    | beta                  | OT_DOUBLE       | Line-search parameter,         |
    |                       |                 | restoration factor of stepsize |
    +-----------------------+-----------------+--------------------------------+
    | c1                    | OT_DOUBLE       | Armijo condition, coefficient  |
    |                       |                 | of decrease in merit           |
    +-----------------------+-----------------+--------------------------------+
    | codegen               | OT_BOOL         | C-code generation              |
    +-----------------------+-----------------+--------------------------------+
    | hessian_approximation | OT_STRING       | gauss-newton|exact             |
    +-----------------------+-----------------+--------------------------------+
    | lbfgs_memory          | OT_INT          | Size of L-BFGS memory.         |
    +-----------------------+-----------------+--------------------------------+
    | max_iter              | OT_INT          | Maximum number of SQP          |
    |                       |                 | iterations                     |
    +-----------------------+-----------------+--------------------------------+
    | max_iter_ls           | OT_INT          | Maximum number of linesearch   |
    |                       |                 | iterations                     |
    +-----------------------+-----------------+--------------------------------+
    | merit_memsize         | OT_INT          | Size of memory to store        |
    |                       |                 | history of merit function      |
    |                       |                 | values                         |
    +-----------------------+-----------------+--------------------------------+
    | merit_start           | OT_DOUBLE       | Lower bound for the merit      |
    |                       |                 | function parameter             |
    +-----------------------+-----------------+--------------------------------+
    | name_x                | OT_STRINGVECTOR | Names of the variables.        |
    +-----------------------+-----------------+--------------------------------+
    | print_header          | OT_BOOL         | Print the header with problem  |
    |                       |                 | statistics                     |
    +-----------------------+-----------------+--------------------------------+
    | print_x               | OT_INTVECTOR    | Which variables to print.      |
    +-----------------------+-----------------+--------------------------------+
    | qpsol                 | OT_STRING       | The QP solver to be used by    |
    |                       |                 | the SQP method                 |
    +-----------------------+-----------------+--------------------------------+
    | qpsol_options         | OT_DICT         | Options to be passed to the QP |
    |                       |                 | solver                         |
    +-----------------------+-----------------+--------------------------------+
    | reg_threshold         | OT_DOUBLE       | Threshold for the              |
    |                       |                 | regularization.                |
    +-----------------------+-----------------+--------------------------------+
    | regularize            | OT_BOOL         | Automatic regularization of    |
    |                       |                 | Lagrange Hessian.              |
    +-----------------------+-----------------+--------------------------------+
    | tol_du                | OT_DOUBLE       | Stopping criterion for dual    |
    |                       |                 | infeasability                  |
    +-----------------------+-----------------+--------------------------------+
    | tol_pr                | OT_DOUBLE       | Stopping criterion for primal  |
    |                       |                 | infeasibility                  |
    +-----------------------+-----------------+--------------------------------+
    | tol_pr_step           | OT_DOUBLE       | Stopping criterion for the     |
    |                       |                 | step size                      |
    +-----------------------+-----------------+--------------------------------+
    | tol_reg               | OT_DOUBLE       | Stopping criterion for         |
    |                       |                 | regularization                 |
    +-----------------------+-----------------+--------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    sqpmethod
    ---------



    A textbook SQPMethod

    >List of available options

    +-----------------------+-----------+--------------------------------------+
    |          Id           |   Type    |             Description              |
    +=======================+===========+======================================+
    | beta                  | OT_DOUBLE | Line-search parameter, restoration   |
    |                       |           | factor of stepsize                   |
    +-----------------------+-----------+--------------------------------------+
    | c1                    | OT_DOUBLE | Armijo condition, coefficient of     |
    |                       |           | decrease in merit                    |
    +-----------------------+-----------+--------------------------------------+
    | hessian_approximation | OT_STRING | limited-memory|exact                 |
    +-----------------------+-----------+--------------------------------------+
    | lbfgs_memory          | OT_INT    | Size of L-BFGS memory.               |
    +-----------------------+-----------+--------------------------------------+
    | max_iter              | OT_INT    | Maximum number of SQP iterations     |
    +-----------------------+-----------+--------------------------------------+
    | max_iter_ls           | OT_INT    | Maximum number of linesearch         |
    |                       |           | iterations                           |
    +-----------------------+-----------+--------------------------------------+
    | merit_memory          | OT_INT    | Size of memory to store history of   |
    |                       |           | merit function values                |
    +-----------------------+-----------+--------------------------------------+
    | min_step_size         | OT_DOUBLE | The size (inf-norm) of the step size |
    |                       |           | should not become smaller than this. |
    +-----------------------+-----------+--------------------------------------+
    | print_header          | OT_BOOL   | Print the header with problem        |
    |                       |           | statistics                           |
    +-----------------------+-----------+--------------------------------------+
    | print_iteration       | OT_BOOL   | Print the iterations                 |
    +-----------------------+-----------+--------------------------------------+
    | qpsol                 | OT_STRING | The QP solver to be used by the SQP  |
    |                       |           | method                               |
    +-----------------------+-----------+--------------------------------------+
    | qpsol_options         | OT_DICT   | Options to be passed to the QP       |
    |                       |           | solver                               |
    +-----------------------+-----------+--------------------------------------+
    | regularize            | OT_BOOL   | Automatic regularization of Lagrange |
    |                       |           | Hessian.                             |
    +-----------------------+-----------+--------------------------------------+
    | tol_du                | OT_DOUBLE | Stopping criterion for dual          |
    |                       |           | infeasability                        |
    +-----------------------+-----------+--------------------------------------+
    | tol_pr                | OT_DOUBLE | Stopping criterion for primal        |
    |                       |           | infeasibility                        |
    +-----------------------+-----------+--------------------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson


    > nlpsol(str name, str solver, Importer compiler, dict opts)
    > nlpsol(str name, str solver, NlpBuilder nl, dict opts)
    > nlpsol(str name, str solver, dict:MX nlp, dict opts)
    > nlpsol(str name, str solver, str fname, dict opts)
    ------------------------------------------------------------------------





    """
    return _casadi.nlpsol(*args)

def nlpsol_in(*args) -> "std::string":
    """
      Get NLP solver input scheme name by index.

      nlpsol_in() -> [str]
        Get input scheme of NLP solvers.
      nlpsol_in(int ind) -> str


    >Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)

    +---------------+--------+-------------------------------------------------+
    |   Full name   | Short  |                   Description                   |
    +===============+========+=================================================+
    | NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |
    |               |        | default -inf.                                   |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |
    |               |        | default +inf.                                   |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |
    |               |        | guess (nx x 1)                                  |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |
    |               |        | guess (ng x 1)                                  |
    +---------------+--------+-------------------------------------------------+


    > nlpsol_in(int ind)
    ------------------------------------------------------------------------


    Get NLP solver input scheme name by index.

    >Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)

    +---------------+--------+-------------------------------------------------+
    |   Full name   | Short  |                   Description                   |
    +===============+========+=================================================+
    | NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |
    |               |        | default -inf.                                   |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |
    |               |        | default +inf.                                   |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |
    |               |        | guess (nx x 1)                                  |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |
    |               |        | guess (ng x 1)                                  |
    +---------------+--------+-------------------------------------------------+


    > nlpsol_in()
    ------------------------------------------------------------------------


    Get input scheme of NLP solvers.

    >Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)

    +---------------+--------+-------------------------------------------------+
    |   Full name   | Short  |                   Description                   |
    +===============+========+=================================================+
    | NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |
    |               |        | default -inf.                                   |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |
    |               |        | default +inf.                                   |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |
    |               |        | guess (nx x 1)                                  |
    +---------------+--------+-------------------------------------------------+
    | NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |
    |               |        | guess (ng x 1)                                  |
    +---------------+--------+-------------------------------------------------+




    """
    return _casadi.nlpsol_in(*args)

def nlpsol_out(*args) -> "std::string":
    """
      Get output scheme name by index.

      nlpsol_out() -> [str]
        Get NLP solver output scheme of NLP solvers.
      nlpsol_out(int ind) -> str


    >Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)

    +--------------+-------+---------------------------------------------------+
    |  Full name   | Short |                    Description                    |
    +==============+=======+===================================================+
    | NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |
    |              |       | 1)                                                |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |
    |              |       | 1)                                                |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |
    |              |       | x 1)                                              |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |
    |              |       | solution (nx x 1)                                 |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |
    |              |       | solution (ng x 1)                                 |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |
    |              |       | solution (np x 1)                                 |
    +--------------+-------+---------------------------------------------------+


    > nlpsol_out(int ind)
    ------------------------------------------------------------------------


    Get output scheme name by index.

    >Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)

    +--------------+-------+---------------------------------------------------+
    |  Full name   | Short |                    Description                    |
    +==============+=======+===================================================+
    | NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |
    |              |       | 1)                                                |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |
    |              |       | 1)                                                |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |
    |              |       | x 1)                                              |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |
    |              |       | solution (nx x 1)                                 |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |
    |              |       | solution (ng x 1)                                 |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |
    |              |       | solution (np x 1)                                 |
    +--------------+-------+---------------------------------------------------+


    > nlpsol_out()
    ------------------------------------------------------------------------


    Get NLP solver output scheme of NLP solvers.

    >Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)

    +--------------+-------+---------------------------------------------------+
    |  Full name   | Short |                    Description                    |
    +==============+=======+===================================================+
    | NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |
    |              |       | 1)                                                |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |
    |              |       | 1)                                                |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |
    |              |       | x 1)                                              |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |
    |              |       | solution (nx x 1)                                 |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |
    |              |       | solution (ng x 1)                                 |
    +--------------+-------+---------------------------------------------------+
    | NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |
    |              |       | solution (np x 1)                                 |
    +--------------+-------+---------------------------------------------------+




    """
    return _casadi.nlpsol_out(*args)

def nlpsol_n_in(*args) -> "int":
    """
    Number of NLP solver inputs.

    nlpsol_n_in() -> int





    """
    return _casadi.nlpsol_n_in(*args)

def nlpsol_n_out(*args) -> "int":
    """
    Number of NLP solver outputs.

    nlpsol_n_out() -> int





    """
    return _casadi.nlpsol_n_out(*args)

def nlpsol_default_in(*args) -> "std::vector< double,std::allocator< double > >":
    """
    Default input for an NLP solver.

    nlpsol_default_in() -> [float]
    nlpsol_default_in(int ind) -> float





    """
    return _casadi.nlpsol_default_in(*args)

def nlpsol_options(*args) -> "std::vector< std::string,std::allocator< std::string > >":
    """
    Get all options for a plugin.

    nlpsol_options(str name) -> [str]





    """
    return _casadi.nlpsol_options(*args)

def nlpsol_option_type(*args) -> "std::string":
    """
    Get type info for a particular option.

    nlpsol_option_type(str name, str op) -> str





    """
    return _casadi.nlpsol_option_type(*args)

def nlpsol_option_info(*args) -> "std::string":
    """
    Get documentation for a particular option.

    nlpsol_option_info(str name, str op) -> str





    """
    return _casadi.nlpsol_option_info(*args)

def has_nlpsol(*args) -> "bool":
    """
    Check if a particular plugin is available.

    has_nlpsol(str name) -> bool





    """
    return _casadi.has_nlpsol(*args)

def load_nlpsol(*args) -> "void":
    """
    Explicitly load a plugin dynamically.

    load_nlpsol(str name)





    """
    return _casadi.load_nlpsol(*args)

def doc_nlpsol(*args) -> "std::string":
    """
    Get the documentation string for a plugin.

    doc_nlpsol(str name) -> str





    """
    return _casadi.doc_nlpsol(*args)

def rootfinder(*args) -> "casadi::Function":
    """
      Create a solver for rootfinding problems Takes a function where one of the

      rootfinder(str name, str solver, Function f, dict opts) -> Function

    inputs is unknown and one of the outputs is a residual function that is
    always zero, defines a new function where the the unknown input has been
    replaced by a guess for the unknown and the residual output has been
    replaced by the calculated value for the input.

    For a function [y0, y1, ...,yi, .., yn] = F(x0, x1, ..., xj, ..., xm), where
    xj is unknown and yi=0, defines a new function [y0, y1, ...,xj, .., yn] =
    G(x0, x1, ..., xj_guess, ..., xm),

    xj and yi must have the same dimension and d(yi)/d(xj) must be invertable.

    By default, the first input is unknown and the first output is the residual.

    General information
    ===================



    >List of available options

    +------------------+-----------------+------------------+------------------+
    |        Id        |      Type       |   Description    |     Used in      |
    +==================+=================+==================+==================+
    | common_options   | OT_DICT         | Options for      | casadi::OracleFu |
    |                  |                 | auto-generated   | nction           |
    |                  |                 | functions        |                  |
    +------------------+-----------------+------------------+------------------+
    | constraints      | OT_INTVECTOR    | Constrain the    | casadi::Rootfind |
    |                  |                 | unknowns. 0      | er               |
    |                  |                 | (default): no    |                  |
    |                  |                 | constraint on    |                  |
    |                  |                 | ui, 1: ui >=     |                  |
    |                  |                 | 0.0, -1: ui <=   |                  |
    |                  |                 | 0.0, 2: ui >     |                  |
    |                  |                 | 0.0, -2: ui <    |                  |
    |                  |                 | 0.0.             |                  |
    +------------------+-----------------+------------------+------------------+
    | implicit_input   | OT_INT          | Index of the     | casadi::Rootfind |
    |                  |                 | input that       | er               |
    |                  |                 | corresponds to   |                  |
    |                  |                 | the actual root- |                  |
    |                  |                 | finding          |                  |
    +------------------+-----------------+------------------+------------------+
    | implicit_output  | OT_INT          | Index of the     | casadi::Rootfind |
    |                  |                 | output that      | er               |
    |                  |                 | corresponds to   |                  |
    |                  |                 | the actual root- |                  |
    |                  |                 | finding          |                  |
    +------------------+-----------------+------------------+------------------+
    | jacobian_functio | OT_FUNCTION     | Function object  | casadi::Rootfind |
    | n                |                 | for calculating  | er               |
    |                  |                 | the Jacobian     |                  |
    |                  |                 | (autogenerated   |                  |
    |                  |                 | by default)      |                  |
    +------------------+-----------------+------------------+------------------+
    | linear_solver    | OT_STRING       | User-defined     | casadi::Rootfind |
    |                  |                 | linear solver    | er               |
    |                  |                 | class. Needed    |                  |
    |                  |                 | for              |                  |
    |                  |                 | sensitivities.   |                  |
    +------------------+-----------------+------------------+------------------+
    | linear_solver_op | OT_DICT         | Options to be    | casadi::Rootfind |
    | tions            |                 | passed to the    | er               |
    |                  |                 | linear solver.   |                  |
    +------------------+-----------------+------------------+------------------+
    | monitor          | OT_STRINGVECTOR | Set of user      | casadi::OracleFu |
    |                  |                 | problem          | nction           |
    |                  |                 | functions to be  |                  |
    |                  |                 | monitored        |                  |
    +------------------+-----------------+------------------+------------------+
    | specific_options | OT_DICT         | Options for      | casadi::OracleFu |
    |                  |                 | specific auto-   | nction           |
    |                  |                 | generated        |                  |
    |                  |                 | functions,       |                  |
    |                  |                 | overwriting the  |                  |
    |                  |                 | defaults from    |                  |
    |                  |                 | common_options.  |                  |
    |                  |                 | Nested           |                  |
    |                  |                 | dictionary.      |                  |
    +------------------+-----------------+------------------+------------------+

    List of plugins
    ===============



    - kinsol

    - nlpsol

    - newton

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Rootfinder.doc("myextraplugin")



    --------------------------------------------------------------------------------

    kinsol
    ------



    KINSOL interface from the Sundials suite

    >List of available options

    +---------------------------+-----------------+----------------------------+
    |            Id             |      Type       |        Description         |
    +===========================+=================+============================+
    | abstol                    | OT_DOUBLE       | Stopping criterion         |
    |                           |                 | tolerance                  |
    +---------------------------+-----------------+----------------------------+
    | disable_internal_warnings | OT_BOOL         | Disable KINSOL internal    |
    |                           |                 | warning messages           |
    +---------------------------+-----------------+----------------------------+
    | exact_jacobian            | OT_BOOL         | Use exact Jacobian         |
    |                           |                 | information                |
    +---------------------------+-----------------+----------------------------+
    | f_scale                   | OT_DOUBLEVECTOR | Equation scaling factors   |
    +---------------------------+-----------------+----------------------------+
    | iterative_solver          | OT_STRING       | gmres|bcgstab|tfqmr        |
    +---------------------------+-----------------+----------------------------+
    | linear_solver_type        | OT_STRING       | dense|banded|iterative|use |
    |                           |                 | r_defined                  |
    +---------------------------+-----------------+----------------------------+
    | lower_bandwidth           | OT_INT          | Lower bandwidth for banded |
    |                           |                 | linear solvers             |
    +---------------------------+-----------------+----------------------------+
    | max_iter                  | OT_INT          | Maximum number of Newton   |
    |                           |                 | iterations. Putting 0 sets |
    |                           |                 | the default value of       |
    |                           |                 | KinSol.                    |
    +---------------------------+-----------------+----------------------------+
    | max_krylov                | OT_INT          | Maximum Krylov space       |
    |                           |                 | dimension                  |
    +---------------------------+-----------------+----------------------------+
    | pretype                   | OT_STRING       | Type of preconditioner     |
    +---------------------------+-----------------+----------------------------+
    | strategy                  | OT_STRING       | Globalization strategy     |
    +---------------------------+-----------------+----------------------------+
    | u_scale                   | OT_DOUBLEVECTOR | Variable scaling factors   |
    +---------------------------+-----------------+----------------------------+
    | upper_bandwidth           | OT_INT          | Upper bandwidth for banded |
    |                           |                 | linear solvers             |
    +---------------------------+-----------------+----------------------------+
    | use_preconditioner        | OT_BOOL         | Precondition an iterative  |
    |                           |                 | solver                     |
    +---------------------------+-----------------+----------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    nlpsol
    ------





    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    newton
    ------



    Implements simple newton iterations to solve an implicit function.

    >List of available options

    +-----------------+-----------+--------------------------------------------+
    |       Id        |   Type    |                Description                 |
    +=================+===========+============================================+
    | abstol          | OT_DOUBLE | Stopping criterion tolerance on max(|F|)   |
    +-----------------+-----------+--------------------------------------------+
    | abstolStep      | OT_DOUBLE | Stopping criterion tolerance on step size  |
    +-----------------+-----------+--------------------------------------------+
    | max_iter        | OT_INT    | Maximum number of Newton iterations to     |
    |                 |           | perform before returning.                  |
    +-----------------+-----------+--------------------------------------------+
    | print_iteration | OT_BOOL   | Print information about each iteration     |
    +-----------------+-----------+--------------------------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson




    """
    return _casadi.rootfinder(*args)

def has_rootfinder(*args) -> "bool":
    """
    Check if a particular plugin is available.

    has_rootfinder(str name) -> bool





    """
    return _casadi.has_rootfinder(*args)

def load_rootfinder(*args) -> "void":
    """
    Explicitly load a plugin dynamically.

    load_rootfinder(str name)





    """
    return _casadi.load_rootfinder(*args)

def doc_rootfinder(*args) -> "std::string":
    """
    Get the documentation string for a plugin.

    doc_rootfinder(str name) -> str





    """
    return _casadi.doc_rootfinder(*args)
class Linsol(SharedObject):
    """
      Linear solver Create a solver for linear systems of equations Solves the


    linear system A*X = B or A^T*X = B for X with A square and non- singular.

    If A is structurally singular, an error will be thrown during init. If A is
    numerically singular, the prepare step will fail.

    General information
    ===================



    List of plugins
    ===============



    - csparsecholesky

    - csparse

    - ma27

    - lapacklu

    - lapackqr

    - symbolicqr

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Linsol.doc("myextraplugin")



    --------------------------------------------------------------------------------

    csparsecholesky
    ---------------



    Linsol with CSparseCholesky Interface

    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    csparse
    -------



    Linsol with CSparse Interface

    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    ma27
    ----



    Interface to the sparse direct linear solver MA27 Works for symmetric
    indefinite systems Partly adopted from qpOASES 3.2 Joel Andersson

    --------------------------------------------------------------------------------

    lapacklu
    --------



    This class solves the linear system A.x=b by making an LU factorization of
    A: A = L.U, with L lower and U upper triangular

    >List of available options

    +-----------------------------+---------+----------------------------------+
    |             Id              |  Type   |           Description            |
    +=============================+=========+==================================+
    | allow_equilibration_failure | OT_BOOL | Non-fatal error when             |
    |                             |         | equilibration fails              |
    +-----------------------------+---------+----------------------------------+
    | equilibration               | OT_BOOL | Equilibrate the matrix           |
    +-----------------------------+---------+----------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    lapackqr
    --------



    This class solves the linear system A.x=b by making an QR factorization of
    A: A = Q.R, with Q orthogonal and R upper triangular

    >List of available options

    +----------+--------+------------------------------------------------------+
    |    Id    |  Type  |                     Description                      |
    +==========+========+======================================================+
    | max_nrhs | OT_INT | Maximum number of right-hand-sides that get          |
    |          |        | processed in a single pass [default:10].             |
    +----------+--------+------------------------------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    symbolicqr
    ----------



    Linear solver for sparse least-squares problems Inspired
    fromhttps://github.com/scipy/scipy/blob/v0.14.0/scipy/sparse/linalg/isolve/lsqr.py#L96

    Linsol based on QR factorization with sparsity pattern based reordering
    without partial pivoting

    >List of available options

    +----------+-----------+---------------------------------------------------+
    |    Id    |   Type    |                    Description                    |
    +==========+===========+===================================================+
    | codegen  | OT_BOOL   | C-code generation                                 |
    +----------+-----------+---------------------------------------------------+
    | compiler | OT_STRING | Compiler command to be used for compiling         |
    |          |           | generated code                                    |
    +----------+-----------+---------------------------------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: linsol.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Linsol, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Linsol, name)
    __repr__ = _swig_repr

    def test_cast(*args) -> "bool":
        """


        test_cast(casadi::SharedObjectInternal const * ptr) -> bool



        """
        return _casadi.Linsol_test_cast(*args)

    test_cast = staticmethod(test_cast)

    def has_plugin(*args) -> "bool":
        """


        has_plugin(str name) -> bool



        """
        return _casadi.Linsol_has_plugin(*args)

    has_plugin = staticmethod(has_plugin)

    def load_plugin(*args) -> "void":
        """


        load_plugin(str name)



        """
        return _casadi.Linsol_load_plugin(*args)

    load_plugin = staticmethod(load_plugin)

    def doc(*args) -> "std::string":
        """


        doc(str name) -> str



        """
        return _casadi.Linsol_doc(*args)

    doc = staticmethod(doc)

    def plugin_name(self, *args) -> "std::string":
        """
        Query plugin name.

        plugin_name(self) -> str





        """
        return _casadi.Linsol_plugin_name(self, *args)


    def solve(self, *args) -> "casadi::MX":
        """
          Create a solve node.

          solve(self, DM A, DM B, bool tr) -> DM
            Solve numerically.
          solve(self, MX A, MX B, bool tr) -> MX



        > solve(self, MX A, MX B, bool tr)
        ------------------------------------------------------------------------


        Create a solve node.


        > solve(self, DM A, DM B, bool tr)
        ------------------------------------------------------------------------


        Solve numerically.




        """
        return _casadi.Linsol_solve(self, *args)


    def cholesky_sparsity(self, *args) -> "casadi::Sparsity":
        """
        Obtain a symbolic Cholesky factorization Only for Cholesky solvers.

        cholesky_sparsity(self, bool tr) -> Sparsity





        """
        return _casadi.Linsol_cholesky_sparsity(self, *args)


    def cholesky(self, *args) -> "casadi::DM":
        """
        Obtain a numeric Cholesky factorization Only for Cholesky solvers.

        cholesky(self, bool tr) -> DM





        """
        return _casadi.Linsol_cholesky(self, *args)


    def neig(self, *args) -> "int":
        """
        Number of negative eigenvalues Not available for all solvers.

        neig(self) -> int





        """
        return _casadi.Linsol_neig(self, *args)


    def rank(self, *args) -> "int":
        """
        Matrix rank Not available for all solvers.

        rank(self) -> int





        """
        return _casadi.Linsol_rank(self, *args)


    def __init__(self, *args):
        """


          Linsol()
            Default constructor.
          Linsol(Linsol other)
          Linsol(str name, str solver, dict opts)
            Importer factory.

        > Linsol(Linsol other)
        ------------------------------------------------------------------------

        > Linsol(str name, str solver, dict opts)
        ------------------------------------------------------------------------


        Importer factory.


        > Linsol()
        ------------------------------------------------------------------------


        Default constructor.




        """
        this = _casadi.new_Linsol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_Linsol
Linsol_swigregister = _casadi.Linsol_swigregister
Linsol_swigregister(Linsol)

def Linsol_test_cast(*args) -> "bool":
    """


    test_cast(casadi::SharedObjectInternal const * ptr) -> bool



    """
    return _casadi.Linsol_test_cast(*args)

def Linsol_has_plugin(*args) -> "bool":
    """


    has_plugin(str name) -> bool



    """
    return _casadi.Linsol_has_plugin(*args)

def Linsol_load_plugin(*args) -> "void":
    """


    load_plugin(str name)



    """
    return _casadi.Linsol_load_plugin(*args)

def Linsol_doc(*args) -> "std::string":
    """


    doc(str name) -> str



    """
    return _casadi.Linsol_doc(*args)


def has_linsol(*args) -> "bool":
    """
    Check if a particular plugin is available.

    has_linsol(str name) -> bool





    """
    return _casadi.has_linsol(*args)

def load_linsol(*args) -> "void":
    """
    Explicitly load a plugin dynamically.

    load_linsol(str name)





    """
    return _casadi.load_linsol(*args)

def doc_linsol(*args) -> "std::string":
    """
    Get the documentation string for a plugin.

    doc_linsol(str name) -> str





    """
    return _casadi.doc_linsol(*args)

def dplesol(*args) -> "casadi::DMVector":
    """


      dplesol([DM] A, [DM] V, str solver, dict opts) -> [DM]
      dplesol(MX A, MX V, str solver, dict opts) -> MX
      dplesol([MX] A, [MX] V, str solver, dict opts) -> [MX]
      dplesol(str name, str solver, dict:Sparsity qp, dict opts) -> Function
        Discrete periodic Lyapunov Equation solver Given matrices $A_k$ and

    > dplesol([DM] A, [DM] V, str solver, dict opts)
    > dplesol(MX A, MX V, str solver, dict opts)
    > dplesol([MX] A, [MX] V, str solver, dict opts)
    ------------------------------------------------------------------------



    > dplesol(str name, str solver, dict:Sparsity qp, dict opts)
    ------------------------------------------------------------------------


    Discrete periodic Lyapunov Equation solver Given matrices $A_k$ and
    symmetric $V_k, k = 0..K-1$

    ::

      A_k in R^(n x n)
      V_k in R^n


    provides all of $P_k$ that satisfy:

    ::

      P_0 = A_(K-1)*P_(K-1)*A_(K-1)' + V_k
      P_k+1 = A_k*P_k*A_k' + V_k  for k = 1..K-1




    General information
    ===================



    >List of available options

    +------------------+-----------------+------------------+------------------+
    |        Id        |      Type       |   Description    |     Used in      |
    +==================+=================+==================+==================+
    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |
    |                  |                 | for derivative   | Internal         |
    |                  |                 | calculation.When |                  |
    |                  |                 | there is an      |                  |
    |                  |                 | option of either |                  |
    |                  |                 | using forward or |                  |
    |                  |                 | reverse mode     |                  |
    |                  |                 | directional      |                  |
    |                  |                 | derivatives, the |                  |
    |                  |                 | condition ad_wei |                  |
    |                  |                 | ght*nf<=(1-ad_we |                  |
    |                  |                 | ight)*na is used |                  |
    |                  |                 | where nf and na  |                  |
    |                  |                 | are estimates of |                  |
    |                  |                 | the number of    |                  |
    |                  |                 | forward/reverse  |                  |
    |                  |                 | mode directional |                  |
    |                  |                 | derivatives      |                  |
    |                  |                 | needed. By       |                  |
    |                  |                 | default,         |                  |
    |                  |                 | ad_weight is     |                  |
    |                  |                 | calculated       |                  |
    |                  |                 | automatically,   |                  |
    |                  |                 | but this can be  |                  |
    |                  |                 | overridden by    |                  |
    |                  |                 | setting this     |                  |
    |                  |                 | option. In       |                  |
    |                  |                 | particular, 0    |                  |
    |                  |                 | means forcing    |                  |
    |                  |                 | forward mode and |                  |
    |                  |                 | 1 forcing        |                  |
    |                  |                 | reverse mode.    |                  |
    |                  |                 | Leave unset for  |                  |
    |                  |                 | (class specific) |                  |
    |                  |                 | heuristics.      |                  |
    +------------------+-----------------+------------------+------------------+
    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |
    |                  |                 | for sparsity     | Internal         |
    |                  |                 | pattern          |                  |
    |                  |                 | calculation calc |                  |
    |                  |                 | ulation.Override |                  |
    |                  |                 | s default        |                  |
    |                  |                 | behavior. Set to |                  |
    |                  |                 | 0 and 1 to force |                  |
    |                  |                 | forward and      |                  |
    |                  |                 | reverse mode     |                  |
    |                  |                 | respectively.    |                  |
    |                  |                 | Cf. option       |                  |
    |                  |                 | "ad_weight".     |                  |
    +------------------+-----------------+------------------+------------------+
    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |
    |                  |                 | compiler plugin  | Internal         |
    |                  |                 | to be used.      |                  |
    +------------------+-----------------+------------------+------------------+
    | const_dim        | OT_BOOL         | Assume constant  | casadi::Dple     |
    |                  |                 | dimension of P   |                  |
    +------------------+-----------------+------------------+------------------+
    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |
    |                  |                 | a derivative of  | Internal         |
    |                  |                 | another          |                  |
    |                  |                 | function. The    |                  |
    |                  |                 | type of          |                  |
    |                  |                 | derivative       |                  |
    |                  |                 | (directional     |                  |
    |                  |                 | derivative,      |                  |
    |                  |                 | Jacobian) is     |                  |
    |                  |                 | inferred from    |                  |
    |                  |                 | the function     |                  |
    |                  |                 | name.            |                  |
    +------------------+-----------------+------------------+------------------+
    | eps_unstable     | OT_DOUBLE       | A margin for     | casadi::Dple     |
    |                  |                 | unstability      |                  |
    |                  |                 | detection        |                  |
    +------------------+-----------------+------------------+------------------+
    | error_unstable   | OT_BOOL         | Throw an         | casadi::Dple     |
    |                  |                 | exception when   |                  |
    |                  |                 | it is detected   |                  |
    |                  |                 | that             |                  |
    |                  |                 | Product(A_i,     |                  |
    |                  |                 | i=N..1)has       |                  |
    |                  |                 | eigenvalues      |                  |
    |                  |                 | greater than     |                  |
    |                  |                 | 1-eps_unstable   |                  |
    +------------------+-----------------+------------------+------------------+
    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |
    |                  |                 | option           | Internal         |
    |                  |                 | (ignored):       |                  |
    |                  |                 | Statistics are   |                  |
    |                  |                 | now always       |                  |
    |                  |                 | collected.       |                  |
    +------------------+-----------------+------------------+------------------+
    | input_scheme     | OT_STRINGVECTOR | Custom input     | casadi::Function |
    |                  |                 | scheme           | Internal         |
    +------------------+-----------------+------------------+------------------+
    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |
    |                  |                 | when the         | Internal         |
    |                  |                 | numerical values |                  |
    |                  |                 | of the inputs    |                  |
    |                  |                 | don't make sense |                  |
    +------------------+-----------------+------------------+------------------+
    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |
    |                  |                 | for a number of  | Internal         |
    |                  |                 | forward/reverse  |                  |
    |                  |                 | directions, it   |                  |
    |                  |                 | may be cheaper   |                  |
    |                  |                 | to compute first |                  |
    |                  |                 | the full         |                  |
    |                  |                 | jacobian and     |                  |
    |                  |                 | then multiply    |                  |
    |                  |                 | with seeds,      |                  |
    |                  |                 | rather than      |                  |
    |                  |                 | obtain the       |                  |
    |                  |                 | requested        |                  |
    |                  |                 | directions in a  |                  |
    |                  |                 | straightforward  |                  |
    |                  |                 | manner. Casadi   |                  |
    |                  |                 | uses a heuristic |                  |
    |                  |                 | to decide which  |                  |
    |                  |                 | is cheaper. A    |                  |
    |                  |                 | high value of    |                  |
    |                  |                 | 'jac_penalty'    |                  |
    |                  |                 | makes it less    |                  |
    |                  |                 | likely for the   |                  |
    |                  |                 | heurstic to      |                  |
    |                  |                 | chose the full   |                  |
    |                  |                 | Jacobian         |                  |
    |                  |                 | strategy. The    |                  |
    |                  |                 | special value -1 |                  |
    |                  |                 | indicates never  |                  |
    |                  |                 | to use the full  |                  |
    |                  |                 | Jacobian         |                  |
    |                  |                 | strategy         |                  |
    +------------------+-----------------+------------------+------------------+
    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |
    |                  |                 | compiler to      | Internal         |
    |                  |                 | speed up the     |                  |
    |                  |                 | evaluation       |                  |
    +------------------+-----------------+------------------+------------------+
    | jit_options      | OT_DICT         | Options to be    | casadi::Function |
    |                  |                 | passed to the    | Internal         |
    |                  |                 | jit compiler.    |                  |
    +------------------+-----------------+------------------+------------------+
    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |
    |                  |                 | maximum number   | Internal         |
    |                  |                 | of directions    |                  |
    |                  |                 | for derivative   |                  |
    |                  |                 | functions.       |                  |
    |                  |                 | Overrules the    |                  |
    |                  |                 | builtin optimize |                  |
    |                  |                 | d_num_dir.       |                  |
    +------------------+-----------------+------------------+------------------+
    | output_scheme    | OT_STRINGVECTOR | Custom output    | casadi::Function |
    |                  |                 | scheme           | Internal         |
    +------------------+-----------------+------------------+------------------+
    | pos_def          | OT_BOOL         | Assume P         | casadi::Dple     |
    |                  |                 | positive         |                  |
    |                  |                 | definite         |                  |
    +------------------+-----------------+------------------+------------------+
    | print_time       | OT_BOOL         | print            | casadi::Function |
    |                  |                 | information      | Internal         |
    |                  |                 | about execution  |                  |
    |                  |                 | time             |                  |
    +------------------+-----------------+------------------+------------------+
    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |
    |                  |                 | when NaN or Inf  | Internal         |
    |                  |                 | appears during   |                  |
    |                  |                 | evaluation       |                  |
    +------------------+-----------------+------------------+------------------+
    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |
    |                  |                 | field that can   | Internal         |
    |                  |                 | be used to       |                  |
    |                  |                 | identify the     |                  |
    |                  |                 | function or pass |                  |
    |                  |                 | additional       |                  |
    |                  |                 | information      |                  |
    +------------------+-----------------+------------------+------------------+
    | verbose          | OT_BOOL         | Verbose          | casadi::Function |
    |                  |                 | evaluation  for  | Internal         |
    |                  |                 | debugging        |                  |
    +------------------+-----------------+------------------+------------------+

    >Input scheme: casadi::DpleInput (DPLE_NUM_IN = 2)

    +-----------+-------+------------------------------------------------------+
    | Full name | Short |                     Description                      |
    +===========+=======+======================================================+
    | DPLE_A    | a     | A matrices (horzcat when const_dim, diagcat          |
    |           |       | otherwise) [a].                                      |
    +-----------+-------+------------------------------------------------------+
    | DPLE_V    | v     | V matrices (horzcat when const_dim, diagcat          |
    |           |       | otherwise) [v].                                      |
    +-----------+-------+------------------------------------------------------+

    >Output scheme: casadi::DpleOutput (DPLE_NUM_OUT = 1)

    +-----------+-------+------------------------------------------------------+
    | Full name | Short |                     Description                      |
    +===========+=======+======================================================+
    | DPLE_P    | p     | Lyapunov matrix (horzcat when const_dim, diagcat     |
    |           |       | otherwise) (Cholesky of P if pos_def) [p].           |
    +-----------+-------+------------------------------------------------------+

    List of plugins
    ===============



    - slicot

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Dple.doc("myextraplugin")



    --------------------------------------------------------------------------------

    slicot
    ------



    An efficient solver for Discrete Periodic Lyapunov Equations using SLICOT

    Uses Periodic Schur Decomposition ('psd') and does not assume positive
    definiteness. Based on Periodic Lyapunov equations: some applications and
    new algorithms. Int. J. Control, vol. 67, pp. 69-87, 1997.

    Overview of the method: J. Gillis Practical Methods for Approximate Robust
    Periodic Optimal Control ofNonlinear Mechanical Systems, PhD Thesis,
    KULeuven, 2015

    >List of available options

    +-----------------------+-----------+--------------------------------------+
    |          Id           |   Type    |             Description              |
    +=======================+===========+======================================+
    | linear_solver         | OT_STRING | User-defined linear solver class.    |
    |                       |           | Needed for sensitivities.            |
    +-----------------------+-----------+--------------------------------------+
    | linear_solver_options | OT_DICT   | Options to be passed to the linear   |
    |                       |           | solver.                              |
    +-----------------------+-----------+--------------------------------------+
    | psd_num_zero          | OT_DOUBLE | Numerical zero used in Periodic      |
    |                       |           | Schur decomposition with slicot.This |
    |                       |           | option is needed when your systems   |
    |                       |           | has Floquet multiplierszero or close |
    |                       |           | to zero                              |
    +-----------------------+-----------+--------------------------------------+

    --------------------------------------------------------------------------------



    Joris Gillis




    """
    return _casadi.dplesol(*args)

def dple_in(*args) -> "std::string":
    """
      Get DPLE input scheme name by index.

      dple_in() -> [str]
        Get input scheme of DPLE solvers.
      dple_in(int ind) -> str



    > dple_in()
    ------------------------------------------------------------------------


    Get input scheme of DPLE solvers.


    > dple_in(int ind)
    ------------------------------------------------------------------------


    Get DPLE input scheme name by index.




    """
    return _casadi.dple_in(*args)

def dple_out(*args) -> "std::string":
    """
      Get DPLE output scheme name by index.

      dple_out() -> [str]
        Get output scheme of DPLE solvers.
      dple_out(int ind) -> str



    > dple_out()
    ------------------------------------------------------------------------


    Get output scheme of DPLE solvers.


    > dple_out(int ind)
    ------------------------------------------------------------------------


    Get DPLE output scheme name by index.




    """
    return _casadi.dple_out(*args)

def dple_n_in(*args) -> "int":
    """
    Get the number of QP solver inputs.

    dple_n_in() -> int





    """
    return _casadi.dple_n_in(*args)

def dple_n_out(*args) -> "int":
    """
    Get the number of QP solver outputs.

    dple_n_out() -> int





    """
    return _casadi.dple_n_out(*args)

def has_dple(*args) -> "bool":
    """
    Check if a particular plugin is available.

    has_dple(str name) -> bool





    """
    return _casadi.has_dple(*args)

def load_dple(*args) -> "void":
    """
    Explicitly load a plugin dynamically.

    load_dple(str name)





    """
    return _casadi.load_dple(*args)

def doc_dple(*args) -> "std::string":
    """
    Get the documentation string for a plugin.

    doc_dple(str name) -> str





    """
    return _casadi.doc_dple(*args)

def expmsol(*args) -> "casadi::Function":
    """
      Performs a matrix exponentiation expm(A)

      expmsol(str name, str solver, Sparsity A, dict opts) -> Function


    General information
    ===================



    >List of available options

    +------------------+-----------------+------------------+------------------+
    |        Id        |      Type       |   Description    |     Used in      |
    +==================+=================+==================+==================+
    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |
    |                  |                 | for derivative   | Internal         |
    |                  |                 | calculation.When |                  |
    |                  |                 | there is an      |                  |
    |                  |                 | option of either |                  |
    |                  |                 | using forward or |                  |
    |                  |                 | reverse mode     |                  |
    |                  |                 | directional      |                  |
    |                  |                 | derivatives, the |                  |
    |                  |                 | condition ad_wei |                  |
    |                  |                 | ght*nf<=(1-ad_we |                  |
    |                  |                 | ight)*na is used |                  |
    |                  |                 | where nf and na  |                  |
    |                  |                 | are estimates of |                  |
    |                  |                 | the number of    |                  |
    |                  |                 | forward/reverse  |                  |
    |                  |                 | mode directional |                  |
    |                  |                 | derivatives      |                  |
    |                  |                 | needed. By       |                  |
    |                  |                 | default,         |                  |
    |                  |                 | ad_weight is     |                  |
    |                  |                 | calculated       |                  |
    |                  |                 | automatically,   |                  |
    |                  |                 | but this can be  |                  |
    |                  |                 | overridden by    |                  |
    |                  |                 | setting this     |                  |
    |                  |                 | option. In       |                  |
    |                  |                 | particular, 0    |                  |
    |                  |                 | means forcing    |                  |
    |                  |                 | forward mode and |                  |
    |                  |                 | 1 forcing        |                  |
    |                  |                 | reverse mode.    |                  |
    |                  |                 | Leave unset for  |                  |
    |                  |                 | (class specific) |                  |
    |                  |                 | heuristics.      |                  |
    +------------------+-----------------+------------------+------------------+
    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |
    |                  |                 | for sparsity     | Internal         |
    |                  |                 | pattern          |                  |
    |                  |                 | calculation calc |                  |
    |                  |                 | ulation.Override |                  |
    |                  |                 | s default        |                  |
    |                  |                 | behavior. Set to |                  |
    |                  |                 | 0 and 1 to force |                  |
    |                  |                 | forward and      |                  |
    |                  |                 | reverse mode     |                  |
    |                  |                 | respectively.    |                  |
    |                  |                 | Cf. option       |                  |
    |                  |                 | "ad_weight".     |                  |
    +------------------+-----------------+------------------+------------------+
    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |
    |                  |                 | compiler plugin  | Internal         |
    |                  |                 | to be used.      |                  |
    +------------------+-----------------+------------------+------------------+
    | const_A          | OT_BOOL         | Assume A is      | casadi::Expm     |
    |                  |                 | constant.        |                  |
    |                  |                 | Default: false.  |                  |
    +------------------+-----------------+------------------+------------------+
    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |
    |                  |                 | a derivative of  | Internal         |
    |                  |                 | another          |                  |
    |                  |                 | function. The    |                  |
    |                  |                 | type of          |                  |
    |                  |                 | derivative       |                  |
    |                  |                 | (directional     |                  |
    |                  |                 | derivative,      |                  |
    |                  |                 | Jacobian) is     |                  |
    |                  |                 | inferred from    |                  |
    |                  |                 | the function     |                  |
    |                  |                 | name.            |                  |
    +------------------+-----------------+------------------+------------------+
    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |
    |                  |                 | option           | Internal         |
    |                  |                 | (ignored):       |                  |
    |                  |                 | Statistics are   |                  |
    |                  |                 | now always       |                  |
    |                  |                 | collected.       |                  |
    +------------------+-----------------+------------------+------------------+
    | input_scheme     | OT_STRINGVECTOR | Custom input     | casadi::Function |
    |                  |                 | scheme           | Internal         |
    +------------------+-----------------+------------------+------------------+
    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |
    |                  |                 | when the         | Internal         |
    |                  |                 | numerical values |                  |
    |                  |                 | of the inputs    |                  |
    |                  |                 | don't make sense |                  |
    +------------------+-----------------+------------------+------------------+
    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |
    |                  |                 | for a number of  | Internal         |
    |                  |                 | forward/reverse  |                  |
    |                  |                 | directions, it   |                  |
    |                  |                 | may be cheaper   |                  |
    |                  |                 | to compute first |                  |
    |                  |                 | the full         |                  |
    |                  |                 | jacobian and     |                  |
    |                  |                 | then multiply    |                  |
    |                  |                 | with seeds,      |                  |
    |                  |                 | rather than      |                  |
    |                  |                 | obtain the       |                  |
    |                  |                 | requested        |                  |
    |                  |                 | directions in a  |                  |
    |                  |                 | straightforward  |                  |
    |                  |                 | manner. Casadi   |                  |
    |                  |                 | uses a heuristic |                  |
    |                  |                 | to decide which  |                  |
    |                  |                 | is cheaper. A    |                  |
    |                  |                 | high value of    |                  |
    |                  |                 | 'jac_penalty'    |                  |
    |                  |                 | makes it less    |                  |
    |                  |                 | likely for the   |                  |
    |                  |                 | heurstic to      |                  |
    |                  |                 | chose the full   |                  |
    |                  |                 | Jacobian         |                  |
    |                  |                 | strategy. The    |                  |
    |                  |                 | special value -1 |                  |
    |                  |                 | indicates never  |                  |
    |                  |                 | to use the full  |                  |
    |                  |                 | Jacobian         |                  |
    |                  |                 | strategy         |                  |
    +------------------+-----------------+------------------+------------------+
    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |
    |                  |                 | compiler to      | Internal         |
    |                  |                 | speed up the     |                  |
    |                  |                 | evaluation       |                  |
    +------------------+-----------------+------------------+------------------+
    | jit_options      | OT_DICT         | Options to be    | casadi::Function |
    |                  |                 | passed to the    | Internal         |
    |                  |                 | jit compiler.    |                  |
    +------------------+-----------------+------------------+------------------+
    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |
    |                  |                 | maximum number   | Internal         |
    |                  |                 | of directions    |                  |
    |                  |                 | for derivative   |                  |
    |                  |                 | functions.       |                  |
    |                  |                 | Overrules the    |                  |
    |                  |                 | builtin optimize |                  |
    |                  |                 | d_num_dir.       |                  |
    +------------------+-----------------+------------------+------------------+
    | output_scheme    | OT_STRINGVECTOR | Custom output    | casadi::Function |
    |                  |                 | scheme           | Internal         |
    +------------------+-----------------+------------------+------------------+
    | print_time       | OT_BOOL         | print            | casadi::Function |
    |                  |                 | information      | Internal         |
    |                  |                 | about execution  |                  |
    |                  |                 | time             |                  |
    +------------------+-----------------+------------------+------------------+
    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |
    |                  |                 | when NaN or Inf  | Internal         |
    |                  |                 | appears during   |                  |
    |                  |                 | evaluation       |                  |
    +------------------+-----------------+------------------+------------------+
    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |
    |                  |                 | field that can   | Internal         |
    |                  |                 | be used to       |                  |
    |                  |                 | identify the     |                  |
    |                  |                 | function or pass |                  |
    |                  |                 | additional       |                  |
    |                  |                 | information      |                  |
    +------------------+-----------------+------------------+------------------+
    | verbose          | OT_BOOL         | Verbose          | casadi::Function |
    |                  |                 | evaluation  for  | Internal         |
    |                  |                 | debugging        |                  |
    +------------------+-----------------+------------------+------------------+

    List of plugins
    ===============



    - slicot

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Expm.doc("myextraplugin")



    --------------------------------------------------------------------------------

    slicot
    ------





    --------------------------------------------------------------------------------



    Joris Gillis




    """
    return _casadi.expmsol(*args)

def expm_n_in(*args) -> "int":
    """
    Get the number of expm solver inputs.

    expm_n_in() -> int





    """
    return _casadi.expm_n_in(*args)

def expm_n_out(*args) -> "int":
    """
    Get the number of expm solver outputs.

    expm_n_out() -> int





    """
    return _casadi.expm_n_out(*args)

def has_expm(*args) -> "bool":
    """
    Check if a particular plugin is available.

    has_expm(str name) -> bool





    """
    return _casadi.has_expm(*args)

def load_expm(*args) -> "void":
    """
    Explicitly load a plugin dynamically.

    load_expm(str name)





    """
    return _casadi.load_expm(*args)

def doc_expm(*args) -> "std::string":
    """
    Get the documentation string for a plugin.

    doc_expm(str name) -> str





    """
    return _casadi.doc_expm(*args)

def interpolant(*args) -> "casadi::Function":
    """
      An interpolant function for lookup table data

      interpolant(str name, str solver, [[float]] grid, [float] values, dict opts) -> Function


    General information
    ===================



    List of plugins
    ===============



    - bspline

    - linear

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Interpolant.doc("myextraplugin")



    --------------------------------------------------------------------------------

    bspline
    -------



    >List of available options

    +---------------+--------------+-------------------------------------------+
    |      Id       |     Type     |                Description                |
    +===============+==============+===========================================+
    | degree        | OT_INTVECTOR | Sets, for each grid dimenion, the degree  |
    |               |              | of the spline.                            |
    +---------------+--------------+-------------------------------------------+
    | linear_solver | OT_STRING    | Solver used for constructing the          |
    |               |              | coefficient tensor.                       |
    +---------------+--------------+-------------------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    linear
    ------



    >List of available options

    +-------------+-----------------+------------------------------------------+
    |     Id      |      Type       |               Description                |
    +=============+=================+==========================================+
    | lookup_mode | OT_STRINGVECTOR | Sets, for each grid dimenion, the lookup |
    |             |                 | algorithm used to find the correct       |
    |             |                 | index. 'linear' uses a for-loop + break; |
    |             |                 | 'exact' uses floored division (only for  |
    |             |                 | uniform grids).                          |
    +-------------+-----------------+------------------------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson




    """
    return _casadi.interpolant(*args)

def has_interpolant(*args) -> "bool":
    """
    Check if a particular plugin is available.

    has_interpolant(str name) -> bool





    """
    return _casadi.has_interpolant(*args)

def load_interpolant(*args) -> "void":
    """
    Explicitly load a plugin dynamically.

    load_interpolant(str name)





    """
    return _casadi.load_interpolant(*args)

def doc_interpolant(*args) -> "std::string":
    """
    Get the documentation string for a plugin.

    doc_interpolant(str name) -> str





    """
    return _casadi.doc_interpolant(*args)
class CodeGenerator(_object):
    """
      Helper class for C code generation.



    Joel Andersson

    C++ includes: code_generator.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CodeGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CodeGenerator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor.

        CodeGenerator(str name, dict opts)





        """
        this = _casadi.new_CodeGenerator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def add(self, *args) -> "void":
        """
        Add a function (name generated)

        add(self, Function f)





        """
        return _casadi.CodeGenerator_add(self, *args)


    def dump(self, *args) -> "std::string":
        """
        Generate a file, return code as string.

        dump(self) -> str





        """
        return _casadi.CodeGenerator_dump(self, *args)


    def generate(self, *args) -> "std::string":
        """
          Generate file(s) The "prefix" argument will be prepended to the generated

          generate(self, str prefix) -> str

        files and may be a directory or a file prefix. returns the filename.




        """
        return _casadi.CodeGenerator_generate(self, *args)


    def addInclude(self, *args) -> "void":
        """
          Add an include file optionally using a relative path "..." instead of an

          addInclude(self, str new_include, bool relative_path, str use_ifdef)

        absolute path <...>




        """
        return _casadi.CodeGenerator_addInclude(self, *args)

    __swig_destroy__ = _casadi.delete_CodeGenerator
CodeGenerator_swigregister = _casadi.CodeGenerator_swigregister
CodeGenerator_swigregister(CodeGenerator)

FLAG = _casadi.FLAG

def _horzcat(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    _horzcat([Sparsity] v) -> Sparsity
    _horzcat([IM] v) -> IM
    _horzcat([DM] v) -> DM
    _horzcat([SX] v) -> SX
    _horzcat([MX] v) -> MX



    """
    return _casadi._horzcat(*args)

def _vertcat(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    _vertcat([Sparsity] v) -> Sparsity
    _vertcat([IM] v) -> IM
    _vertcat([DM] v) -> DM
    _vertcat([SX] v) -> SX
    _vertcat([MX] v) -> MX



    """
    return _casadi._vertcat(*args)

def horzsplit(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
    """


    horzsplit(Sparsity v, int incr) -> [Sparsity]
    horzsplit(IM v, int incr) -> [IM]
    horzsplit(DM v, int incr) -> [DM]
    horzsplit(SX v, int incr) -> [SX]
    horzsplit(MX v, int incr) -> [MX]
    horzsplit(Sparsity v, [int] offset) -> [Sparsity]
    horzsplit(IM v, [int] offset) -> [IM]
    horzsplit(DM v, [int] offset) -> [DM]
    horzsplit(SX v, [int] offset) -> [SX]
    horzsplit(MX v, [int] offset) -> [MX]



    """
    return _casadi.horzsplit(*args)

def offset(*args) -> "std::vector< int,std::allocator< int > >":
    """


    offset([Sparsity] v, bool vert) -> [int]
    offset([IM] v, bool vert) -> [int]
    offset([DM] v, bool vert) -> [int]
    offset([SX] v, bool vert) -> [int]
    offset([MX] v, bool vert) -> [int]



    """
    return _casadi.offset(*args)

def vertsplit(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
    """


    vertsplit(Sparsity v, int incr) -> [Sparsity]
    vertsplit(IM v, int incr) -> [IM]
    vertsplit(DM v, int incr) -> [DM]
    vertsplit(SX v, int incr) -> [SX]
    vertsplit(MX v, int incr) -> [MX]
    vertsplit(Sparsity v, [int] offset) -> [Sparsity]
    vertsplit(IM v, [int] offset) -> [IM]
    vertsplit(DM v, [int] offset) -> [DM]
    vertsplit(SX v, [int] offset) -> [SX]
    vertsplit(MX v, [int] offset) -> [MX]



    """
    return _casadi.vertsplit(*args)

def blockcat(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    blockcat([[Sparsity]] v) -> Sparsity
    blockcat([IM]] v) -> IM
    blockcat([[DM]] v) -> DM
    blockcat([SX]] v) -> SX
    blockcat([[MX]] v) -> MX
    blockcat(Sparsity A, Sparsity B, Sparsity C, Sparsity D) -> Sparsity
    blockcat(IM A, IM B, IM C, IM D) -> IM
    blockcat(DM A, DM B, DM C, DM D) -> DM
    blockcat(SX A, SX B, SX C, SX D) -> SX
    blockcat(MX A, MX B, MX C, MX D) -> MX



    """
    return _casadi.blockcat(*args)

def blocksplit(*args) -> "std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >":
    """


    blocksplit(Sparsity x, int vert_incr, int horz_incr) -> [[Sparsity]]
    blocksplit(IM x, int vert_incr, int horz_incr) -> [IM]]
    blocksplit(DM x, int vert_incr, int horz_incr) -> [[DM]]
    blocksplit(SX x, int vert_incr, int horz_incr) -> [SX]]
    blocksplit(MX x, int vert_incr, int horz_incr) -> [[MX]]
    blocksplit(Sparsity x, [int] vert_offset, [int] horz_offset) -> [[Sparsity]]
    blocksplit(IM x, [int] vert_offset, [int] horz_offset) -> [IM]]
    blocksplit(DM x, [int] vert_offset, [int] horz_offset) -> [[DM]]
    blocksplit(SX x, [int] vert_offset, [int] horz_offset) -> [SX]]
    blocksplit(MX x, [int] vert_offset, [int] horz_offset) -> [[MX]]



    """
    return _casadi.blocksplit(*args)

def _diagcat(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    _diagcat([Sparsity] A) -> Sparsity
    _diagcat([IM] A) -> IM
    _diagcat([DM] A) -> DM
    _diagcat([SX] A) -> SX
    _diagcat([MX] A) -> MX



    """
    return _casadi._diagcat(*args)

def diagsplit(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
    """


    diagsplit(Sparsity x, int incr) -> [Sparsity]
    diagsplit(IM x, int incr) -> [IM]
    diagsplit(DM x, int incr) -> [DM]
    diagsplit(SX x, int incr) -> [SX]
    diagsplit(MX x, int incr) -> [MX]
    diagsplit(Sparsity x, [int] output_offset) -> [Sparsity]
    diagsplit(IM x, [int] output_offset) -> [IM]
    diagsplit(DM x, [int] output_offset) -> [DM]
    diagsplit(SX x, [int] output_offset) -> [SX]
    diagsplit(MX x, [int] output_offset) -> [MX]
    diagsplit(Sparsity x, int incr1, int incr2) -> [Sparsity]
    diagsplit(Sparsity x, [int] output_offset1, [int] output_offset2) -> [Sparsity]
    diagsplit(IM x, int incr1, int incr2) -> [IM]
    diagsplit(IM x, [int] output_offset1, [int] output_offset2) -> [IM]
    diagsplit(DM x, int incr1, int incr2) -> [DM]
    diagsplit(DM x, [int] output_offset1, [int] output_offset2) -> [DM]
    diagsplit(SX x, int incr1, int incr2) -> [SX]
    diagsplit(SX x, [int] output_offset1, [int] output_offset2) -> [SX]
    diagsplit(MX x, int incr1, int incr2) -> [MX]
    diagsplit(MX x, [int] output_offset1, [int] output_offset2) -> [MX]



    """
    return _casadi.diagsplit(*args)

def _veccat(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    _veccat([Sparsity] x) -> Sparsity
    _veccat([IM] x) -> IM
    _veccat([DM] x) -> DM
    _veccat([SX] x) -> SX
    _veccat([MX] x) -> MX



    """
    return _casadi._veccat(*args)

def mtimes(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    mtimes([Sparsity] args) -> Sparsity
    mtimes([IM] args) -> IM
    mtimes([DM] args) -> DM
    mtimes([SX] args) -> SX
    mtimes([MX] args) -> MX
    mtimes(Sparsity x, Sparsity y) -> Sparsity
    mtimes(IM x, IM y) -> IM
    mtimes(DM x, DM y) -> DM
    mtimes(SX x, SX y) -> SX
    mtimes(MX x, MX y) -> MX



    """
    return _casadi.mtimes(*args)

def mac(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    mac(Sparsity X, Sparsity Y, Sparsity Z) -> Sparsity
    mac(IM X, IM Y, IM Z) -> IM
    mac(DM X, DM Y, DM Z) -> DM
    mac(SX X, SX Y, SX Z) -> SX
    mac(MX X, MX Y, MX Z) -> MX



    """
    return _casadi.mac(*args)

def transpose(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    transpose(Sparsity X) -> Sparsity
    transpose(IM X) -> IM
    transpose(DM X) -> DM
    transpose(SX X) -> SX
    transpose(MX X) -> MX



    """
    return _casadi.transpose(*args)

def vec(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    vec(Sparsity a) -> Sparsity
    vec(IM a) -> IM
    vec(DM a) -> DM
    vec(SX a) -> SX
    vec(MX a) -> MX



    """
    return _casadi.vec(*args)

def reshape(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    reshape(Sparsity a, (int,int) rc) -> Sparsity
    reshape(Sparsity a, Sparsity sp) -> Sparsity
    reshape(IM a, (int,int) rc) -> IM
    reshape(IM a, Sparsity sp) -> IM
    reshape(DM a, (int,int) rc) -> DM
    reshape(DM a, Sparsity sp) -> DM
    reshape(SX a, (int,int) rc) -> SX
    reshape(SX a, Sparsity sp) -> SX
    reshape(MX a, (int,int) rc) -> MX
    reshape(MX a, Sparsity sp) -> MX
    reshape(Sparsity a, int nrow, int ncol) -> Sparsity
    reshape(IM a, int nrow, int ncol) -> IM
    reshape(DM a, int nrow, int ncol) -> DM
    reshape(SX a, int nrow, int ncol) -> SX
    reshape(MX a, int nrow, int ncol) -> MX



    """
    return _casadi.reshape(*args)

def sprank(*args) -> "int":
    """


    sprank(Sparsity A) -> int
    sprank(IM A) -> int
    sprank(DM A) -> int
    sprank(SX A) -> int
    sprank(MX A) -> int



    """
    return _casadi.sprank(*args)

def norm_0_mul(*args) -> "int":
    """


    norm_0_mul(Sparsity x, Sparsity y) -> int
    norm_0_mul(IM x, IM y) -> int
    norm_0_mul(DM x, DM y) -> int
    norm_0_mul(SX x, SX y) -> int
    norm_0_mul(MX x, MX y) -> int



    """
    return _casadi.norm_0_mul(*args)

def triu(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    triu(Sparsity a, bool includeDiagonal) -> Sparsity
    triu(IM a, bool includeDiagonal) -> IM
    triu(DM a, bool includeDiagonal) -> DM
    triu(SX a, bool includeDiagonal) -> SX
    triu(MX a, bool includeDiagonal) -> MX



    """
    return _casadi.triu(*args)

def tril(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    tril(Sparsity a, bool includeDiagonal) -> Sparsity
    tril(IM a, bool includeDiagonal) -> IM
    tril(DM a, bool includeDiagonal) -> DM
    tril(SX a, bool includeDiagonal) -> SX
    tril(MX a, bool includeDiagonal) -> MX



    """
    return _casadi.tril(*args)

def kron(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    kron(Sparsity a, Sparsity b) -> Sparsity
    kron(IM a, IM b) -> IM
    kron(DM a, DM b) -> DM
    kron(SX a, SX b) -> SX
    kron(MX a, MX b) -> MX



    """
    return _casadi.kron(*args)

def repmat(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    repmat(Sparsity A, int n, int m) -> Sparsity
    repmat(Sparsity A, (int,int) rc) -> Sparsity
    repmat(IM A, int n, int m) -> IM
    repmat(IM A, (int,int) rc) -> IM
    repmat(DM A, int n, int m) -> DM
    repmat(DM A, (int,int) rc) -> DM
    repmat(SX A, int n, int m) -> SX
    repmat(SX A, (int,int) rc) -> SX
    repmat(MX A, int n, int m) -> MX
    repmat(MX A, (int,int) rc) -> MX



    """
    return _casadi.repmat(*args)

def plus(*args) -> "double":
    """


    plus(float x, float y) -> float
    plus(IM x, IM y) -> IM
    plus(DM x, DM y) -> DM
    plus(SX x, SX y) -> SX
    plus(MX x, MX y) -> MX



    """
    return _casadi.plus(*args)

def minus(*args) -> "double":
    """


    minus(float x, float y) -> float
    minus(IM x, IM y) -> IM
    minus(DM x, DM y) -> DM
    minus(SX x, SX y) -> SX
    minus(MX x, MX y) -> MX



    """
    return _casadi.minus(*args)

def times(*args) -> "double":
    """


    times(float x, float y) -> float
    times(IM x, IM y) -> IM
    times(DM x, DM y) -> DM
    times(SX x, SX y) -> SX
    times(MX x, MX y) -> MX



    """
    return _casadi.times(*args)

def rdivide(*args) -> "double":
    """


    rdivide(float x, float y) -> float
    rdivide(IM x, IM y) -> IM
    rdivide(DM x, DM y) -> DM
    rdivide(SX x, SX y) -> SX
    rdivide(MX x, MX y) -> MX



    """
    return _casadi.rdivide(*args)

def ldivide(*args) -> "double":
    """


    ldivide(float x, float y) -> float
    ldivide(IM x, IM y) -> IM
    ldivide(DM x, DM y) -> DM
    ldivide(SX x, SX y) -> SX
    ldivide(MX x, MX y) -> MX



    """
    return _casadi.ldivide(*args)

def lt(*args) -> "double":
    """


    lt(float x, float y) -> float
    lt(IM x, IM y) -> IM
    lt(DM x, DM y) -> DM
    lt(SX x, SX y) -> SX
    lt(MX x, MX y) -> MX



    """
    return _casadi.lt(*args)

def le(*args) -> "double":
    """


    le(float x, float y) -> float
    le(IM x, IM y) -> IM
    le(DM x, DM y) -> DM
    le(SX x, SX y) -> SX
    le(MX x, MX y) -> MX



    """
    return _casadi.le(*args)

def gt(*args) -> "double":
    """


    gt(float x, float y) -> float
    gt(IM x, IM y) -> IM
    gt(DM x, DM y) -> DM
    gt(SX x, SX y) -> SX
    gt(MX x, MX y) -> MX



    """
    return _casadi.gt(*args)

def ge(*args) -> "double":
    """


    ge(float x, float y) -> float
    ge(IM x, IM y) -> IM
    ge(DM x, DM y) -> DM
    ge(SX x, SX y) -> SX
    ge(MX x, MX y) -> MX



    """
    return _casadi.ge(*args)

def eq(*args) -> "double":
    """


    eq(float x, float y) -> float
    eq(IM x, IM y) -> IM
    eq(DM x, DM y) -> DM
    eq(SX x, SX y) -> SX
    eq(MX x, MX y) -> MX



    """
    return _casadi.eq(*args)

def ne(*args) -> "double":
    """


    ne(float x, float y) -> float
    ne(IM x, IM y) -> IM
    ne(DM x, DM y) -> DM
    ne(SX x, SX y) -> SX
    ne(MX x, MX y) -> MX



    """
    return _casadi.ne(*args)

def logic_and(*args) -> "double":
    """


    logic_and(float x, float y) -> float
    logic_and(IM x, IM y) -> IM
    logic_and(DM x, DM y) -> DM
    logic_and(SX x, SX y) -> SX
    logic_and(MX x, MX y) -> MX



    """
    return _casadi.logic_and(*args)

def logic_or(*args) -> "double":
    """


    logic_or(float x, float y) -> float
    logic_or(IM x, IM y) -> IM
    logic_or(DM x, DM y) -> DM
    logic_or(SX x, SX y) -> SX
    logic_or(MX x, MX y) -> MX



    """
    return _casadi.logic_or(*args)

def logic_not(*args) -> "double":
    """


    logic_not(float x) -> float
    logic_not(IM x) -> IM
    logic_not(DM x) -> DM
    logic_not(SX x) -> SX
    logic_not(MX x) -> MX



    """
    return _casadi.logic_not(*args)

def fabs(*args) -> "double":
    """


    fabs(float x) -> float
    fabs(IM x) -> IM
    fabs(DM x) -> DM
    fabs(SX x) -> SX
    fabs(MX x) -> MX



    """
    return _casadi.fabs(*args)

def sqrt(*args) -> "double":
    """


    sqrt(float x) -> float
    sqrt(IM x) -> IM
    sqrt(DM x) -> DM
    sqrt(SX x) -> SX
    sqrt(MX x) -> MX



    """
    return _casadi.sqrt(*args)

def sin(*args) -> "double":
    """


    sin(float x) -> float
    sin(IM x) -> IM
    sin(DM x) -> DM
    sin(SX x) -> SX
    sin(MX x) -> MX



    """
    return _casadi.sin(*args)

def cos(*args) -> "double":
    """


    cos(float x) -> float
    cos(IM x) -> IM
    cos(DM x) -> DM
    cos(SX x) -> SX
    cos(MX x) -> MX



    """
    return _casadi.cos(*args)

def tan(*args) -> "double":
    """


    tan(float x) -> float
    tan(IM x) -> IM
    tan(DM x) -> DM
    tan(SX x) -> SX
    tan(MX x) -> MX



    """
    return _casadi.tan(*args)

def atan(*args) -> "double":
    """


    atan(float x) -> float
    atan(IM x) -> IM
    atan(DM x) -> DM
    atan(SX x) -> SX
    atan(MX x) -> MX



    """
    return _casadi.atan(*args)

def asin(*args) -> "double":
    """


    asin(float x) -> float
    asin(IM x) -> IM
    asin(DM x) -> DM
    asin(SX x) -> SX
    asin(MX x) -> MX



    """
    return _casadi.asin(*args)

def acos(*args) -> "double":
    """


    acos(float x) -> float
    acos(IM x) -> IM
    acos(DM x) -> DM
    acos(SX x) -> SX
    acos(MX x) -> MX



    """
    return _casadi.acos(*args)

def tanh(*args) -> "double":
    """


    tanh(float x) -> float
    tanh(IM x) -> IM
    tanh(DM x) -> DM
    tanh(SX x) -> SX
    tanh(MX x) -> MX



    """
    return _casadi.tanh(*args)

def sinh(*args) -> "double":
    """


    sinh(float x) -> float
    sinh(IM x) -> IM
    sinh(DM x) -> DM
    sinh(SX x) -> SX
    sinh(MX x) -> MX



    """
    return _casadi.sinh(*args)

def cosh(*args) -> "double":
    """


    cosh(float x) -> float
    cosh(IM x) -> IM
    cosh(DM x) -> DM
    cosh(SX x) -> SX
    cosh(MX x) -> MX



    """
    return _casadi.cosh(*args)

def atanh(*args) -> "double":
    """


    atanh(float x) -> float
    atanh(IM x) -> IM
    atanh(DM x) -> DM
    atanh(SX x) -> SX
    atanh(MX x) -> MX



    """
    return _casadi.atanh(*args)

def asinh(*args) -> "double":
    """


    asinh(float x) -> float
    asinh(IM x) -> IM
    asinh(DM x) -> DM
    asinh(SX x) -> SX
    asinh(MX x) -> MX



    """
    return _casadi.asinh(*args)

def acosh(*args) -> "double":
    """


    acosh(float x) -> float
    acosh(IM x) -> IM
    acosh(DM x) -> DM
    acosh(SX x) -> SX
    acosh(MX x) -> MX



    """
    return _casadi.acosh(*args)

def exp(*args) -> "double":
    """


    exp(float x) -> float
    exp(IM x) -> IM
    exp(DM x) -> DM
    exp(SX x) -> SX
    exp(MX x) -> MX



    """
    return _casadi.exp(*args)

def log(*args) -> "double":
    """


    log(float x) -> float
    log(IM x) -> IM
    log(DM x) -> DM
    log(SX x) -> SX
    log(MX x) -> MX



    """
    return _casadi.log(*args)

def log10(*args) -> "double":
    """


    log10(float x) -> float
    log10(IM x) -> IM
    log10(DM x) -> DM
    log10(SX x) -> SX
    log10(MX x) -> MX



    """
    return _casadi.log10(*args)

def floor(*args) -> "double":
    """


    floor(float x) -> float
    floor(IM x) -> IM
    floor(DM x) -> DM
    floor(SX x) -> SX
    floor(MX x) -> MX



    """
    return _casadi.floor(*args)

def ceil(*args) -> "double":
    """


    ceil(float x) -> float
    ceil(IM x) -> IM
    ceil(DM x) -> DM
    ceil(SX x) -> SX
    ceil(MX x) -> MX



    """
    return _casadi.ceil(*args)

def erf(*args) -> "double":
    """


    erf(float x) -> float
    erf(IM x) -> IM
    erf(DM x) -> DM
    erf(SX x) -> SX
    erf(MX x) -> MX



    """
    return _casadi.erf(*args)

def erfinv(*args) -> "double":
    """


    erfinv(float x) -> float
    erfinv(IM x) -> IM
    erfinv(DM x) -> DM
    erfinv(SX x) -> SX
    erfinv(MX x) -> MX



    """
    return _casadi.erfinv(*args)

def sign(*args) -> "double":
    """


    sign(float x) -> float
    sign(IM x) -> IM
    sign(DM x) -> DM
    sign(SX x) -> SX
    sign(MX x) -> MX



    """
    return _casadi.sign(*args)

def power(*args) -> "double":
    """


    power(float x, float n) -> float
    power(IM x, IM n) -> IM
    power(DM x, DM n) -> DM
    power(SX x, SX n) -> SX
    power(MX x, MX n) -> MX



    """
    return _casadi.power(*args)

def mod(*args) -> "double":
    """


    mod(float x, float y) -> float
    mod(IM x, IM y) -> IM
    mod(DM x, DM y) -> DM
    mod(SX x, SX y) -> SX
    mod(MX x, MX y) -> MX



    """
    return _casadi.mod(*args)

def atan2(*args) -> "double":
    """


    atan2(float x, float y) -> float
    atan2(IM x, IM y) -> IM
    atan2(DM x, DM y) -> DM
    atan2(SX x, SX y) -> SX
    atan2(MX x, MX y) -> MX



    """
    return _casadi.atan2(*args)

def fmin(*args) -> "double":
    """


    fmin(float x, float y) -> float
    fmin(IM x, IM y) -> IM
    fmin(DM x, DM y) -> DM
    fmin(SX x, SX y) -> SX
    fmin(MX x, MX y) -> MX



    """
    return _casadi.fmin(*args)

def fmax(*args) -> "double":
    """


    fmax(float x, float y) -> float
    fmax(IM x, IM y) -> IM
    fmax(DM x, DM y) -> DM
    fmax(SX x, SX y) -> SX
    fmax(MX x, MX y) -> MX



    """
    return _casadi.fmax(*args)

def simplify(*args) -> "double":
    """


    simplify(float x) -> float
    simplify(IM x) -> IM
    simplify(DM x) -> DM
    simplify(SX x) -> SX
    simplify(MX x) -> MX



    """
    return _casadi.simplify(*args)

def is_equal(*args) -> "bool":
    """


    is_equal(float x, float y, int depth) -> bool
    is_equal(IM x, IM y, int depth) -> bool
    is_equal(DM x, DM y, int depth) -> bool
    is_equal(SX x, SX y, int depth) -> bool
    is_equal(MX x, MX y, int depth) -> bool



    """
    return _casadi.is_equal(*args)

def copysign(*args) -> "double":
    """


    copysign(float x, float y) -> float
    copysign(IM x, IM y) -> IM
    copysign(DM x, DM y) -> DM
    copysign(SX x, SX y) -> SX
    copysign(MX x, MX y) -> MX



    """
    return _casadi.copysign(*args)

def constpow(*args) -> "double":
    """


    constpow(float x, float y) -> float
    constpow(IM x, IM y) -> IM
    constpow(DM x, DM y) -> DM
    constpow(SX x, SX y) -> SX
    constpow(MX x, MX y) -> MX



    """
    return _casadi.constpow(*args)

def mpower(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    mpower(IM x, IM n) -> IM
    mpower(DM x, DM n) -> DM
    mpower(SX x, SX n) -> SX
    mpower(MX x, MX n) -> MX



    """
    return _casadi.mpower(*args)

def mrdivide(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    mrdivide(IM x, IM y) -> IM
    mrdivide(DM x, DM y) -> DM
    mrdivide(SX x, SX y) -> SX
    mrdivide(MX x, MX y) -> MX



    """
    return _casadi.mrdivide(*args)

def mldivide(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    mldivide(IM x, IM y) -> IM
    mldivide(DM x, DM y) -> DM
    mldivide(SX x, SX y) -> SX
    mldivide(MX x, MX y) -> MX



    """
    return _casadi.mldivide(*args)

def symvar(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
    """


    symvar(IM x) -> [IM]
    symvar(DM x) -> [DM]
    symvar(SX x) -> [SX]
    symvar(MX x) -> [MX]



    """
    return _casadi.symvar(*args)

def bilin(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    bilin(IM A, IM x, IM y) -> IM
    bilin(DM A, DM x, DM y) -> DM
    bilin(SX A, SX x, SX y) -> SX
    bilin(MX A, MX x, MX y) -> MX



    """
    return _casadi.bilin(*args)

def rank1(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    rank1(IM A, IM alpha, IM x, IM y) -> IM
    rank1(DM A, DM alpha, DM x, DM y) -> DM
    rank1(SX A, SX alpha, SX x, SX y) -> SX
    rank1(MX A, MX alpha, MX x, MX y) -> MX



    """
    return _casadi.rank1(*args)

def sum_square(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    sum_square(IM X) -> IM
    sum_square(DM X) -> DM
    sum_square(SX X) -> SX
    sum_square(MX X) -> MX



    """
    return _casadi.sum_square(*args)

def linspace(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    linspace(IM a, IM b, int nsteps) -> IM
    linspace(DM a, DM b, int nsteps) -> DM
    linspace(SX a, SX b, int nsteps) -> SX
    linspace(MX a, MX b, int nsteps) -> MX



    """
    return _casadi.linspace(*args)

def interp1d(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    interp1d([float] x, IM v, [float] xq, str mode, bool equidistant) -> IM
    interp1d([float] x, DM v, [float] xq, str mode, bool equidistant) -> DM
    interp1d([float] x, SX v, [float] xq, str mode, bool equidistant) -> SX
    interp1d([float] x, MX v, [float] xq, str mode, bool equidistant) -> MX



    """
    return _casadi.interp1d(*args)

def cross(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    cross(IM a, IM b, int dim) -> IM
    cross(DM a, DM b, int dim) -> DM
    cross(SX a, SX b, int dim) -> SX
    cross(MX a, MX b, int dim) -> MX



    """
    return _casadi.cross(*args)

def skew(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    skew(IM a) -> IM
    skew(DM a) -> DM
    skew(SX a) -> SX
    skew(MX a) -> MX



    """
    return _casadi.skew(*args)

def inv_skew(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    inv_skew(IM a) -> IM
    inv_skew(DM a) -> DM
    inv_skew(SX a) -> SX
    inv_skew(MX a) -> MX



    """
    return _casadi.inv_skew(*args)

def det(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    det(IM A) -> IM
    det(DM A) -> DM
    det(SX A) -> SX
    det(MX A) -> MX



    """
    return _casadi.det(*args)

def inv_minor(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    inv_minor(IM A) -> IM
    inv_minor(DM A) -> DM
    inv_minor(SX A) -> SX
    inv_minor(MX A) -> MX



    """
    return _casadi.inv_minor(*args)

def inv(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    inv(IM A) -> IM
    inv(DM A) -> DM
    inv(SX A) -> SX
    inv(MX A) -> MX
    inv(IM A, str lsolver, dict opts) -> IM
    inv(DM A, str lsolver, dict opts) -> DM
    inv(SX A, str lsolver, dict opts) -> SX
    inv(MX A, str lsolver, dict opts) -> MX



    """
    return _casadi.inv(*args)

def trace(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    trace(IM a) -> IM
    trace(DM a) -> DM
    trace(SX a) -> SX
    trace(MX a) -> MX



    """
    return _casadi.trace(*args)

def tril2symm(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    tril2symm(IM a) -> IM
    tril2symm(DM a) -> DM
    tril2symm(SX a) -> SX
    tril2symm(MX a) -> MX



    """
    return _casadi.tril2symm(*args)

def triu2symm(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    triu2symm(IM a) -> IM
    triu2symm(DM a) -> DM
    triu2symm(SX a) -> SX
    triu2symm(MX a) -> MX



    """
    return _casadi.triu2symm(*args)

def norm_fro(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    norm_fro(IM x) -> IM
    norm_fro(DM x) -> DM
    norm_fro(SX x) -> SX
    norm_fro(MX x) -> MX



    """
    return _casadi.norm_fro(*args)

def norm_2(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    norm_2(IM x) -> IM
    norm_2(DM x) -> DM
    norm_2(SX x) -> SX
    norm_2(MX x) -> MX



    """
    return _casadi.norm_2(*args)

def norm_1(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    norm_1(IM x) -> IM
    norm_1(DM x) -> DM
    norm_1(SX x) -> SX
    norm_1(MX x) -> MX



    """
    return _casadi.norm_1(*args)

def norm_inf(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    norm_inf(IM x) -> IM
    norm_inf(DM x) -> DM
    norm_inf(SX x) -> SX
    norm_inf(MX x) -> MX



    """
    return _casadi.norm_inf(*args)

def sum2(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    sum2(IM x) -> IM
    sum2(DM x) -> DM
    sum2(SX x) -> SX
    sum2(MX x) -> MX



    """
    return _casadi.sum2(*args)

def sum1(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    sum1(IM x) -> IM
    sum1(DM x) -> DM
    sum1(SX x) -> SX
    sum1(MX x) -> MX



    """
    return _casadi.sum1(*args)

def dot(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    dot(IM x, IM y) -> IM
    dot(DM x, DM y) -> DM
    dot(SX x, SX y) -> SX
    dot(MX x, MX y) -> MX



    """
    return _casadi.dot(*args)

def nullspace(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    nullspace(IM A) -> IM
    nullspace(DM A) -> DM
    nullspace(SX A) -> SX
    nullspace(MX A) -> MX



    """
    return _casadi.nullspace(*args)

def polyval(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    polyval(IM p, IM x) -> IM
    polyval(DM p, DM x) -> DM
    polyval(SX p, SX x) -> SX
    polyval(MX p, MX x) -> MX



    """
    return _casadi.polyval(*args)

def diag(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    diag(IM A) -> IM
    diag(DM A) -> DM
    diag(SX A) -> SX
    diag(MX A) -> MX



    """
    return _casadi.diag(*args)

def unite(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    unite(IM A, IM B) -> IM
    unite(DM A, DM B) -> DM
    unite(SX A, SX B) -> SX
    unite(MX A, MX B) -> MX



    """
    return _casadi.unite(*args)

def densify(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    densify(IM x) -> IM
    densify(DM x) -> DM
    densify(SX x) -> SX
    densify(MX x) -> MX



    """
    return _casadi.densify(*args)

def project(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    project(IM A, Sparsity sp, bool intersect) -> IM
    project(DM A, Sparsity sp, bool intersect) -> DM
    project(SX A, Sparsity sp, bool intersect) -> SX
    project(MX A, Sparsity sp, bool intersect) -> MX



    """
    return _casadi.project(*args)

def if_else(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    if_else(IM cond, IM if_true, IM if_false, bool short_circuit) -> IM
    if_else(DM cond, DM if_true, DM if_false, bool short_circuit) -> DM
    if_else(SX cond, SX if_true, SX if_false, bool short_circuit) -> SX
    if_else(MX cond, MX if_true, MX if_false, bool short_circuit) -> MX



    """
    return _casadi.if_else(*args)

def conditional(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    conditional(IM ind, [IM] x, IM x_default, bool short_circuit) -> IM
    conditional(DM ind, [DM] x, DM x_default, bool short_circuit) -> DM
    conditional(SX ind, [SX] x, SX x_default, bool short_circuit) -> SX
    conditional(MX ind, [MX] x, MX x_default, bool short_circuit) -> MX



    """
    return _casadi.conditional(*args)

def depends_on(*args) -> "bool":
    """


    depends_on(IM f, IM arg) -> bool
    depends_on(DM f, DM arg) -> bool
    depends_on(SX f, SX arg) -> bool
    depends_on(MX f, MX arg) -> bool



    """
    return _casadi.depends_on(*args)

def solve(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    solve(IM A, IM b) -> IM
    solve(DM A, DM b) -> DM
    solve(SX A, SX b) -> SX
    solve(MX A, MX b) -> MX
    solve(IM A, IM b, str lsolver, dict opts) -> IM
    solve(DM A, DM b, str lsolver, dict opts) -> DM
    solve(SX A, SX b, str lsolver, dict opts) -> SX
    solve(MX A, MX b, str lsolver, dict opts) -> MX



    """
    return _casadi.solve(*args)

def pinv(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    pinv(IM A) -> IM
    pinv(DM A) -> DM
    pinv(SX A) -> SX
    pinv(MX A) -> MX
    pinv(IM A, str lsolver, dict opts) -> IM
    pinv(DM A, str lsolver, dict opts) -> DM
    pinv(SX A, str lsolver, dict opts) -> SX
    pinv(MX A, str lsolver, dict opts) -> MX



    """
    return _casadi.pinv(*args)

def expm_const(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    expm_const(IM A, IM t) -> IM
    expm_const(DM A, DM t) -> DM
    expm_const(SX A, SX t) -> SX
    expm_const(MX A, MX t) -> MX



    """
    return _casadi.expm_const(*args)

def expm(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    expm(IM A) -> IM
    expm(DM A) -> DM
    expm(SX A) -> SX
    expm(MX A) -> MX



    """
    return _casadi.expm(*args)

def jacobian(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    jacobian(IM ex, IM arg, dict opts) -> IM
    jacobian(DM ex, DM arg, dict opts) -> DM
    jacobian(SX ex, SX arg, dict opts) -> SX
    jacobian(MX ex, MX arg, dict opts) -> MX



    """
    return _casadi.jacobian(*args)

def jtimes(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    jtimes(IM ex, IM arg, IM v, bool tr) -> IM
    jtimes(DM ex, DM arg, DM v, bool tr) -> DM
    jtimes(SX ex, SX arg, SX v, bool tr) -> SX
    jtimes(MX ex, MX arg, MX v, bool tr) -> MX



    """
    return _casadi.jtimes(*args)

def linearize(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    linearize(IM f, IM x, IM x0) -> IM
    linearize(DM f, DM x, DM x0) -> DM
    linearize(SX f, SX x, SX x0) -> SX
    linearize(MX f, MX x, MX x0) -> MX



    """
    return _casadi.linearize(*args)

def which_depends(*args) -> "std::vector< bool,std::allocator< bool > >":
    """


    which_depends(IM expr, IM var, int order, bool tr) -> [bool]
    which_depends(DM expr, DM var, int order, bool tr) -> [bool]
    which_depends(SX expr, SX var, int order, bool tr) -> [bool]
    which_depends(MX expr, MX var, int order, bool tr) -> [bool]



    """
    return _casadi.which_depends(*args)

def gradient(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    gradient(IM ex, IM arg) -> IM
    gradient(DM ex, DM arg) -> DM
    gradient(SX ex, SX arg) -> SX
    gradient(MX ex, MX arg) -> MX



    """
    return _casadi.gradient(*args)

def tangent(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    tangent(IM ex, IM arg) -> IM
    tangent(DM ex, DM arg) -> DM
    tangent(SX ex, SX arg) -> SX
    tangent(MX ex, MX arg) -> MX



    """
    return _casadi.tangent(*args)

def hessian(*args) -> "casadi::Matrix< casadi::SXElem > &":
    """


    hessian(IM ex, IM arg) -> (IM , IM OUTPUT1)
    hessian(DM ex, DM arg) -> (DM , DM OUTPUT1)
    hessian(SX ex, SX arg) -> (SX , SX OUTPUT1)
    hessian(MX ex, MX arg) -> (MX , MX OUTPUT1)



    """
    return _casadi.hessian(*args)

def n_nodes(*args) -> "int":
    """


    n_nodes(IM A) -> int
    n_nodes(DM A) -> int
    n_nodes(SX A) -> int
    n_nodes(MX A) -> int



    """
    return _casadi.n_nodes(*args)

def print_operator(*args) -> "std::string":
    """


    print_operator(IM xb, [str] args) -> str
    print_operator(DM xb, [str] args) -> str
    print_operator(SX xb, [str] args) -> str
    print_operator(MX xb, [str] args) -> str



    """
    return _casadi.print_operator(*args)

def repsum(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    repsum(IM A, int n, int m) -> IM
    repsum(DM A, int n, int m) -> DM
    repsum(SX A, int n, int m) -> SX
    repsum(MX A, int n, int m) -> MX



    """
    return _casadi.repsum(*args)

def einstein(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    einstein(IM A, IM B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> IM
    einstein(DM A, DM B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> DM
    einstein(SX A, SX B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> SX
    einstein(MX A, MX B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> MX
    einstein(IM A, IM B, IM C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> IM
    einstein(DM A, DM B, DM C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> DM
    einstein(SX A, SX B, SX C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> SX
    einstein(MX A, MX B, MX C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -> MX



    """
    return _casadi.einstein(*args)

def forward(*args) -> "std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >":
    """


    forward([IM] ex, [IM] arg, [IM]] v, dict opts) -> [IM]]
    forward([DM] ex, [DM] arg, [[DM]] v, dict opts) -> [[DM]]
    forward([SX] ex, [SX] arg, [SX]] v, dict opts) -> [SX]]
    forward([MX] ex, [MX] arg, [[MX]] v, dict opts) -> [[MX]]



    """
    return _casadi.forward(*args)

def reverse(*args) -> "std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >":
    """


    reverse([IM] ex, [IM] arg, [IM]] v, dict opts) -> [IM]]
    reverse([DM] ex, [DM] arg, [[DM]] v, dict opts) -> [[DM]]
    reverse([SX] ex, [SX] arg, [SX]] v, dict opts) -> [SX]]
    reverse([MX] ex, [MX] arg, [[MX]] v, dict opts) -> [[MX]]



    """
    return _casadi.reverse(*args)

def substitute(*args) -> "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >":
    """


    substitute(IM ex, IM v, IM vdef) -> IM
    substitute([IM] ex, [IM] v, [IM] vdef) -> [IM]
    substitute(DM ex, DM v, DM vdef) -> DM
    substitute([DM] ex, [DM] v, [DM] vdef) -> [DM]
    substitute(SX ex, SX v, SX vdef) -> SX
    substitute([SX] ex, [SX] v, [SX] vdef) -> [SX]
    substitute(MX ex, MX v, MX vdef) -> MX
    substitute([MX] ex, [MX] v, [MX] vdef) -> [MX]



    """
    return _casadi.substitute(*args)

def substitute_inplace(*args) -> "std::vector< casadi::Matrix< casadi::SXElem > > &, std::vector< casadi::Matrix< casadi::SXElem > > &":
    """


    substitute_inplace([IM] v, bool reverse) -> ([IM] INOUT1, [IM] INOUT2)
    substitute_inplace([DM] v, bool reverse) -> ([DM] INOUT1, [DM] INOUT2)
    substitute_inplace([SX] v, bool reverse) -> ([SX] INOUT1, [SX] INOUT2)
    substitute_inplace([MX] v, bool reverse) -> ([MX] INOUT1, [MX] INOUT2)



    """
    return _casadi.substitute_inplace(*args)

def shared(*args) -> "std::vector< casadi::Matrix< casadi::SXElem > > &, std::vector< casadi::Matrix< casadi::SXElem > > &, std::vector< casadi::Matrix< casadi::SXElem > > &":
    """


    shared([IM] ex, str v_prefix, str v_suffix) -> ([IM] OUTPUT1, [IM] OUTPUT2, [IM] OUTPUT3)
    shared([DM] ex, str v_prefix, str v_suffix) -> ([DM] OUTPUT1, [DM] OUTPUT2, [DM] OUTPUT3)
    shared([SX] ex, str v_prefix, str v_suffix) -> ([SX] OUTPUT1, [SX] OUTPUT2, [SX] OUTPUT3)
    shared([MX] ex, str v_prefix, str v_suffix) -> ([MX] OUTPUT1, [MX] OUTPUT2, [MX] OUTPUT3)



    """
    return _casadi.shared(*args)

def logic_all(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    logic_all(IM x) -> IM
    logic_all(DM x) -> DM
    logic_all(SX x) -> SX



    """
    return _casadi.logic_all(*args)

def logic_any(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    logic_any(IM x) -> IM
    logic_any(DM x) -> DM
    logic_any(SX x) -> SX



    """
    return _casadi.logic_any(*args)

def adj(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    adj(IM A) -> IM
    adj(DM A) -> DM
    adj(SX A) -> SX



    """
    return _casadi.adj(*args)

def getMinor(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    getMinor(IM x, int i, int j) -> IM
    getMinor(DM x, int i, int j) -> DM
    getMinor(SX x, int i, int j) -> SX



    """
    return _casadi.getMinor(*args)

def cofactor(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    cofactor(IM x, int i, int j) -> IM
    cofactor(DM x, int i, int j) -> DM
    cofactor(SX x, int i, int j) -> SX



    """
    return _casadi.cofactor(*args)

def qr(*args) -> "casadi::Matrix< casadi::SXElem > &, casadi::Matrix< casadi::SXElem > &":
    """


    qr(IM A) -> (IM OUTPUT1, IM OUTPUT2)
    qr(DM A) -> (DM OUTPUT1, DM OUTPUT2)
    qr(SX A) -> (SX OUTPUT1, SX OUTPUT2)



    """
    return _casadi.qr(*args)

def chol(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    chol(IM A) -> IM
    chol(DM A) -> DM
    chol(SX A) -> SX



    """
    return _casadi.chol(*args)

def norm_inf_mul(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    norm_inf_mul(IM x, IM y) -> IM
    norm_inf_mul(DM x, DM y) -> DM
    norm_inf_mul(SX x, SX y) -> SX



    """
    return _casadi.norm_inf_mul(*args)

def sparsify(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    sparsify(IM A, float tol) -> IM
    sparsify(DM A, float tol) -> DM
    sparsify(SX A, float tol) -> SX



    """
    return _casadi.sparsify(*args)

def expand(*args) -> "casadi::Matrix< casadi::SXElem > &, casadi::Matrix< casadi::SXElem > &":
    """


    expand(IM ex) -> (IM OUTPUT1, IM OUTPUT2)
    expand(DM ex) -> (DM OUTPUT1, DM OUTPUT2)
    expand(SX ex) -> (SX OUTPUT1, SX OUTPUT2)



    """
    return _casadi.expand(*args)

def pw_const(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    pw_const(IM t, IM tval, IM val) -> IM
    pw_const(DM t, DM tval, DM val) -> DM
    pw_const(SX t, SX tval, SX val) -> SX



    """
    return _casadi.pw_const(*args)

def pw_lin(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    pw_lin(IM t, IM tval, IM val) -> IM
    pw_lin(DM t, DM tval, DM val) -> DM
    pw_lin(SX t, SX tval, SX val) -> SX



    """
    return _casadi.pw_lin(*args)

def heaviside(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    heaviside(IM x) -> IM
    heaviside(DM x) -> DM
    heaviside(SX x) -> SX



    """
    return _casadi.heaviside(*args)

def rectangle(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    rectangle(IM x) -> IM
    rectangle(DM x) -> DM
    rectangle(SX x) -> SX



    """
    return _casadi.rectangle(*args)

def triangle(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    triangle(IM x) -> IM
    triangle(DM x) -> DM
    triangle(SX x) -> SX



    """
    return _casadi.triangle(*args)

def ramp(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    ramp(IM x) -> IM
    ramp(DM x) -> DM
    ramp(SX x) -> SX



    """
    return _casadi.ramp(*args)

def gauss_quadrature(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    gauss_quadrature(IM f, IM x, IM a, IM b, int order) -> IM
    gauss_quadrature(DM f, DM x, DM a, DM b, int order) -> DM
    gauss_quadrature(SX f, SX x, SX a, SX b, int order) -> SX
    gauss_quadrature(IM f, IM x, IM a, IM b, int order, IM w) -> IM
    gauss_quadrature(DM f, DM x, DM a, DM b, int order, DM w) -> DM
    gauss_quadrature(SX f, SX x, SX a, SX b, int order, SX w) -> SX



    """
    return _casadi.gauss_quadrature(*args)

def taylor(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    taylor(IM ex, IM x, IM a, int order) -> IM
    taylor(DM ex, DM x, DM a, int order) -> DM
    taylor(SX ex, SX x, SX a, int order) -> SX



    """
    return _casadi.taylor(*args)

def mtaylor(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    mtaylor(IM ex, IM x, IM a, int order) -> IM
    mtaylor(DM ex, DM x, DM a, int order) -> DM
    mtaylor(SX ex, SX x, SX a, int order) -> SX
    mtaylor(IM ex, IM x, IM a, int order, [int] order_contributions) -> IM
    mtaylor(DM ex, DM x, DM a, int order, [int] order_contributions) -> DM
    mtaylor(SX ex, SX x, SX a, int order, [int] order_contributions) -> SX



    """
    return _casadi.mtaylor(*args)

def poly_coeff(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    poly_coeff(IM ex, IM x) -> IM
    poly_coeff(DM ex, DM x) -> DM
    poly_coeff(SX ex, SX x) -> SX



    """
    return _casadi.poly_coeff(*args)

def poly_roots(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    poly_roots(IM p) -> IM
    poly_roots(DM p) -> DM
    poly_roots(SX p) -> SX



    """
    return _casadi.poly_roots(*args)

def eig_symbolic(*args) -> "casadi::Matrix< casadi::SXElem >":
    """


    eig_symbolic(IM m) -> IM
    eig_symbolic(DM m) -> DM
    eig_symbolic(SX m) -> SX



    """
    return _casadi.eig_symbolic(*args)

def find(*args) -> "casadi::MX":
    """


    find(MX x) -> MX



    """
    return _casadi.find(*args)

def inv_node(*args) -> "casadi::MX":
    """


    inv_node(MX x) -> MX



    """
    return _casadi.inv_node(*args)

def matrix_expand(*args) -> "casadi::MX":
    """


    matrix_expand(MX e, [MX] boundary, dict options) -> MX
    matrix_expand([MX] e, [MX] boundary, dict options) -> [MX]



    """
    return _casadi.matrix_expand(*args)

def graph_substitute(*args) -> "std::vector< casadi::MX,std::allocator< casadi::MX > >":
    """


    graph_substitute(MX ex, [MX] v, [MX] vdef) -> MX
    graph_substitute([MX] ex, [MX] v, [MX] vdef) -> [MX]



    """
    return _casadi.graph_substitute(*args)
class Importer(SharedObject):
    """
      Importer.



    Just-in-time compilation of code

    General information
    ===================



    List of plugins
    ===============



    - clang

    - shell

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Importer.doc("myextraplugin")



    --------------------------------------------------------------------------------

    clang
    -----



    Interface to the JIT compiler CLANG

    >List of available options

    +--------------+-----------------+-----------------------------------------+
    |      Id      |      Type       |               Description               |
    +==============+=================+=========================================+
    | flags        | OT_STRINGVECTOR | Compile flags for the JIT compiler.     |
    |              |                 | Default: None                           |
    +--------------+-----------------+-----------------------------------------+
    | include_path | OT_STRING       | Include paths for the JIT compiler. The |
    |              |                 | include directory shipped with CasADi   |
    |              |                 | will be automatically appended.         |
    +--------------+-----------------+-----------------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    shell
    -----



    Interface to the JIT compiler SHELL

    >List of available options

    +----------------+-----------------+---------------------------------------+
    |       Id       |      Type       |              Description              |
    +================+=================+=======================================+
    | cleanup        | OT_BOOL         | Cleanup temporary files when          |
    |                |                 | unloading. Default: true              |
    +----------------+-----------------+---------------------------------------+
    | compiler       | OT_STRING       | Compiler command                      |
    +----------------+-----------------+---------------------------------------+
    | compiler_flags | OT_STRINGVECTOR | Alias for 'compiler_flags'            |
    +----------------+-----------------+---------------------------------------+
    | compiler_setup | OT_STRING       | Compiler setup command. Intended to   |
    |                |                 | be fixed. The 'flag' option is the    |
    |                |                 | prefered way to set custom flags.     |
    +----------------+-----------------+---------------------------------------+
    | flags          | OT_STRINGVECTOR | Compile flags for the JIT compiler.   |
    |                |                 | Default: None                         |
    +----------------+-----------------+---------------------------------------+
    | folder         | OT_STRING       | Folder to put temporary objects in.   |
    +----------------+-----------------+---------------------------------------+
    | linker         | OT_STRING       | Linker command                        |
    +----------------+-----------------+---------------------------------------+
    | linker_flags   | OT_STRINGVECTOR | Linker flags for the JIT compiler.    |
    |                |                 | Default: None                         |
    +----------------+-----------------+---------------------------------------+
    | linker_setup   | OT_STRING       | Linker setup command. Intended to be  |
    |                |                 | fixed. The 'flag' option is the       |
    |                |                 | prefered way to set custom flags.     |
    +----------------+-----------------+---------------------------------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: importer.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Importer, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Importer, name)
    __repr__ = _swig_repr

    def test_cast(*args) -> "bool":
        """


        test_cast(casadi::SharedObjectInternal const * ptr) -> bool



        """
        return _casadi.Importer_test_cast(*args)

    test_cast = staticmethod(test_cast)

    def has_plugin(*args) -> "bool":
        """


        has_plugin(str name) -> bool



        """
        return _casadi.Importer_has_plugin(*args)

    has_plugin = staticmethod(has_plugin)

    def load_plugin(*args) -> "void":
        """


        load_plugin(str name)



        """
        return _casadi.Importer_load_plugin(*args)

    load_plugin = staticmethod(load_plugin)

    def doc(*args) -> "std::string":
        """


        doc(str name) -> str



        """
        return _casadi.Importer_doc(*args)

    doc = staticmethod(doc)

    def plugin_name(self, *args) -> "std::string":
        """
        Query plugin name.

        plugin_name(self) -> str





        """
        return _casadi.Importer_plugin_name(self, *args)


    def has_function(self, *args) -> "bool":
        """


        has_function(self, str symname) -> bool



        """
        return _casadi.Importer_has_function(self, *args)


    def has_meta(self, *args) -> "bool":
        """
        Does a meta entry exist?

        has_meta(self, str cmd, int ind) -> bool





        """
        return _casadi.Importer_has_meta(self, *args)


    def get_meta(self, *args) -> "std::string":
        """
        Get entry as a text.

        get_meta(self, str cmd, int ind) -> str





        """
        return _casadi.Importer_get_meta(self, *args)


    def inlined(self, *args) -> "bool":
        """
        Check if a function is inlined.

        inlined(self, str symname) -> bool





        """
        return _casadi.Importer_inlined(self, *args)


    def body(self, *args) -> "std::string":
        """
        Get the function body, if inlined.

        body(self, str symname) -> str





        """
        return _casadi.Importer_body(self, *args)


    def __init__(self, *args):
        """


          Importer()
            Default constructor.
          Importer(Importer other)
          Importer(str name, str compiler, dict opts)
            Importer factory.

        > Importer(Importer other)
        ------------------------------------------------------------------------

        > Importer(str name, str compiler, dict opts)
        ------------------------------------------------------------------------


        Importer factory.


        > Importer()
        ------------------------------------------------------------------------


        Default constructor.




        """
        this = _casadi.new_Importer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_Importer
Importer_swigregister = _casadi.Importer_swigregister
Importer_swigregister(Importer)

def Importer_test_cast(*args) -> "bool":
    """


    test_cast(casadi::SharedObjectInternal const * ptr) -> bool



    """
    return _casadi.Importer_test_cast(*args)

def Importer_has_plugin(*args) -> "bool":
    """


    has_plugin(str name) -> bool



    """
    return _casadi.Importer_has_plugin(*args)

def Importer_load_plugin(*args) -> "void":
    """


    load_plugin(str name)



    """
    return _casadi.Importer_load_plugin(*args)

def Importer_doc(*args) -> "std::string":
    """


    doc(str name) -> str



    """
    return _casadi.Importer_doc(*args)

class Callback(Function):
    """
      Callback function functionality.



    This class provides a public API to the FunctionInternal class that can be
    subclassed by the user, who is then able to implement the different virtual
    method. Note that the Function class also provides a public API to
    FunctionInternal, but only allows calling, not being called.

    The user is responsible for not deleting this class for the lifetime of the
    internal function object.

    Joris Gillis, Joel Andersson

    C++ includes: callback.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Callback, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Callback, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
          Copy constructor (throws an error)

          Callback(self)
            Default constructor.
          Callback(self, Callback obj)



        > Callback(self)
        ------------------------------------------------------------------------


        Default constructor.


        > Callback(self, Callback obj)
        ------------------------------------------------------------------------


        Copy constructor (throws an error)




        """
        if self.__class__ == Callback:
            _self = None
        else:
            _self = self
        this = _casadi.new_Callback(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def create(*args) -> "casadi::Function":
        """


        create(str name, Callback n, dict opts) -> Function



        """
        return _casadi.Callback_create(*args)

    create = staticmethod(create)

    def construct(self, *args) -> "void":
        """
          Construct internal object This is the step that actually construct the

          construct(self, str name, dict opts)

        internal object, as the class constructor only creates a null pointer. It
        should be called from the user constructor.




        """
        return _casadi.Callback_construct(self, *args)

    __swig_destroy__ = _casadi.delete_Callback

    def init(self, *args) -> "void":
        """
          Initialize the object This function is called after the object construction

          init(self)

        (for the whole class hierarchy) is complete, but before the finalization
        step. It is called recursively for the whole class hierarchy, starting with
        the lowest level.




        """
        return _casadi.Callback_init(self, *args)


    def finalize(self, *args) -> "void":
        """
          Finalize the object This function is called after the construction and init

          finalize(self)

        steps are completed, but before user functions are called. It is called
        recursively for the whole class hierarchy, starting with the highest level.




        """
        return _casadi.Callback_finalize(self, *args)


    def eval(self, *args) -> "std::vector< casadi::DM,std::allocator< casadi::DM > >":
        """
        Evaluate numerically, temporary matrices and work vectors.

        eval(self, [DM] arg) -> [DM]





        """
        return _casadi.Callback_eval(self, *args)


    def get_n_in(self, *args) -> "int":
        """
        Get the number of inputs This function is called during construction.

        get_n_in(self) -> int





        """
        return _casadi.Callback_get_n_in(self, *args)


    def get_n_out(self, *args) -> "int":
        """
        Get the number of outputs This function is called during construction.

        get_n_out(self) -> int





        """
        return _casadi.Callback_get_n_out(self, *args)


    def get_sparsity_in(self, *args) -> "casadi::Sparsity":
        """
        Get the sparsity of an input This function is called during construction.

        get_sparsity_in(self, int i) -> Sparsity





        """
        return _casadi.Callback_get_sparsity_in(self, *args)


    def get_sparsity_out(self, *args) -> "casadi::Sparsity":
        """
        Get the sparsity of an output This function is called during construction.

        get_sparsity_out(self, int i) -> Sparsity





        """
        return _casadi.Callback_get_sparsity_out(self, *args)


    def get_name_in(self, *args) -> "std::string":
        """
        Get the sparsity of an input This function is called during construction.

        get_name_in(self, int i) -> str





        """
        return _casadi.Callback_get_name_in(self, *args)


    def get_name_out(self, *args) -> "std::string":
        """
        Get the sparsity of an output This function is called during construction.

        get_name_out(self, int i) -> str





        """
        return _casadi.Callback_get_name_out(self, *args)


    def has_jacobian(self, *args) -> "bool":
        """
        Return Jacobian of all input elements with respect to all output elements.

        has_jacobian(self) -> bool





        """
        return _casadi.Callback_has_jacobian(self, *args)


    def get_jacobian(self, *args) -> "casadi::Function":
        """
        Return Jacobian of all input elements with respect to all output elements.

        get_jacobian(self, str name, dict opts) -> Function





        """
        return _casadi.Callback_get_jacobian(self, *args)


    def get_forward(self, *args) -> "casadi::Function":
        """
          Return function that calculates forward derivatives forward(nfwd) returns a

          get_forward(self, str name, int nfwd, [str] i_names, [str] o_names, dict opts) -> Function

        cached instance if available, and calls  Function get_forward(int nfwd) if
        no cached version is available.




        """
        return _casadi.Callback_get_forward(self, *args)


    def get_n_forward(self, *args) -> "int":
        """
          Return function that calculates forward derivatives forward(nfwd) returns a

          get_n_forward(self) -> int

        cached instance if available, and calls  Function get_forward(int nfwd) if
        no cached version is available.




        """
        return _casadi.Callback_get_n_forward(self, *args)


    def get_reverse(self, *args) -> "casadi::Function":
        """
          Return function that calculates adjoint derivatives reverse(nadj) returns a

          get_reverse(self, str name, int nadj, [str] i_names, [str] o_names, dict opts) -> Function

        cached instance if available, and calls  Function get_reverse(int nadj) if
        no cached version is available.




        """
        return _casadi.Callback_get_reverse(self, *args)


    def get_n_reverse(self, *args) -> "int":
        """
          Return function that calculates adjoint derivatives reverse(nadj) returns a

          get_n_reverse(self) -> int

        cached instance if available, and calls  Function get_reverse(int nadj) if
        no cached version is available.




        """
        return _casadi.Callback_get_n_reverse(self, *args)


    def alloc_w(self, *args) -> "void":
        """
        Allocate work vectors.

        alloc_w(self, size_t sz_w, bool persist)





        """
        return _casadi.Callback_alloc_w(self, *args)


    def alloc_iw(self, *args) -> "void":
        """
        Allocate work vectors.

        alloc_iw(self, size_t sz_iw, bool persist)





        """
        return _casadi.Callback_alloc_iw(self, *args)


    def alloc_arg(self, *args) -> "void":
        """
        Allocate work vectors.

        alloc_arg(self, size_t sz_arg, bool persist)





        """
        return _casadi.Callback_alloc_arg(self, *args)


    def alloc_res(self, *args) -> "void":
        """
        Allocate work vectors.

        alloc_res(self, size_t sz_res, bool persist)





        """
        return _casadi.Callback_alloc_res(self, *args)

    def __disown__(self):
        self.this.disown()
        _casadi.disown_Callback(self)
        return weakref_proxy(self)
Callback_swigregister = _casadi.Callback_swigregister
Callback_swigregister(Callback)

def Callback_create(*args) -> "casadi::Function":
    """


    create(str name, Callback n, dict opts) -> Function



    """
    return _casadi.Callback_create(*args)

class GlobalOptions(_object):
    """
      Collects global CasADi options.



    Note to developers: use sparingly. Global options are - in general - a
    rather bad idea

    this class must never be instantiated. Access its static members directly
    Joris Gillis

    C++ includes: global_options.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GlobalOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GlobalOptions, name)
    __repr__ = _swig_repr

    def setSimplificationOnTheFly(*args) -> "void":
        """


        setSimplificationOnTheFly(bool flag)



        """
        return _casadi.GlobalOptions_setSimplificationOnTheFly(*args)

    setSimplificationOnTheFly = staticmethod(setSimplificationOnTheFly)

    def getSimplificationOnTheFly(*args) -> "bool":
        """


        getSimplificationOnTheFly() -> bool



        """
        return _casadi.GlobalOptions_getSimplificationOnTheFly(*args)

    getSimplificationOnTheFly = staticmethod(getSimplificationOnTheFly)

    def setHierarchicalSparsity(*args) -> "void":
        """


        setHierarchicalSparsity(bool flag)



        """
        return _casadi.GlobalOptions_setHierarchicalSparsity(*args)

    setHierarchicalSparsity = staticmethod(setHierarchicalSparsity)

    def getHierarchicalSparsity(*args) -> "bool":
        """


        getHierarchicalSparsity() -> bool



        """
        return _casadi.GlobalOptions_getHierarchicalSparsity(*args)

    getHierarchicalSparsity = staticmethod(getHierarchicalSparsity)

    def setCasadiPath(*args) -> "void":
        """


        setCasadiPath(str path)



        """
        return _casadi.GlobalOptions_setCasadiPath(*args)

    setCasadiPath = staticmethod(setCasadiPath)

    def getCasadiPath(*args) -> "std::string":
        """


        getCasadiPath() -> str



        """
        return _casadi.GlobalOptions_getCasadiPath(*args)

    getCasadiPath = staticmethod(getCasadiPath)

    def __init__(self, *args):
        """


        GlobalOptions(GlobalOptions other)



        """
        this = _casadi.new_GlobalOptions(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_GlobalOptions
GlobalOptions_swigregister = _casadi.GlobalOptions_swigregister
GlobalOptions_swigregister(GlobalOptions)

def GlobalOptions_setSimplificationOnTheFly(*args) -> "void":
    """


    setSimplificationOnTheFly(bool flag)



    """
    return _casadi.GlobalOptions_setSimplificationOnTheFly(*args)

def GlobalOptions_getSimplificationOnTheFly(*args) -> "bool":
    """


    getSimplificationOnTheFly() -> bool



    """
    return _casadi.GlobalOptions_getSimplificationOnTheFly(*args)

def GlobalOptions_setHierarchicalSparsity(*args) -> "void":
    """


    setHierarchicalSparsity(bool flag)



    """
    return _casadi.GlobalOptions_setHierarchicalSparsity(*args)

def GlobalOptions_getHierarchicalSparsity(*args) -> "bool":
    """


    getHierarchicalSparsity() -> bool



    """
    return _casadi.GlobalOptions_getHierarchicalSparsity(*args)

def GlobalOptions_setCasadiPath(*args) -> "void":
    """


    setCasadiPath(str path)



    """
    return _casadi.GlobalOptions_setCasadiPath(*args)

def GlobalOptions_getCasadiPath(*args) -> "std::string":
    """


    getCasadiPath() -> str



    """
    return _casadi.GlobalOptions_getCasadiPath(*args)

class CasadiMeta(_object):
    """
      Collects global CasADi meta information.



    Joris Gillis

    C++ includes: casadi_meta.hpp 


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CasadiMeta, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CasadiMeta, name)
    __repr__ = _swig_repr

    def getVersion(*args) -> "std::string":
        """


        getVersion() -> str



        """
        return _casadi.CasadiMeta_getVersion(*args)

    getVersion = staticmethod(getVersion)

    def getGitRevision(*args) -> "std::string":
        """


        getGitRevision() -> str



        """
        return _casadi.CasadiMeta_getGitRevision(*args)

    getGitRevision = staticmethod(getGitRevision)

    def getGitDescribe(*args) -> "std::string":
        """


        getGitDescribe() -> str



        """
        return _casadi.CasadiMeta_getGitDescribe(*args)

    getGitDescribe = staticmethod(getGitDescribe)

    def getFeatureList(*args) -> "std::string":
        """


        getFeatureList() -> str



        """
        return _casadi.CasadiMeta_getFeatureList(*args)

    getFeatureList = staticmethod(getFeatureList)

    def getBuildType(*args) -> "std::string":
        """


        getBuildType() -> str



        """
        return _casadi.CasadiMeta_getBuildType(*args)

    getBuildType = staticmethod(getBuildType)

    def getCompilerId(*args) -> "std::string":
        """


        getCompilerId() -> str



        """
        return _casadi.CasadiMeta_getCompilerId(*args)

    getCompilerId = staticmethod(getCompilerId)

    def getCompiler(*args) -> "std::string":
        """


        getCompiler() -> str



        """
        return _casadi.CasadiMeta_getCompiler(*args)

    getCompiler = staticmethod(getCompiler)

    def getCompilerFlags(*args) -> "std::string":
        """


        getCompilerFlags() -> str



        """
        return _casadi.CasadiMeta_getCompilerFlags(*args)

    getCompilerFlags = staticmethod(getCompilerFlags)

    def getModules(*args) -> "std::string":
        """


        getModules() -> str



        """
        return _casadi.CasadiMeta_getModules(*args)

    getModules = staticmethod(getModules)

    def getPlugins(*args) -> "std::string":
        """


        getPlugins() -> str



        """
        return _casadi.CasadiMeta_getPlugins(*args)

    getPlugins = staticmethod(getPlugins)

    def getInstallPrefix(*args) -> "std::string":
        """


        getInstallPrefix() -> str



        """
        return _casadi.CasadiMeta_getInstallPrefix(*args)

    getInstallPrefix = staticmethod(getInstallPrefix)

    def version(*args) -> "char const *":
        """


        version() -> char const *



        """
        return _casadi.CasadiMeta_version(*args)

    version = staticmethod(version)

    def git_revision(*args) -> "char const *":
        """


        git_revision() -> char const *



        """
        return _casadi.CasadiMeta_git_revision(*args)

    git_revision = staticmethod(git_revision)

    def git_describe(*args) -> "char const *":
        """


        git_describe() -> char const *



        """
        return _casadi.CasadiMeta_git_describe(*args)

    git_describe = staticmethod(git_describe)

    def feature_list(*args) -> "char const *":
        """


        feature_list() -> char const *



        """
        return _casadi.CasadiMeta_feature_list(*args)

    feature_list = staticmethod(feature_list)

    def build_type(*args) -> "char const *":
        """


        build_type() -> char const *



        """
        return _casadi.CasadiMeta_build_type(*args)

    build_type = staticmethod(build_type)

    def compiler_id(*args) -> "char const *":
        """


        compiler_id() -> char const *



        """
        return _casadi.CasadiMeta_compiler_id(*args)

    compiler_id = staticmethod(compiler_id)

    def compiler(*args) -> "char const *":
        """


        compiler() -> char const *



        """
        return _casadi.CasadiMeta_compiler(*args)

    compiler = staticmethod(compiler)

    def compiler_flags(*args) -> "char const *":
        """


        compiler_flags() -> char const *



        """
        return _casadi.CasadiMeta_compiler_flags(*args)

    compiler_flags = staticmethod(compiler_flags)

    def modules(*args) -> "char const *":
        """


        modules() -> char const *



        """
        return _casadi.CasadiMeta_modules(*args)

    modules = staticmethod(modules)

    def plugins(*args) -> "char const *":
        """


        plugins() -> char const *



        """
        return _casadi.CasadiMeta_plugins(*args)

    plugins = staticmethod(plugins)

    def install_prefix(*args) -> "char const *":
        """


        install_prefix() -> char const *



        """
        return _casadi.CasadiMeta_install_prefix(*args)

    install_prefix = staticmethod(install_prefix)

    def __init__(self, *args):
        """


        CasadiMeta(CasadiMeta other)



        """
        this = _casadi.new_CasadiMeta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_CasadiMeta
CasadiMeta_swigregister = _casadi.CasadiMeta_swigregister
CasadiMeta_swigregister(CasadiMeta)

def CasadiMeta_getVersion(*args) -> "std::string":
    """


    getVersion() -> str



    """
    return _casadi.CasadiMeta_getVersion(*args)

def CasadiMeta_getGitRevision(*args) -> "std::string":
    """


    getGitRevision() -> str



    """
    return _casadi.CasadiMeta_getGitRevision(*args)

def CasadiMeta_getGitDescribe(*args) -> "std::string":
    """


    getGitDescribe() -> str



    """
    return _casadi.CasadiMeta_getGitDescribe(*args)

def CasadiMeta_getFeatureList(*args) -> "std::string":
    """


    getFeatureList() -> str



    """
    return _casadi.CasadiMeta_getFeatureList(*args)

def CasadiMeta_getBuildType(*args) -> "std::string":
    """


    getBuildType() -> str



    """
    return _casadi.CasadiMeta_getBuildType(*args)

def CasadiMeta_getCompilerId(*args) -> "std::string":
    """


    getCompilerId() -> str



    """
    return _casadi.CasadiMeta_getCompilerId(*args)

def CasadiMeta_getCompiler(*args) -> "std::string":
    """


    getCompiler() -> str



    """
    return _casadi.CasadiMeta_getCompiler(*args)

def CasadiMeta_getCompilerFlags(*args) -> "std::string":
    """


    getCompilerFlags() -> str



    """
    return _casadi.CasadiMeta_getCompilerFlags(*args)

def CasadiMeta_getModules(*args) -> "std::string":
    """


    getModules() -> str



    """
    return _casadi.CasadiMeta_getModules(*args)

def CasadiMeta_getPlugins(*args) -> "std::string":
    """


    getPlugins() -> str



    """
    return _casadi.CasadiMeta_getPlugins(*args)

def CasadiMeta_getInstallPrefix(*args) -> "std::string":
    """


    getInstallPrefix() -> str



    """
    return _casadi.CasadiMeta_getInstallPrefix(*args)

def CasadiMeta_version(*args) -> "char const *":
    """


    version() -> char const *



    """
    return _casadi.CasadiMeta_version(*args)

def CasadiMeta_git_revision(*args) -> "char const *":
    """


    git_revision() -> char const *



    """
    return _casadi.CasadiMeta_git_revision(*args)

def CasadiMeta_git_describe(*args) -> "char const *":
    """


    git_describe() -> char const *



    """
    return _casadi.CasadiMeta_git_describe(*args)

def CasadiMeta_feature_list(*args) -> "char const *":
    """


    feature_list() -> char const *



    """
    return _casadi.CasadiMeta_feature_list(*args)

def CasadiMeta_build_type(*args) -> "char const *":
    """


    build_type() -> char const *



    """
    return _casadi.CasadiMeta_build_type(*args)

def CasadiMeta_compiler_id(*args) -> "char const *":
    """


    compiler_id() -> char const *



    """
    return _casadi.CasadiMeta_compiler_id(*args)

def CasadiMeta_compiler(*args) -> "char const *":
    """


    compiler() -> char const *



    """
    return _casadi.CasadiMeta_compiler(*args)

def CasadiMeta_compiler_flags(*args) -> "char const *":
    """


    compiler_flags() -> char const *



    """
    return _casadi.CasadiMeta_compiler_flags(*args)

def CasadiMeta_modules(*args) -> "char const *":
    """


    modules() -> char const *



    """
    return _casadi.CasadiMeta_modules(*args)

def CasadiMeta_plugins(*args) -> "char const *":
    """


    plugins() -> char const *



    """
    return _casadi.CasadiMeta_plugins(*args)

def CasadiMeta_install_prefix(*args) -> "char const *":
    """


    install_prefix() -> char const *



    """
    return _casadi.CasadiMeta_install_prefix(*args)


def collocation_points(*args) -> "std::vector< double,std::allocator< double > >":
    """
      Obtain collocation points of specific order and scheme.

      collocation_points(int order, str scheme) -> [float]


    Parameters:
    -----------

    scheme:  'radau' or 'legendre'




    """
    return _casadi.collocation_points(*args)

def collocation_interpolators(*args) -> "std::vector< std::vector< double > > &, std::vector< double > &":
    """
      Obtain collocation interpolating matrices.

      collocation_interpolators([float] tau_root) -> ([[float]] OUTPUT, [float] OUTPUT)


    Parameters:
    -----------

    tau_root:  location of collocation points, as obtained from
    collocation_points

    C:  interpolating coefficients to obtain derivatives Length: order+1, order
    + 1



    ::

    dX/dt @collPoint(j) ~ Sum_i C[j][i]*X@collPoint(i)



    Parameters:
    -----------

    D:  interpolating coefficients to obtain end state Length: order+1




    """
    return _casadi.collocation_interpolators(*args)
LEGENDRE = _casadi.LEGENDRE
RADAU = _casadi.RADAU

def simpleRK(*args) -> "casadi::Function":
    """
      Construct an explicit Runge-Kutta integrator The constructed function has

      simpleRK(Function f, int N, int order) -> Function

    three inputs, corresponding to initial state (x0), parameter (p) and
    integration time (h) and one output, corresponding to final state (xf).

    Parameters:
    -----------

    f:  ODE function with two inputs (x and p) and one output (xdot)

    N:  Number of integrator steps

    order:  Order of interpolating polynomials




    """
    return _casadi.simpleRK(*args)

def simpleIRK(*args) -> "casadi::Function":
    """
      Construct an implicit Runge-Kutta integrator using a collocation scheme The

      simpleIRK(Function f, int N, int order, str scheme, str solver, dict solver_options) -> Function

    constructed function has three inputs, corresponding to initial state (x0),
    parameter (p) and integration time (h) and one output, corresponding to
    final state (xf).

    Parameters:
    -----------

    f:  ODE function with two inputs (x and p) and one output (xdot)

    N:  Number of integrator steps

    order:  Order of interpolating polynomials

    scheme:   Collocation scheme, as excepted by collocationPoints function.




    """
    return _casadi.simpleIRK(*args)

def simpleIntegrator(*args) -> "casadi::Function":
    """
      Simplified wrapper for the Integrator class Constructs an integrator using

      simpleIntegrator(Function f, str integrator, dict integrator_options) -> Function

    the same syntax as simpleRK and simpleIRK. The constructed function has
    three inputs, corresponding to initial state (x0), parameter (p) and
    integration time (h) and one output, corresponding to final state (xf).

    Parameters:
    -----------

    f:  ODE function with two inputs (x and p) and one output (xdot)

    N:  Number of integrator steps

    order:  Order of interpolating polynomials

    scheme:   Collocation scheme, as excepted by collocationPoints function.




    """
    return _casadi.simpleIntegrator(*args)
class NlpBuilder(PrintNlpBuilder):
    """
      A symbolic NLP representation.



    Joel Andersson

    C++ includes: nlp_builder.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [PrintNlpBuilder]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NlpBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintNlpBuilder]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NlpBuilder, name)
    __repr__ = _swig_repr
    __swig_getmethods__["x"] = _casadi.NlpBuilder_x_get
    if _newclass:
        x = _swig_property(_casadi.NlpBuilder_x_get)
    __swig_getmethods__["f"] = _casadi.NlpBuilder_f_get
    if _newclass:
        f = _swig_property(_casadi.NlpBuilder_f_get)
    __swig_getmethods__["g"] = _casadi.NlpBuilder_g_get
    if _newclass:
        g = _swig_property(_casadi.NlpBuilder_g_get)
    __swig_getmethods__["x_lb"] = _casadi.NlpBuilder_x_lb_get
    if _newclass:
        x_lb = _swig_property(_casadi.NlpBuilder_x_lb_get)
    __swig_getmethods__["x_ub"] = _casadi.NlpBuilder_x_ub_get
    if _newclass:
        x_ub = _swig_property(_casadi.NlpBuilder_x_ub_get)
    __swig_getmethods__["g_lb"] = _casadi.NlpBuilder_g_lb_get
    if _newclass:
        g_lb = _swig_property(_casadi.NlpBuilder_g_lb_get)
    __swig_getmethods__["g_ub"] = _casadi.NlpBuilder_g_ub_get
    if _newclass:
        g_ub = _swig_property(_casadi.NlpBuilder_g_ub_get)
    __swig_getmethods__["x_init"] = _casadi.NlpBuilder_x_init_get
    if _newclass:
        x_init = _swig_property(_casadi.NlpBuilder_x_init_get)
    __swig_getmethods__["lambda_init"] = _casadi.NlpBuilder_lambda_init_get
    if _newclass:
        lambda_init = _swig_property(_casadi.NlpBuilder_lambda_init_get)

    def import_nl(self, *args) -> "void":
        """
        Import an .nl file.

        import_nl(self, str filename, dict opts)





        """
        return _casadi.NlpBuilder_import_nl(self, *args)


    def __init__(self, *args):
        """


        NlpBuilder()
        NlpBuilder(NlpBuilder other)



        """
        this = _casadi.new_NlpBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_NlpBuilder
NlpBuilder_swigregister = _casadi.NlpBuilder_swigregister
NlpBuilder_swigregister(NlpBuilder)

CONSTANT = _casadi.CONSTANT
PARAMETER = _casadi.PARAMETER
DISCRETE = _casadi.DISCRETE
CONTINUOUS = _casadi.CONTINUOUS
INPUT = _casadi.INPUT
OUTPUT = _casadi.OUTPUT
INTERNAL = _casadi.INTERNAL
ALGEBRAIC = _casadi.ALGEBRAIC
DIFFERENTIAL = _casadi.DIFFERENTIAL
NO_ALIAS = _casadi.NO_ALIAS
ALIAS = _casadi.ALIAS
NEGATED_ALIAS = _casadi.NEGATED_ALIAS
CAT_UNKNOWN = _casadi.CAT_UNKNOWN
CAT_DERIVATIVE = _casadi.CAT_DERIVATIVE
CAT_STATE = _casadi.CAT_STATE
CAT_DEPENDENT_CONSTANT = _casadi.CAT_DEPENDENT_CONSTANT
CAT_INDEPENDENT_CONSTANT = _casadi.CAT_INDEPENDENT_CONSTANT
CAT_DEPENDENT_PARAMETER = _casadi.CAT_DEPENDENT_PARAMETER
CAT_INDEPENDENT_PARAMETER = _casadi.CAT_INDEPENDENT_PARAMETER
CAT_ALGEBRAIC = _casadi.CAT_ALGEBRAIC
class Variable(PrintVariable):
    """


    Variable() -> 



    """

    __swig_setmethods__ = {}
    for _s in [PrintVariable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintVariable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)
    __repr__ = _swig_repr

    def name(self, *args) -> "std::string":
        """


        name(self) -> str



        """
        return _casadi.Variable_name(self, *args)

    __swig_getmethods__["v"] = _casadi.Variable_v_get
    if _newclass:
        v = _swig_property(_casadi.Variable_v_get)
    __swig_getmethods__["d"] = _casadi.Variable_d_get
    if _newclass:
        d = _swig_property(_casadi.Variable_d_get)
    __swig_getmethods__["nominal"] = _casadi.Variable_nominal_get
    if _newclass:
        nominal = _swig_property(_casadi.Variable_nominal_get)
    __swig_getmethods__["start"] = _casadi.Variable_start_get
    if _newclass:
        start = _swig_property(_casadi.Variable_start_get)
    __swig_getmethods__["min"] = _casadi.Variable_min_get
    if _newclass:
        min = _swig_property(_casadi.Variable_min_get)
    __swig_getmethods__["max"] = _casadi.Variable_max_get
    if _newclass:
        max = _swig_property(_casadi.Variable_max_get)
    __swig_getmethods__["guess"] = _casadi.Variable_guess_get
    if _newclass:
        guess = _swig_property(_casadi.Variable_guess_get)
    __swig_getmethods__["derivative_start"] = _casadi.Variable_derivative_start_get
    if _newclass:
        derivative_start = _swig_property(_casadi.Variable_derivative_start_get)
    __swig_getmethods__["variability"] = _casadi.Variable_variability_get
    if _newclass:
        variability = _swig_property(_casadi.Variable_variability_get)
    __swig_getmethods__["causality"] = _casadi.Variable_causality_get
    if _newclass:
        causality = _swig_property(_casadi.Variable_causality_get)
    __swig_getmethods__["category"] = _casadi.Variable_category_get
    if _newclass:
        category = _swig_property(_casadi.Variable_category_get)
    __swig_getmethods__["alias"] = _casadi.Variable_alias_get
    if _newclass:
        alias = _swig_property(_casadi.Variable_alias_get)
    __swig_getmethods__["description"] = _casadi.Variable_description_get
    if _newclass:
        description = _swig_property(_casadi.Variable_description_get)
    __swig_getmethods__["valueReference"] = _casadi.Variable_valueReference_get
    if _newclass:
        valueReference = _swig_property(_casadi.Variable_valueReference_get)
    __swig_getmethods__["unit"] = _casadi.Variable_unit_get
    if _newclass:
        unit = _swig_property(_casadi.Variable_unit_get)
    __swig_getmethods__["display_unit"] = _casadi.Variable_display_unit_get
    if _newclass:
        display_unit = _swig_property(_casadi.Variable_display_unit_get)
    __swig_getmethods__["free"] = _casadi.Variable_free_get
    if _newclass:
        free = _swig_property(_casadi.Variable_free_get)

    def __init__(self, *args):
        """


        Variable()
        Variable(Variable other)
        Variable(str name, Sparsity sp)



        """
        this = _casadi.new_Variable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_Variable
Variable_swigregister = _casadi.Variable_swigregister
Variable_swigregister(Variable)

class DaeBuilder(PrintDaeBuilder):
    """
      An initial-value problem in differential-algebraic equations.



    Independent variables:
    ======================





    ::

      t:      time




    Time-continuous variables:
    ==========================





    ::

      x:      states defined by ODE
      s:      implicitly defined states
      z:      algebraic variables
      u:      control signals
      q:      quadrature states
      y:      outputs




    Time-constant variables:
    ========================





    ::

      p:      free parameters
      d:      dependent parameters




    Dynamic constraints (imposed everywhere):
    =========================================





    ::

      ODE                    \\dot{x} ==  ode(t, x, s, z, u, p, d)
      DAE or implicit ODE:         0 ==  dae(t, x, s, z, u, p, d, sdot)
      algebraic equations:         0 ==  alg(t, x, s, z, u, p, d)
      quadrature equations:  \\dot{q} == quad(t, x, s, z, u, p, d)
      dependent parameters:        d == ddef(t, x, s, z, u, p, d)
      output equations:            y == ydef(t, x, s, z, u, p, d)




    Point constraints (imposed pointwise):
    ======================================





    ::

      Initial equations:           0 == init(t, x, s, z, u, p, d, sdot)




    Joel Andersson

    C++ includes: dae_builder.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [PrintDaeBuilder]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DaeBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintDaeBuilder]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DaeBuilder, name)
    __repr__ = _swig_repr
    __swig_getmethods__["t"] = _casadi.DaeBuilder_t_get
    if _newclass:
        t = _swig_property(_casadi.DaeBuilder_t_get)
    __swig_getmethods__["x"] = _casadi.DaeBuilder_x_get
    if _newclass:
        x = _swig_property(_casadi.DaeBuilder_x_get)
    __swig_getmethods__["ode"] = _casadi.DaeBuilder_ode_get
    if _newclass:
        ode = _swig_property(_casadi.DaeBuilder_ode_get)
    __swig_getmethods__["lam_ode"] = _casadi.DaeBuilder_lam_ode_get
    if _newclass:
        lam_ode = _swig_property(_casadi.DaeBuilder_lam_ode_get)
    __swig_getmethods__["s"] = _casadi.DaeBuilder_s_get
    if _newclass:
        s = _swig_property(_casadi.DaeBuilder_s_get)
    __swig_getmethods__["sdot"] = _casadi.DaeBuilder_sdot_get
    if _newclass:
        sdot = _swig_property(_casadi.DaeBuilder_sdot_get)
    __swig_getmethods__["dae"] = _casadi.DaeBuilder_dae_get
    if _newclass:
        dae = _swig_property(_casadi.DaeBuilder_dae_get)
    __swig_getmethods__["lam_dae"] = _casadi.DaeBuilder_lam_dae_get
    if _newclass:
        lam_dae = _swig_property(_casadi.DaeBuilder_lam_dae_get)
    __swig_getmethods__["z"] = _casadi.DaeBuilder_z_get
    if _newclass:
        z = _swig_property(_casadi.DaeBuilder_z_get)
    __swig_getmethods__["alg"] = _casadi.DaeBuilder_alg_get
    if _newclass:
        alg = _swig_property(_casadi.DaeBuilder_alg_get)
    __swig_getmethods__["lam_alg"] = _casadi.DaeBuilder_lam_alg_get
    if _newclass:
        lam_alg = _swig_property(_casadi.DaeBuilder_lam_alg_get)
    __swig_getmethods__["q"] = _casadi.DaeBuilder_q_get
    if _newclass:
        q = _swig_property(_casadi.DaeBuilder_q_get)
    __swig_getmethods__["quad"] = _casadi.DaeBuilder_quad_get
    if _newclass:
        quad = _swig_property(_casadi.DaeBuilder_quad_get)
    __swig_getmethods__["lam_quad"] = _casadi.DaeBuilder_lam_quad_get
    if _newclass:
        lam_quad = _swig_property(_casadi.DaeBuilder_lam_quad_get)
    __swig_getmethods__["w"] = _casadi.DaeBuilder_w_get
    if _newclass:
        w = _swig_property(_casadi.DaeBuilder_w_get)
    __swig_getmethods__["wdef"] = _casadi.DaeBuilder_wdef_get
    if _newclass:
        wdef = _swig_property(_casadi.DaeBuilder_wdef_get)
    __swig_getmethods__["lam_wdef"] = _casadi.DaeBuilder_lam_wdef_get
    if _newclass:
        lam_wdef = _swig_property(_casadi.DaeBuilder_lam_wdef_get)
    __swig_getmethods__["y"] = _casadi.DaeBuilder_y_get
    if _newclass:
        y = _swig_property(_casadi.DaeBuilder_y_get)
    __swig_getmethods__["ydef"] = _casadi.DaeBuilder_ydef_get
    if _newclass:
        ydef = _swig_property(_casadi.DaeBuilder_ydef_get)
    __swig_getmethods__["lam_ydef"] = _casadi.DaeBuilder_lam_ydef_get
    if _newclass:
        lam_ydef = _swig_property(_casadi.DaeBuilder_lam_ydef_get)
    __swig_getmethods__["u"] = _casadi.DaeBuilder_u_get
    if _newclass:
        u = _swig_property(_casadi.DaeBuilder_u_get)
    __swig_getmethods__["p"] = _casadi.DaeBuilder_p_get
    if _newclass:
        p = _swig_property(_casadi.DaeBuilder_p_get)
    __swig_getmethods__["c"] = _casadi.DaeBuilder_c_get
    if _newclass:
        c = _swig_property(_casadi.DaeBuilder_c_get)
    __swig_getmethods__["cdef"] = _casadi.DaeBuilder_cdef_get
    if _newclass:
        cdef = _swig_property(_casadi.DaeBuilder_cdef_get)
    __swig_getmethods__["d"] = _casadi.DaeBuilder_d_get
    if _newclass:
        d = _swig_property(_casadi.DaeBuilder_d_get)
    __swig_getmethods__["ddef"] = _casadi.DaeBuilder_ddef_get
    if _newclass:
        ddef = _swig_property(_casadi.DaeBuilder_ddef_get)
    __swig_getmethods__["lam_ddef"] = _casadi.DaeBuilder_lam_ddef_get
    if _newclass:
        lam_ddef = _swig_property(_casadi.DaeBuilder_lam_ddef_get)
    __swig_getmethods__["init"] = _casadi.DaeBuilder_init_get
    if _newclass:
        init = _swig_property(_casadi.DaeBuilder_init_get)

    def add_p(self, *args) -> "casadi::MX":
        """
        Add a new parameter

        add_p(self, str name, int n) -> MX





        """
        return _casadi.DaeBuilder_add_p(self, *args)


    def add_u(self, *args) -> "casadi::MX":
        """
        Add a new control.

        add_u(self, str name, int n) -> MX





        """
        return _casadi.DaeBuilder_add_u(self, *args)


    def add_x(self, *args) -> "casadi::MX":
        """
        Add a new differential state.

        add_x(self, str name, int n) -> MX





        """
        return _casadi.DaeBuilder_add_x(self, *args)


    def add_s(self, *args) -> "std::pair< casadi::MX,casadi::MX >":
        """
        Add a implicit state.

        add_s(self, str name, int n) -> std::pair< casadi::MX,casadi::MX >





        """
        return _casadi.DaeBuilder_add_s(self, *args)


    def add_z(self, *args) -> "casadi::MX":
        """
        Add a new algebraic variable.

        add_z(self, str name, int n) -> MX





        """
        return _casadi.DaeBuilder_add_z(self, *args)


    def add_q(self, *args) -> "casadi::MX":
        """
        Add a new quadrature state.

        add_q(self, str name, int n) -> MX





        """
        return _casadi.DaeBuilder_add_q(self, *args)


    def add_d(self, *args) -> "casadi::MX":
        """
        Add a new dependent parameter.

        add_d(self, MX new_ddef, str name) -> MX





        """
        return _casadi.DaeBuilder_add_d(self, *args)


    def add_y(self, *args) -> "casadi::MX":
        """
        Add a new output.

        add_y(self, MX new_ydef, str name) -> MX





        """
        return _casadi.DaeBuilder_add_y(self, *args)


    def add_ode(self, *args) -> "void":
        """
        Add an ordinary differential equation.

        add_ode(self, MX new_ode, str name)





        """
        return _casadi.DaeBuilder_add_ode(self, *args)


    def add_dae(self, *args) -> "void":
        """
        Add a differential-algebraic equation.

        add_dae(self, MX new_dae, str name)





        """
        return _casadi.DaeBuilder_add_dae(self, *args)


    def add_alg(self, *args) -> "void":
        """
        Add an algebraic equation.

        add_alg(self, MX new_alg, str name)





        """
        return _casadi.DaeBuilder_add_alg(self, *args)


    def add_quad(self, *args) -> "void":
        """
        Add a quadrature equation.

        add_quad(self, MX new_quad, str name)





        """
        return _casadi.DaeBuilder_add_quad(self, *args)


    def sanity_check(self, *args) -> "void":
        """
        Check if dimensions match.

        sanity_check(self)





        """
        return _casadi.DaeBuilder_sanity_check(self, *args)


    def split_dae(self, *args) -> "void":
        """
        Identify and separate the algebraic variables and equations in the DAE.

        split_dae(self)





        """
        return _casadi.DaeBuilder_split_dae(self, *args)


    def eliminate_alg(self, *args) -> "void":
        """
        Eliminate algebraic variables and equations transforming them into outputs.

        eliminate_alg(self)





        """
        return _casadi.DaeBuilder_eliminate_alg(self, *args)


    def make_semi_explicit(self, *args) -> "void":
        """
        Transform the implicit DAE to a semi-explicit DAE.

        make_semi_explicit(self)





        """
        return _casadi.DaeBuilder_make_semi_explicit(self, *args)


    def make_explicit(self, *args) -> "void":
        """
        Transform the implicit DAE or semi-explicit DAE into an explicit ODE.

        make_explicit(self)





        """
        return _casadi.DaeBuilder_make_explicit(self, *args)


    def sort_d(self, *args) -> "void":
        """
        Sort dependent parameters.

        sort_d(self)





        """
        return _casadi.DaeBuilder_sort_d(self, *args)


    def split_d(self, *args) -> "void":
        """
        Eliminate interdependencies amongst dependent parameters.

        split_d(self)





        """
        return _casadi.DaeBuilder_split_d(self, *args)


    def eliminate_d(self, *args) -> "void":
        """
        Eliminate dependent parameters.

        eliminate_d(self)





        """
        return _casadi.DaeBuilder_eliminate_d(self, *args)


    def eliminate_quad(self, *args) -> "void":
        """
        Eliminate quadrature states and turn them into ODE states.

        eliminate_quad(self)





        """
        return _casadi.DaeBuilder_eliminate_quad(self, *args)


    def sort_dae(self, *args) -> "void":
        """
        Sort the DAE and implicitly defined states.

        sort_dae(self)





        """
        return _casadi.DaeBuilder_sort_dae(self, *args)


    def sort_alg(self, *args) -> "void":
        """
        Sort the algebraic equations and algebraic states.

        sort_alg(self)





        """
        return _casadi.DaeBuilder_sort_alg(self, *args)


    def scale_variables(self, *args) -> "void":
        """
        Scale the variables.

        scale_variables(self)





        """
        return _casadi.DaeBuilder_scale_variables(self, *args)


    def scale_equations(self, *args) -> "void":
        """
        Scale the implicit equations.

        scale_equations(self)





        """
        return _casadi.DaeBuilder_scale_equations(self, *args)


    def parse_fmi(self, *args) -> "void":
        """
        Import existing problem from FMI/XML

        parse_fmi(self, str filename)





        """
        return _casadi.DaeBuilder_parse_fmi(self, *args)


    def add_lc(self, *args) -> "casadi::MX":
        """
        Add a named linear combination of output expressions.

        add_lc(self, str name, [str] f_out) -> MX





        """
        return _casadi.DaeBuilder_add_lc(self, *args)


    def create(self, *args) -> "casadi::Function":
        """
        Construct a function object.

        create(self, str fname, [str] s_in, [str] s_out) -> Function





        """
        return _casadi.DaeBuilder_create(self, *args)


    def __call__(self, *args) -> "casadi::MX":
        """


        __call__(self, str name) -> MX



        """
        return _casadi.DaeBuilder___call__(self, *args)


    def der(self, *args) -> "casadi::MX":
        """
          Get a derivative expression by non-differentiated expression.

          der(self, MX var) -> MX
          der(self, str name) -> MX
            Get a derivative expression by name.



        > der(self, str name)
        ------------------------------------------------------------------------


        Get a derivative expression by name.


        > der(self, MX var)
        ------------------------------------------------------------------------


        Get a derivative expression by non-differentiated expression.




        """
        return _casadi.DaeBuilder_der(self, *args)


    def nominal(self, *args) -> "std::vector< double,std::allocator< double > >":
        """
          Get the nominal value(s) by expression.

          nominal(self, MX var) -> [float]
          nominal(self, str name) -> float
            Get the nominal value by name.



        > nominal(self, MX var)
        ------------------------------------------------------------------------


        Get the nominal value(s) by expression.


        > nominal(self, str name)
        ------------------------------------------------------------------------


        Get the nominal value by name.




        """
        return _casadi.DaeBuilder_nominal(self, *args)


    def set_nominal(self, *args) -> "void":
        """
          Set the nominal value(s) by expression.

          set_nominal(self, MX var, [float] val)
          set_nominal(self, str name, float val)
            Set the nominal value by name.



        > set_nominal(self, MX var, [float] val)
        ------------------------------------------------------------------------


        Set the nominal value(s) by expression.


        > set_nominal(self, str name, float val)
        ------------------------------------------------------------------------


        Set the nominal value by name.




        """
        return _casadi.DaeBuilder_set_nominal(self, *args)


    def min(self, *args) -> "std::vector< double,std::allocator< double > >":
        """
          Get the lower bound(s) by expression.

          min(self, MX var, bool normalized) -> [float]
          min(self, str name, bool normalized) -> float
            Get the lower bound by name.



        > min(self, MX var, bool normalized)
        ------------------------------------------------------------------------


        Get the lower bound(s) by expression.


        > min(self, str name, bool normalized)
        ------------------------------------------------------------------------


        Get the lower bound by name.




        """
        return _casadi.DaeBuilder_min(self, *args)


    def set_min(self, *args) -> "void":
        """
          Set the lower bound(s) by expression.

          set_min(self, MX var, [float] val, bool normalized)
          set_min(self, str name, float val, bool normalized)
            Set the lower bound by name.



        > set_min(self, MX var, [float] val, bool normalized)
        ------------------------------------------------------------------------


        Set the lower bound(s) by expression.


        > set_min(self, str name, float val, bool normalized)
        ------------------------------------------------------------------------


        Set the lower bound by name.




        """
        return _casadi.DaeBuilder_set_min(self, *args)


    def max(self, *args) -> "std::vector< double,std::allocator< double > >":
        """
          Get the upper bound(s) by expression.

          max(self, MX var, bool normalized) -> [float]
          max(self, str name, bool normalized) -> float
            Get the upper bound by name.



        > max(self, MX var, bool normalized)
        ------------------------------------------------------------------------


        Get the upper bound(s) by expression.


        > max(self, str name, bool normalized)
        ------------------------------------------------------------------------


        Get the upper bound by name.




        """
        return _casadi.DaeBuilder_max(self, *args)


    def set_max(self, *args) -> "void":
        """
          Set the upper bound(s) by expression.

          set_max(self, MX var, [float] val, bool normalized)
          set_max(self, str name, float val, bool normalized)
            Set the upper bound by name.



        > set_max(self, MX var, [float] val, bool normalized)
        ------------------------------------------------------------------------


        Set the upper bound(s) by expression.


        > set_max(self, str name, float val, bool normalized)
        ------------------------------------------------------------------------


        Set the upper bound by name.




        """
        return _casadi.DaeBuilder_set_max(self, *args)


    def guess(self, *args) -> "std::vector< double,std::allocator< double > >":
        """
          Get the initial guess(es) by expression.

          guess(self, MX var, bool normalized) -> [float]
          guess(self, str name, bool normalized) -> float
            Get the initial guess by name.



        > guess(self, MX var, bool normalized)
        ------------------------------------------------------------------------


        Get the initial guess(es) by expression.


        > guess(self, str name, bool normalized)
        ------------------------------------------------------------------------


        Get the initial guess by name.




        """
        return _casadi.DaeBuilder_guess(self, *args)


    def set_guess(self, *args) -> "void":
        """
          Set the initial guess(es) by expression.

          set_guess(self, MX var, [float] val, bool normalized)
          set_guess(self, str name, float val, bool normalized)
            Set the initial guess by name.



        > set_guess(self, MX var, [float] val, bool normalized)
        ------------------------------------------------------------------------


        Set the initial guess(es) by expression.


        > set_guess(self, str name, float val, bool normalized)
        ------------------------------------------------------------------------


        Set the initial guess by name.




        """
        return _casadi.DaeBuilder_set_guess(self, *args)


    def start(self, *args) -> "std::vector< double,std::allocator< double > >":
        """
          Get the (optionally normalized) value(s) at time 0 by expression.

          start(self, MX var, bool normalized) -> [float]
          start(self, str name, bool normalized) -> float
            Get the (optionally normalized) value at time 0 by name.



        > start(self, MX var, bool normalized)
        ------------------------------------------------------------------------


        Get the (optionally normalized) value(s) at time 0 by expression.


        > start(self, str name, bool normalized)
        ------------------------------------------------------------------------


        Get the (optionally normalized) value at time 0 by name.




        """
        return _casadi.DaeBuilder_start(self, *args)


    def set_start(self, *args) -> "void":
        """
          Set the (optionally normalized) value(s) at time 0 by expression.

          set_start(self, MX var, [float] val, bool normalized)
          set_start(self, str name, float val, bool normalized)
            Set the (optionally normalized) value at time 0 by name.



        > set_start(self, MX var, [float] val, bool normalized)
        ------------------------------------------------------------------------


        Set the (optionally normalized) value(s) at time 0 by expression.


        > set_start(self, str name, float val, bool normalized)
        ------------------------------------------------------------------------


        Set the (optionally normalized) value at time 0 by name.




        """
        return _casadi.DaeBuilder_set_start(self, *args)


    def derivative_start(self, *args) -> "std::vector< double,std::allocator< double > >":
        """
          Get the (optionally normalized) derivative value(s) at time 0 by expression.

          derivative_start(self, MX var, bool normalized) -> [float]
          derivative_start(self, str name, bool normalized) -> float
            Get the (optionally normalized) derivative value at time 0 by name.



        > derivative_start(self, MX var, bool normalized)
        ------------------------------------------------------------------------


        Get the (optionally normalized) derivative value(s) at time 0 by expression.


        > derivative_start(self, str name, bool normalized)
        ------------------------------------------------------------------------


        Get the (optionally normalized) derivative value at time 0 by name.




        """
        return _casadi.DaeBuilder_derivative_start(self, *args)


    def set_derivative_start(self, *args) -> "void":
        """
          Set the (optionally normalized) derivative value(s) at time 0 by expression.

          set_derivative_start(self, MX var, [float] val, bool normalized)
          set_derivative_start(self, str name, float val, bool normalized)
            Set the (optionally normalized) derivative value at time 0 by name.



        > set_derivative_start(self, MX var, [float] val, bool normalized)
        ------------------------------------------------------------------------


        Set the (optionally normalized) derivative value(s) at time 0 by expression.


        > set_derivative_start(self, str name, float val, bool normalized)
        ------------------------------------------------------------------------


        Set the (optionally normalized) derivative value at time 0 by name.




        """
        return _casadi.DaeBuilder_set_derivative_start(self, *args)


    def unit(self, *args) -> "std::string":
        """
          Get the unit given a vector of symbolic variables (all units must be

          unit(self, MX var) -> str
          unit(self, str name) -> str
            Get the unit for a component.

        identical)


        > unit(self, MX var)
        ------------------------------------------------------------------------


        Get the unit given a vector of symbolic variables (all units must be
        identical)


        > unit(self, str name)
        ------------------------------------------------------------------------


        Get the unit for a component.




        """
        return _casadi.DaeBuilder_unit(self, *args)


    def set_unit(self, *args) -> "void":
        """
        Set the unit for a component.

        set_unit(self, str name, str val)





        """
        return _casadi.DaeBuilder_set_unit(self, *args)


    def add_variable(self, *args) -> "casadi::MX":
        """
          Add a new variable: returns corresponding symbolic expression.

          add_variable(self, str name, int n) -> MX
          add_variable(self, str name, Variable var)
            Add a variable.
          add_variable(self, str name, Sparsity sp) -> MX



        > add_variable(self, str name, Variable var)
        ------------------------------------------------------------------------


        Add a variable.


        > add_variable(self, str name, int n)
        > add_variable(self, str name, Sparsity sp)
        ------------------------------------------------------------------------


        Add a new variable: returns corresponding symbolic expression.




        """
        return _casadi.DaeBuilder_add_variable(self, *args)


    def variable(self, *args) -> "casadi::Variable const &":
        """
        Access a variable by name

        variable(self, str name) -> Variable
        variable(self, str name) -> Variable





        """
        return _casadi.DaeBuilder_variable(self, *args)


    def __init__(self, *args):
        """


          DaeBuilder()
            Default constructor.
          DaeBuilder(DaeBuilder other)

        > DaeBuilder(DaeBuilder other)
        ------------------------------------------------------------------------

        > DaeBuilder()
        ------------------------------------------------------------------------


        Default constructor.




        """
        this = _casadi.new_DaeBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _casadi.delete_DaeBuilder
DaeBuilder_swigregister = _casadi.DaeBuilder_swigregister
DaeBuilder_swigregister(DaeBuilder)

class XmlFile(SharedObject):
    """
      XML parser Can be used for parsing XML files into CasADi data structures.



    Joel Andersson

    C++ includes: xml_file.hpp 


    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XmlFile, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, XmlFile, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi.delete_XmlFile

    def load_plugin(*args) -> "void":
        """


        load_plugin(str name)



        """
        return _casadi.XmlFile_load_plugin(*args)

    load_plugin = staticmethod(load_plugin)

    def doc(*args) -> "std::string":
        """


        doc(str name) -> str



        """
        return _casadi.XmlFile_doc(*args)

    doc = staticmethod(doc)

    def __init__(self, *args):
        """


          XmlFile()
          XmlFile(XmlFile other)
          XmlFile(str name)

        > XmlFile(XmlFile other)
        ------------------------------------------------------------------------

        > XmlFile()
        > XmlFile(str name)
        ------------------------------------------------------------------------





        """
        this = _casadi.new_XmlFile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
XmlFile_swigregister = _casadi.XmlFile_swigregister
XmlFile_swigregister(XmlFile)

def XmlFile_load_plugin(*args) -> "void":
    """


    load_plugin(str name)



    """
    return _casadi.XmlFile_load_plugin(*args)

def XmlFile_doc(*args) -> "std::string":
    """


    doc(str name) -> str



    """
    return _casadi.XmlFile_doc(*args)

# This file is compatible with both classic and new-style classes.


