"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
import os


class AffectedHistory(TLObject):
    constructor_id = 0xb45c69d1
    subclass_of_id = 0x2c49c116

    def __init__(self, pts, pts_count, offset):
        """
        :param int pts:
        :param int pts_count:
        :param int offset:

        Constructor for messages.AffectedHistory: Instance of AffectedHistory.
        """
        super().__init__()

        self.pts = pts
        self.pts_count = pts_count
        self.offset = offset

    def to_dict(self, recursive=True):
        return {
            'pts': self.pts,
            'pts_count': self.pts_count,
            'offset': self.offset,
        }

    def on_send(self, writer):
        writer.write_int(AffectedHistory.constructor_id, signed=False)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)
        writer.write_int(self.offset)

    @staticmethod
    def empty():
        return AffectedHistory(None, None, None)

    def on_response(self, reader):
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()
        self.offset = reader.read_int()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class AffectedMessages(TLObject):
    constructor_id = 0x84d19185
    subclass_of_id = 0xced3c06e

    def __init__(self, pts, pts_count):
        """
        :param int pts:
        :param int pts_count:

        Constructor for messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()

        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(AffectedMessages.constructor_id, signed=False)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return AffectedMessages(None, None)

    def on_response(self, reader):
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class AllStickers(TLObject):
    constructor_id = 0xedfd405f
    subclass_of_id = 0x45834829

    def __init__(self, hash, sets):
        """
        :param int hash:
        :param list[TLObject] sets:

        Constructor for messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()

        self.hash = hash
        self.sets = sets

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'sets': ([] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]) if recursive else self.sets,
        }

    def on_send(self, writer):
        writer.write_int(AllStickers.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.sets))
        for _x in self.sets:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return AllStickers(None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.sets = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sets.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class AllStickersNotModified(TLObject):
    constructor_id = 0xe86602c3
    subclass_of_id = 0x45834829

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(AllStickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return AllStickersNotModified()

    def on_response(self, reader):
        pass

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ArchivedStickers(TLObject):
    constructor_id = 0x4fcba9c8
    subclass_of_id = 0x7296d771

    def __init__(self, count, sets):
        """
        :param int count:
        :param list[TLObject] sets:

        Constructor for messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        super().__init__()

        self.count = count
        self.sets = sets

    def to_dict(self, recursive=True):
        return {
            'count': self.count,
            'sets': ([] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]) if recursive else self.sets,
        }

    def on_send(self, writer):
        writer.write_int(ArchivedStickers.constructor_id, signed=False)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.sets))
        for _x in self.sets:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ArchivedStickers(None, None)

    def on_response(self, reader):
        self.count = reader.read_int()
        reader.read_int()
        self.sets = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sets.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotCallbackAnswer(TLObject):
    constructor_id = 0x36585ea4
    subclass_of_id = 0x6c4dd18c

    def __init__(self, cache_time, alert=None, has_url=None, message=None, url=None):
        """
        :param bool | None alert:
        :param bool | None has_url:
        :param str | None message:
        :param str | None url:
        :param int cache_time:

        Constructor for messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        super().__init__()

        self.alert = alert
        self.has_url = has_url
        self.message = message
        self.url = url
        self.cache_time = cache_time

    def to_dict(self, recursive=True):
        return {
            'alert': self.alert,
            'has_url': self.has_url,
            'message': self.message,
            'url': self.url,
            'cache_time': self.cache_time,
        }

    def on_send(self, writer):
        writer.write_int(BotCallbackAnswer.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.alert else 0
        flags |= (1 << 3) if self.has_url else 0
        flags |= (1 << 0) if self.message else 0
        flags |= (1 << 2) if self.url else 0
        writer.write_int(flags)

        if self.message:
            writer.tgwrite_string(self.message)

        if self.url:
            writer.tgwrite_string(self.url)

        writer.write_int(self.cache_time)

    @staticmethod
    def empty():
        return BotCallbackAnswer(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.alert = True

        if (flags & (1 << 3)) != 0:
            self.has_url = True

        if (flags & (1 << 0)) != 0:
            self.message = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.url = reader.tgread_string()

        self.cache_time = reader.read_int()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotResults(TLObject):
    constructor_id = 0xccd3563d
    subclass_of_id = 0x3ed4d9c9

    def __init__(self, query_id, results, cache_time, gallery=None, next_offset=None, switch_pm=None):
        """
        :param bool | None gallery:
        :param int query_id:
        :param str | None next_offset:
        :param TLObject | None switch_pm:
        :param list[TLObject] results:
        :param int cache_time:

        Constructor for messages.BotResults: Instance of BotResults.
        """
        super().__init__()

        self.gallery = gallery
        self.query_id = query_id
        self.next_offset = next_offset
        self.switch_pm = switch_pm
        self.results = results
        self.cache_time = cache_time

    def to_dict(self, recursive=True):
        return {
            'gallery': self.gallery,
            'query_id': self.query_id,
            'next_offset': self.next_offset,
            'switch_pm': (None if self.switch_pm is None else self.switch_pm.to_dict()) if recursive else self.switch_pm,
            'results': ([] if self.results is None else [None if x is None else x.to_dict() for x in self.results]) if recursive else self.results,
            'cache_time': self.cache_time,
        }

    def on_send(self, writer):
        writer.write_int(BotResults.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.gallery else 0
        flags |= (1 << 1) if self.next_offset else 0
        flags |= (1 << 2) if self.switch_pm else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        if self.next_offset:
            writer.tgwrite_string(self.next_offset)

        if self.switch_pm:
            self.switch_pm.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.results))
        for _x in self.results:
            _x.on_send(writer)

        writer.write_int(self.cache_time)

    @staticmethod
    def empty():
        return BotResults(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.gallery = True

        self.query_id = reader.read_long()
        if (flags & (1 << 1)) != 0:
            self.next_offset = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.switch_pm = reader.tgread_object()

        reader.read_int()
        self.results = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.results.append(_x)

        self.cache_time = reader.read_int()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelMessages(TLObject):
    constructor_id = 0x99262e37
    subclass_of_id = 0xd4b40b5e

    def __init__(self, pts, count, messages, chats, users):
        """
        :param int pts:
        :param int count:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.pts = pts
        self.count = count
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'pts': self.pts,
            'count': self.count,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def on_send(self, writer):
        writer.write_int(ChannelMessages.constructor_id, signed=False)
        flags = 0
        writer.write_int(flags)

        writer.write_int(self.pts)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ChannelMessages(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.pts = reader.read_int()
        self.count = reader.read_int()
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatFull(TLObject):
    constructor_id = 0xe5d7d19c
    subclass_of_id = 0x225a5109

    def __init__(self, full_chat, chats, users):
        """
        :param TLObject full_chat:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.ChatFull: Instance of ChatFull.
        """
        super().__init__()

        self.full_chat = full_chat
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'full_chat': (None if self.full_chat is None else self.full_chat.to_dict()) if recursive else self.full_chat,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def on_send(self, writer):
        writer.write_int(ChatFull.constructor_id, signed=False)
        self.full_chat.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ChatFull(None, None, None)

    def on_response(self, reader):
        self.full_chat = reader.tgread_object()
        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Chats(TLObject):
    constructor_id = 0x64ff9fd5
    subclass_of_id = 0x99d5cb14

    def __init__(self, chats):
        """
        :param list[TLObject] chats:

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()

        self.chats = chats

    def to_dict(self, recursive=True):
        return {
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
        }

    def on_send(self, writer):
        writer.write_int(Chats.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Chats(None)

    def on_response(self, reader):
        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatsSlice(TLObject):
    constructor_id = 0x9cd81144
    subclass_of_id = 0x99d5cb14

    def __init__(self, count, chats):
        """
        :param int count:
        :param list[TLObject] chats:

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()

        self.count = count
        self.chats = chats

    def to_dict(self, recursive=True):
        return {
            'count': self.count,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
        }

    def on_send(self, writer):
        writer.write_int(ChatsSlice.constructor_id, signed=False)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ChatsSlice(None, None)

    def on_response(self, reader):
        self.count = reader.read_int()
        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DhConfig(TLObject):
    constructor_id = 0x2c221edd
    subclass_of_id = 0xe488ed8b

    def __init__(self, g, p, version, random):
        """
        :param int g:
        :param bytes p:
        :param int version:
        :param bytes random:

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()

        self.g = g
        self.p = p
        self.version = version
        self.random = random

    def to_dict(self, recursive=True):
        return {
            'g': self.g,
            'p': self.p,
            'version': self.version,
            'random': self.random,
        }

    def on_send(self, writer):
        writer.write_int(DhConfig.constructor_id, signed=False)
        writer.write_int(self.g)
        writer.tgwrite_bytes(self.p)
        writer.write_int(self.version)
        writer.tgwrite_bytes(self.random)

    @staticmethod
    def empty():
        return DhConfig(None, None, None, None)

    def on_response(self, reader):
        self.g = reader.read_int()
        self.p = reader.tgread_bytes()
        self.version = reader.read_int()
        self.random = reader.tgread_bytes()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DhConfigNotModified(TLObject):
    constructor_id = 0xc0e24635
    subclass_of_id = 0xe488ed8b

    def __init__(self, random):
        """
        :param bytes random:

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()

        self.random = random

    def to_dict(self, recursive=True):
        return {
            'random': self.random,
        }

    def on_send(self, writer):
        writer.write_int(DhConfigNotModified.constructor_id, signed=False)
        writer.tgwrite_bytes(self.random)

    @staticmethod
    def empty():
        return DhConfigNotModified(None)

    def on_response(self, reader):
        self.random = reader.tgread_bytes()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Dialogs(TLObject):
    constructor_id = 0x15ba6c40
    subclass_of_id = 0xe1b52ee

    def __init__(self, dialogs, messages, chats, users):
        """
        :param list[TLObject] dialogs:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()

        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'dialogs': ([] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs]) if recursive else self.dialogs,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def on_send(self, writer):
        writer.write_int(Dialogs.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.dialogs))
        for _x in self.dialogs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Dialogs(None, None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.dialogs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.dialogs.append(_x)

        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DialogsSlice(TLObject):
    constructor_id = 0x71e094f3
    subclass_of_id = 0xe1b52ee

    def __init__(self, count, dialogs, messages, chats, users):
        """
        :param int count:
        :param list[TLObject] dialogs:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()

        self.count = count
        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'count': self.count,
            'dialogs': ([] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs]) if recursive else self.dialogs,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def on_send(self, writer):
        writer.write_int(DialogsSlice.constructor_id, signed=False)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.dialogs))
        for _x in self.dialogs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return DialogsSlice(None, None, None, None, None)

    def on_response(self, reader):
        self.count = reader.read_int()
        reader.read_int()
        self.dialogs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.dialogs.append(_x)

        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FavedStickers(TLObject):
    constructor_id = 0xf37f2f16
    subclass_of_id = 0x8e736fb9

    def __init__(self, hash, packs, stickers):
        """
        :param int hash:
        :param list[TLObject] packs:
        :param list[TLObject] stickers:

        Constructor for messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        super().__init__()

        self.hash = hash
        self.packs = packs
        self.stickers = stickers

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'packs': ([] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs]) if recursive else self.packs,
            'stickers': ([] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]) if recursive else self.stickers,
        }

    def on_send(self, writer):
        writer.write_int(FavedStickers.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.packs))
        for _x in self.packs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.stickers))
        for _x in self.stickers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return FavedStickers(None, None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.packs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.packs.append(_x)

        reader.read_int()
        self.stickers = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.stickers.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FavedStickersNotModified(TLObject):
    constructor_id = 0x9e8fa6d3
    subclass_of_id = 0x8e736fb9

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(FavedStickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return FavedStickersNotModified()

    def on_response(self, reader):
        pass

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FeaturedStickers(TLObject):
    constructor_id = 0xf89d88e5
    subclass_of_id = 0x2614b722

    def __init__(self, hash, sets, unread):
        """
        :param int hash:
        :param list[TLObject] sets:
        :param list[int] unread:

        Constructor for messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        super().__init__()

        self.hash = hash
        self.sets = sets
        self.unread = unread

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'sets': ([] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]) if recursive else self.sets,
            'unread': [] if self.unread is None else self.unread[:],
        }

    def on_send(self, writer):
        writer.write_int(FeaturedStickers.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.sets))
        for _x in self.sets:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.unread))
        for _x in self.unread:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return FeaturedStickers(None, None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.sets = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sets.append(_x)

        reader.read_int()
        self.unread = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.unread.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FeaturedStickersNotModified(TLObject):
    constructor_id = 0x4ede3cf
    subclass_of_id = 0x2614b722

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(FeaturedStickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return FeaturedStickersNotModified()

    def on_response(self, reader):
        pass

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FoundGifs(TLObject):
    constructor_id = 0x450a1c0a
    subclass_of_id = 0xe799ea7

    def __init__(self, next_offset, results):
        """
        :param int next_offset:
        :param list[TLObject] results:

        Constructor for messages.FoundGifs: Instance of FoundGifs.
        """
        super().__init__()

        self.next_offset = next_offset
        self.results = results

    def to_dict(self, recursive=True):
        return {
            'next_offset': self.next_offset,
            'results': ([] if self.results is None else [None if x is None else x.to_dict() for x in self.results]) if recursive else self.results,
        }

    def on_send(self, writer):
        writer.write_int(FoundGifs.constructor_id, signed=False)
        writer.write_int(self.next_offset)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.results))
        for _x in self.results:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return FoundGifs(None, None)

    def on_response(self, reader):
        self.next_offset = reader.read_int()
        reader.read_int()
        self.results = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.results.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class HighScores(TLObject):
    constructor_id = 0x9a3bfd99
    subclass_of_id = 0x6ccd95fd

    def __init__(self, scores, users):
        """
        :param list[TLObject] scores:
        :param list[TLObject] users:

        Constructor for messages.HighScores: Instance of HighScores.
        """
        super().__init__()

        self.scores = scores
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'scores': ([] if self.scores is None else [None if x is None else x.to_dict() for x in self.scores]) if recursive else self.scores,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def on_send(self, writer):
        writer.write_int(HighScores.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.scores))
        for _x in self.scores:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return HighScores(None, None)

    def on_response(self, reader):
        reader.read_int()
        self.scores = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.scores.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEditData(TLObject):
    constructor_id = 0x26b5dde6
    subclass_of_id = 0xfb47949d

    def __init__(self, caption=None):
        """
        :param bool | None caption:

        Constructor for messages.MessageEditData: Instance of MessageEditData.
        """
        super().__init__()

        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'caption': self.caption,
        }

    def on_send(self, writer):
        writer.write_int(MessageEditData.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.caption else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return MessageEditData(None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.caption = True

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Messages(TLObject):
    constructor_id = 0x8c718e87
    subclass_of_id = 0xd4b40b5e

    def __init__(self, messages, chats, users):
        """
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def on_send(self, writer):
        writer.write_int(Messages.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Messages(None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessagesSlice(TLObject):
    constructor_id = 0xb446ae3
    subclass_of_id = 0xd4b40b5e

    def __init__(self, count, messages, chats, users):
        """
        :param int count:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.count = count
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'count': self.count,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def on_send(self, writer):
        writer.write_int(MessagesSlice.constructor_id, signed=False)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return MessagesSlice(None, None, None, None)

    def on_response(self, reader):
        self.count = reader.read_int()
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerDialogs(TLObject):
    constructor_id = 0x3371c354
    subclass_of_id = 0x3ac70132

    def __init__(self, dialogs, messages, chats, users, state):
        """
        :param list[TLObject] dialogs:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:
        :param TLObject state:

        Constructor for messages.PeerDialogs: Instance of PeerDialogs.
        """
        super().__init__()

        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users
        self.state = state

    def to_dict(self, recursive=True):
        return {
            'dialogs': ([] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs]) if recursive else self.dialogs,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
            'state': (None if self.state is None else self.state.to_dict()) if recursive else self.state,
        }

    def on_send(self, writer):
        writer.write_int(PeerDialogs.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.dialogs))
        for _x in self.dialogs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

        self.state.on_send(writer)

    @staticmethod
    def empty():
        return PeerDialogs(None, None, None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.dialogs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.dialogs.append(_x)

        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

        self.state = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RecentStickers(TLObject):
    constructor_id = 0x5ce20970
    subclass_of_id = 0xf76f8683

    def __init__(self, hash, stickers):
        """
        :param int hash:
        :param list[TLObject] stickers:

        Constructor for messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        super().__init__()

        self.hash = hash
        self.stickers = stickers

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'stickers': ([] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]) if recursive else self.stickers,
        }

    def on_send(self, writer):
        writer.write_int(RecentStickers.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.stickers))
        for _x in self.stickers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return RecentStickers(None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.stickers = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.stickers.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RecentStickersNotModified(TLObject):
    constructor_id = 0xb17f890
    subclass_of_id = 0xf76f8683

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(RecentStickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return RecentStickersNotModified()

    def on_response(self, reader):
        pass

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SavedGifs(TLObject):
    constructor_id = 0x2e0709a5
    subclass_of_id = 0xa68b61f5

    def __init__(self, hash, gifs):
        """
        :param int hash:
        :param list[TLObject] gifs:

        Constructor for messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        super().__init__()

        self.hash = hash
        self.gifs = gifs

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'gifs': ([] if self.gifs is None else [None if x is None else x.to_dict() for x in self.gifs]) if recursive else self.gifs,
        }

    def on_send(self, writer):
        writer.write_int(SavedGifs.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.gifs))
        for _x in self.gifs:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return SavedGifs(None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.gifs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.gifs.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SavedGifsNotModified(TLObject):
    constructor_id = 0xe8025ca2
    subclass_of_id = 0xa68b61f5

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(SavedGifsNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SavedGifsNotModified()

    def on_response(self, reader):
        pass

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SentEncryptedFile(TLObject):
    constructor_id = 0x9493ff32
    subclass_of_id = 0xc99e3e50

    def __init__(self, date, file):
        """
        :param datetime.datetime date:
        :param TLObject file:

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()

        self.date = date
        self.file = file

    def to_dict(self, recursive=True):
        return {
            'date': self.date,
            'file': (None if self.file is None else self.file.to_dict()) if recursive else self.file,
        }

    def on_send(self, writer):
        writer.write_int(SentEncryptedFile.constructor_id, signed=False)
        writer.tgwrite_date(self.date)
        self.file.on_send(writer)

    @staticmethod
    def empty():
        return SentEncryptedFile(None, None)

    def on_response(self, reader):
        self.date = reader.tgread_date()
        self.file = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SentEncryptedMessage(TLObject):
    constructor_id = 0x560f8935
    subclass_of_id = 0xc99e3e50

    def __init__(self, date):
        """
        :param datetime.datetime date:

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()

        self.date = date

    def to_dict(self, recursive=True):
        return {
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(SentEncryptedMessage.constructor_id, signed=False)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return SentEncryptedMessage(None)

    def on_response(self, reader):
        self.date = reader.tgread_date()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSet(TLObject):
    constructor_id = 0xb60a24a6
    subclass_of_id = 0x9b704a5a

    def __init__(self, set, packs, documents):
        """
        :param TLObject set:
        :param list[TLObject] packs:
        :param list[TLObject] documents:

        Constructor for messages.StickerSet: Instance of StickerSet.
        """
        super().__init__()

        self.set = set
        self.packs = packs
        self.documents = documents

    def to_dict(self, recursive=True):
        return {
            'set': (None if self.set is None else self.set.to_dict()) if recursive else self.set,
            'packs': ([] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs]) if recursive else self.packs,
            'documents': ([] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]) if recursive else self.documents,
        }

    def on_send(self, writer):
        writer.write_int(StickerSet.constructor_id, signed=False)
        self.set.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.packs))
        for _x in self.packs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.documents))
        for _x in self.documents:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return StickerSet(None, None, None)

    def on_response(self, reader):
        self.set = reader.tgread_object()
        reader.read_int()
        self.packs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.packs.append(_x)

        reader.read_int()
        self.documents = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.documents.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSetInstallResultArchive(TLObject):
    constructor_id = 0x35e410a8
    subclass_of_id = 0x67cb3fe8

    def __init__(self, sets):
        """
        :param list[TLObject] sets:

        Constructor for messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        super().__init__()

        self.sets = sets

    def to_dict(self, recursive=True):
        return {
            'sets': ([] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]) if recursive else self.sets,
        }

    def on_send(self, writer):
        writer.write_int(StickerSetInstallResultArchive.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.sets))
        for _x in self.sets:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return StickerSetInstallResultArchive(None)

    def on_response(self, reader):
        reader.read_int()
        self.sets = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sets.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSetInstallResultSuccess(TLObject):
    constructor_id = 0x38641628
    subclass_of_id = 0x67cb3fe8

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(StickerSetInstallResultSuccess.constructor_id, signed=False)

    @staticmethod
    def empty():
        return StickerSetInstallResultSuccess()

    def on_response(self, reader):
        pass

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Stickers(TLObject):
    constructor_id = 0x8a8ecd32
    subclass_of_id = 0xd73bb9de

    def __init__(self, hash, stickers):
        """
        :param str hash:
        :param list[TLObject] stickers:

        Constructor for messages.Stickers: Instance of either StickersNotModified, Stickers.
        """
        super().__init__()

        self.hash = hash
        self.stickers = stickers

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'stickers': ([] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]) if recursive else self.stickers,
        }

    def on_send(self, writer):
        writer.write_int(Stickers.constructor_id, signed=False)
        writer.tgwrite_string(self.hash)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.stickers))
        for _x in self.stickers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Stickers(None, None)

    def on_response(self, reader):
        self.hash = reader.tgread_string()
        reader.read_int()
        self.stickers = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.stickers.append(_x)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickersNotModified(TLObject):
    constructor_id = 0xf1749a22
    subclass_of_id = 0xd73bb9de

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(StickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return StickersNotModified()

    def on_response(self, reader):
        pass

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
