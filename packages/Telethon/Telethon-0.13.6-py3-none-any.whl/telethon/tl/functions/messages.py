"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
import os


class AcceptEncryptionRequest(TLObject):
    constructor_id = 0x3dbc0415
    subclass_of_id = 0x6d28a37a

    def __init__(self, peer, g_b, key_fingerprint):
        """
        :param TLObject peer:
        :param bytes g_b:
        :param int key_fingerprint:

        :returns EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.g_b = g_b
        self.key_fingerprint = key_fingerprint

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'g_b': self.g_b,
            'key_fingerprint': self.key_fingerprint,
        }

    def on_send(self, writer):
        writer.write_int(AcceptEncryptionRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.tgwrite_bytes(self.g_b)
        writer.write_long(self.key_fingerprint)

    @staticmethod
    def empty():
        return AcceptEncryptionRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user


class AddChatUserRequest(TLObject):
    constructor_id = 0xf9a0aa09
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, user_id, fwd_limit):
        """
        :param int chat_id:
        :param TLObject user_id:
        :param int fwd_limit:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)
        self.fwd_limit = fwd_limit

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'fwd_limit': self.fwd_limit,
        }

    def on_send(self, writer):
        writer.write_int(AddChatUserRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        self.user_id.on_send(writer)
        writer.write_int(self.fwd_limit)

    @staticmethod
    def empty():
        return AddChatUserRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class CheckChatInviteRequest(TLObject):
    constructor_id = 0x3eadb1bb
    subclass_of_id = 0x4561736

    def __init__(self, hash):
        """
        :param str hash:

        :returns ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(CheckChatInviteRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.hash)

    @staticmethod
    def empty():
        return CheckChatInviteRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ClearRecentStickersRequest(TLObject):
    constructor_id = 0x8999602d
    subclass_of_id = 0xf5b399ac

    def __init__(self, attached=None):
        """
        :param bool | None attached:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached

    def to_dict(self, recursive=True):
        return {
            'attached': self.attached,
        }

    def on_send(self, writer):
        writer.write_int(ClearRecentStickersRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.attached else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return ClearRecentStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user


class CreateChatRequest(TLObject):
    constructor_id = 0x9cb126e
    subclass_of_id = 0x8af52aac

    def __init__(self, users, title):
        """
        :param list[TLObject] users:
        :param str title:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.users = [get_input_user(_x) for _x in users]
        self.title = title

    def to_dict(self, recursive=True):
        return {
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
            'title': self.title,
        }

    def on_send(self, writer):
        writer.write_int(CreateChatRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

        writer.tgwrite_string(self.title)

    @staticmethod
    def empty():
        return CreateChatRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user


class DeleteChatUserRequest(TLObject):
    constructor_id = 0xe0611f16
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, user_id):
        """
        :param int chat_id:
        :param TLObject user_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(DeleteChatUserRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        self.user_id.on_send(writer)

    @staticmethod
    def empty():
        return DeleteChatUserRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class DeleteHistoryRequest(TLObject):
    constructor_id = 0x1c015b09
    subclass_of_id = 0x2c49c116

    def __init__(self, peer, max_id, just_clear=None):
        """
        :param bool | None just_clear:
        :param TLObject peer:
        :param int max_id:

        :returns messages.AffectedHistory: Instance of AffectedHistory.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.just_clear = just_clear
        self.peer = get_input_peer(peer)
        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'just_clear': self.just_clear,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(DeleteHistoryRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.just_clear else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return DeleteHistoryRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DeleteMessagesRequest(TLObject):
    constructor_id = 0xe58e95d2
    subclass_of_id = 0xced3c06e

    def __init__(self, id, revoke=None):
        """
        :param bool | None revoke:
        :param list[int] id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.revoke = revoke
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'revoke': self.revoke,
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(DeleteMessagesRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.revoke else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return DeleteMessagesRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DiscardEncryptionRequest(TLObject):
    constructor_id = 0xedd923c5
    subclass_of_id = 0xf5b399ac

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(DiscardEncryptionRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return DiscardEncryptionRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user


class EditChatAdminRequest(TLObject):
    constructor_id = 0xa9e69f2e
    subclass_of_id = 0xf5b399ac

    def __init__(self, chat_id, user_id, is_admin):
        """
        :param int chat_id:
        :param TLObject user_id:
        :param TLObject is_admin:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)
        self.is_admin = is_admin

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'is_admin': self.is_admin,
        }

    def on_send(self, writer):
        writer.write_int(EditChatAdminRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        self.user_id.on_send(writer)
        writer.tgwrite_bool(self.is_admin)

    @staticmethod
    def empty():
        return EditChatAdminRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditChatPhotoRequest(TLObject):
    constructor_id = 0xca4c79d8
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, photo):
        """
        :param int chat_id:
        :param TLObject photo:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.photo = photo

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
        }

    def on_send(self, writer):
        writer.write_int(EditChatPhotoRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        self.photo.on_send(writer)

    @staticmethod
    def empty():
        return EditChatPhotoRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditChatTitleRequest(TLObject):
    constructor_id = 0xdc452855
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, title):
        """
        :param int chat_id:
        :param str title:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.title = title

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'title': self.title,
        }

    def on_send(self, writer):
        writer.write_int(EditChatTitleRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.tgwrite_string(self.title)

    @staticmethod
    def empty():
        return EditChatTitleRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditInlineBotMessageRequest(TLObject):
    constructor_id = 0x130c2c85
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, no_webpage=None, message=None, reply_markup=None, entities=None):
        """
        :param bool | None no_webpage:
        :param TLObject id:
        :param str | None message:
        :param TLObject | None reply_markup:
        :param list[TLObject] | None entities:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.id = id
        self.message = message
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'message': self.message,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def on_send(self, writer):
        writer.write_int(EditInlineBotMessageRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 11) if self.message else 0
        flags |= (1 << 2) if self.reply_markup else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        self.id.on_send(writer)
        if self.message:
            writer.tgwrite_string(self.message)

        if self.reply_markup:
            self.reply_markup.on_send(writer)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return EditInlineBotMessageRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class EditMessageRequest(TLObject):
    constructor_id = 0xce91e4ca
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, id, no_webpage=None, message=None, reply_markup=None, entities=None):
        """
        :param bool | None no_webpage:
        :param TLObject peer:
        :param int id:
        :param str | None message:
        :param TLObject | None reply_markup:
        :param list[TLObject] | None entities:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.peer = get_input_peer(peer)
        self.id = id
        self.message = message
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
            'message': self.message,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def on_send(self, writer):
        writer.write_int(EditMessageRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 11) if self.message else 0
        flags |= (1 << 2) if self.reply_markup else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.id)
        if self.message:
            writer.tgwrite_string(self.message)

        if self.reply_markup:
            self.reply_markup.on_send(writer)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return EditMessageRequest(None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ExportChatInviteRequest(TLObject):
    constructor_id = 0x7d885289
    subclass_of_id = 0xb4748a58

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(ExportChatInviteRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return ExportChatInviteRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FaveStickerRequest(TLObject):
    constructor_id = 0xb9ffc55b
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, unfave):
        """
        :param TLObject id:
        :param TLObject unfave:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.unfave = unfave

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'unfave': self.unfave,
        }

    def on_send(self, writer):
        writer.write_int(FaveStickerRequest.constructor_id, signed=False)
        self.id.on_send(writer)
        writer.tgwrite_bool(self.unfave)

    @staticmethod
    def empty():
        return FaveStickerRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class ForwardMessageRequest(TLObject):
    constructor_id = 0x33963bf9
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, id, random_id=None):
        """
        :param TLObject peer:
        :param int id:
        :param int random_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
            'random_id': self.random_id,
        }

    def on_send(self, writer):
        writer.write_int(ForwardMessageRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.id)
        writer.write_long(self.random_id)

    @staticmethod
    def empty():
        return ForwardMessageRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class ForwardMessagesRequest(TLObject):
    constructor_id = 0x708e0195
    subclass_of_id = 0x8af52aac

    def __init__(self, from_peer, id, to_peer, silent=None, background=None, with_my_score=None, random_id=None):
        """
        :param bool | None silent:
        :param bool | None background:
        :param bool | None with_my_score:
        :param TLObject from_peer:
        :param list[int] id:
        :param list[int] random_id:
        :param TLObject to_peer:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.with_my_score = with_my_score
        self.from_peer = get_input_peer(from_peer)
        self.id = id
        self.random_id = random_id if random_id is not None else [int.from_bytes(os.urandom(8), 'big', signed=True) for _ in range(len(id))]
        self.to_peer = get_input_peer(to_peer)

    def to_dict(self, recursive=True):
        return {
            'silent': self.silent,
            'background': self.background,
            'with_my_score': self.with_my_score,
            'from_peer': (None if self.from_peer is None else self.from_peer.to_dict()) if recursive else self.from_peer,
            'id': [] if self.id is None else self.id[:],
            'random_id': [] if self.random_id is None else self.random_id[:],
            'to_peer': (None if self.to_peer is None else self.to_peer.to_dict()) if recursive else self.to_peer,
        }

    def on_send(self, writer):
        writer.write_int(ForwardMessagesRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 5) if self.silent else 0
        flags |= (1 << 6) if self.background else 0
        flags |= (1 << 8) if self.with_my_score else 0
        writer.write_int(flags)

        self.from_peer.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.random_id))
        for _x in self.random_id:
            writer.write_long(_x)

        self.to_peer.on_send(writer)

    @staticmethod
    def empty():
        return ForwardMessagesRequest(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAllChatsRequest(TLObject):
    constructor_id = 0xeba80ff0
    subclass_of_id = 0x99d5cb14

    def __init__(self, except_ids):
        """
        :param list[int] except_ids:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.except_ids = except_ids

    def to_dict(self, recursive=True):
        return {
            'except_ids': [] if self.except_ids is None else self.except_ids[:],
        }

    def on_send(self, writer):
        writer.write_int(GetAllChatsRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.except_ids))
        for _x in self.except_ids:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return GetAllChatsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAllDraftsRequest(TLObject):
    constructor_id = 0x6a3f8d65
    subclass_of_id = 0x8af52aac

    def __init__(self):
        super().__init__()
        self.result = None
        self.content_related = True

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(GetAllDraftsRequest.constructor_id, signed=False)

    @staticmethod
    def empty():
        return GetAllDraftsRequest()

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAllStickersRequest(TLObject):
    constructor_id = 0x1c9618b1
    subclass_of_id = 0x45834829

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetAllStickersRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetAllStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetArchivedStickersRequest(TLObject):
    constructor_id = 0x57f17692
    subclass_of_id = 0x7296d771

    def __init__(self, offset_id, limit, masks=None):
        """
        :param bool | None masks:
        :param int offset_id:
        :param int limit:

        :returns messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.masks = masks
        self.offset_id = offset_id
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'masks': self.masks,
            'offset_id': self.offset_id,
            'limit': self.limit,
        }

    def on_send(self, writer):
        writer.write_int(GetArchivedStickersRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.masks else 0
        writer.write_int(flags)

        writer.write_long(self.offset_id)
        writer.write_int(self.limit)

    @staticmethod
    def empty():
        return GetArchivedStickersRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAttachedStickersRequest(TLObject):
    constructor_id = 0xcc5b67cc
    subclass_of_id = 0xcc125f6b

    def __init__(self, media):
        """
        :param TLObject media:

        :returns Vector<StickerSetCovered>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.media = media

    def to_dict(self, recursive=True):
        return {
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
        }

    def on_send(self, writer):
        writer.write_int(GetAttachedStickersRequest.constructor_id, signed=False)
        self.media.on_send(writer)

    @staticmethod
    def empty():
        return GetAttachedStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_vector()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class GetBotCallbackAnswerRequest(TLObject):
    constructor_id = 0x810a9fec
    subclass_of_id = 0x6c4dd18c

    def __init__(self, peer, msg_id, game=None, data=None):
        """
        :param bool | None game:
        :param TLObject peer:
        :param int msg_id:
        :param bytes | None data:

        :returns messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.game = game
        self.peer = get_input_peer(peer)
        self.msg_id = msg_id
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'game': self.game,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'msg_id': self.msg_id,
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(GetBotCallbackAnswerRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.game else 0
        flags |= (1 << 0) if self.data else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.msg_id)
        if self.data:
            writer.tgwrite_bytes(self.data)

    @staticmethod
    def empty():
        return GetBotCallbackAnswerRequest(None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetChatsRequest(TLObject):
    constructor_id = 0x3c6aa187
    subclass_of_id = 0x99d5cb14

    def __init__(self, id):
        """
        :param list[int] id:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(GetChatsRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return GetChatsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user


class GetCommonChatsRequest(TLObject):
    constructor_id = 0xd0a48c4
    subclass_of_id = 0x99d5cb14

    def __init__(self, user_id, max_id, limit):
        """
        :param TLObject user_id:
        :param int max_id:
        :param int limit:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.user_id = get_input_user(user_id)
        self.max_id = max_id
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'max_id': self.max_id,
            'limit': self.limit,
        }

    def on_send(self, writer):
        writer.write_int(GetCommonChatsRequest.constructor_id, signed=False)
        self.user_id.on_send(writer)
        writer.write_int(self.max_id)
        writer.write_int(self.limit)

    @staticmethod
    def empty():
        return GetCommonChatsRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetDhConfigRequest(TLObject):
    constructor_id = 0x26cf8950
    subclass_of_id = 0xe488ed8b

    def __init__(self, version, random_length):
        """
        :param int version:
        :param int random_length:

        :returns messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.version = version
        self.random_length = random_length

    def to_dict(self, recursive=True):
        return {
            'version': self.version,
            'random_length': self.random_length,
        }

    def on_send(self, writer):
        writer.write_int(GetDhConfigRequest.constructor_id, signed=False)
        writer.write_int(self.version)
        writer.write_int(self.random_length)

    @staticmethod
    def empty():
        return GetDhConfigRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class GetDialogsRequest(TLObject):
    constructor_id = 0x191ba9c5
    subclass_of_id = 0xe1b52ee

    def __init__(self, offset_date, offset_id, offset_peer, limit, exclude_pinned=None):
        """
        :param bool | None exclude_pinned:
        :param datetime.datetime offset_date:
        :param int offset_id:
        :param TLObject offset_peer:
        :param int limit:

        :returns messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.exclude_pinned = exclude_pinned
        self.offset_date = offset_date
        self.offset_id = offset_id
        self.offset_peer = get_input_peer(offset_peer)
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'exclude_pinned': self.exclude_pinned,
            'offset_date': self.offset_date,
            'offset_id': self.offset_id,
            'offset_peer': (None if self.offset_peer is None else self.offset_peer.to_dict()) if recursive else self.offset_peer,
            'limit': self.limit,
        }

    def on_send(self, writer):
        writer.write_int(GetDialogsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.exclude_pinned else 0
        writer.write_int(flags)

        writer.tgwrite_date(self.offset_date)
        writer.write_int(self.offset_id)
        self.offset_peer.on_send(writer)
        writer.write_int(self.limit)

    @staticmethod
    def empty():
        return GetDialogsRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetDocumentByHashRequest(TLObject):
    constructor_id = 0x338e2464
    subclass_of_id = 0x211fe820

    def __init__(self, sha256, size, mime_type):
        """
        :param bytes sha256:
        :param int size:
        :param str mime_type:

        :returns Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.sha256 = sha256
        self.size = size
        self.mime_type = mime_type

    def to_dict(self, recursive=True):
        return {
            'sha256': self.sha256,
            'size': self.size,
            'mime_type': self.mime_type,
        }

    def on_send(self, writer):
        writer.write_int(GetDocumentByHashRequest.constructor_id, signed=False)
        writer.tgwrite_bytes(self.sha256)
        writer.write_int(self.size)
        writer.tgwrite_string(self.mime_type)

    @staticmethod
    def empty():
        return GetDocumentByHashRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetFavedStickersRequest(TLObject):
    constructor_id = 0x21ce0b0e
    subclass_of_id = 0x8e736fb9

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetFavedStickersRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetFavedStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetFeaturedStickersRequest(TLObject):
    constructor_id = 0x2dacca4f
    subclass_of_id = 0x2614b722

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetFeaturedStickersRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetFeaturedStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetFullChatRequest(TLObject):
    constructor_id = 0x3b831c66
    subclass_of_id = 0x225a5109

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns messages.ChatFull: Instance of ChatFull.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(GetFullChatRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return GetFullChatRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user, get_input_peer


class GetGameHighScoresRequest(TLObject):
    constructor_id = 0xe822649d
    subclass_of_id = 0x6ccd95fd

    def __init__(self, peer, id, user_id):
        """
        :param TLObject peer:
        :param int id:
        :param TLObject user_id:

        :returns messages.HighScores: Instance of HighScores.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.user_id = get_input_user(user_id)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(GetGameHighScoresRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.id)
        self.user_id.on_send(writer)

    @staticmethod
    def empty():
        return GetGameHighScoresRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class GetHistoryRequest(TLObject):
    constructor_id = 0xafa92846
    subclass_of_id = 0xd4b40b5e

    def __init__(self, peer, offset_id, offset_date, add_offset, limit, max_id, min_id):
        """
        :param TLObject peer:
        :param int offset_id:
        :param datetime.datetime offset_date:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.offset_id = offset_id
        self.offset_date = offset_date
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'offset_id': self.offset_id,
            'offset_date': self.offset_date,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def on_send(self, writer):
        writer.write_int(GetHistoryRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.offset_id)
        writer.tgwrite_date(self.offset_date)
        writer.write_int(self.add_offset)
        writer.write_int(self.limit)
        writer.write_int(self.max_id)
        writer.write_int(self.min_id)

    @staticmethod
    def empty():
        return GetHistoryRequest(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer, get_input_user


class GetInlineBotResultsRequest(TLObject):
    constructor_id = 0x514e999d
    subclass_of_id = 0x3ed4d9c9

    def __init__(self, bot, peer, query, offset, geo_point=None):
        """
        :param TLObject bot:
        :param TLObject peer:
        :param TLObject | None geo_point:
        :param str query:
        :param str offset:

        :returns messages.BotResults: Instance of BotResults.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.bot = get_input_user(bot)
        self.peer = get_input_peer(peer)
        self.geo_point = geo_point
        self.query = query
        self.offset = offset

    def to_dict(self, recursive=True):
        return {
            'bot': (None if self.bot is None else self.bot.to_dict()) if recursive else self.bot,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'geo_point': (None if self.geo_point is None else self.geo_point.to_dict()) if recursive else self.geo_point,
            'query': self.query,
            'offset': self.offset,
        }

    def on_send(self, writer):
        writer.write_int(GetInlineBotResultsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.geo_point else 0
        writer.write_int(flags)

        self.bot.on_send(writer)
        self.peer.on_send(writer)
        if self.geo_point:
            self.geo_point.on_send(writer)

        writer.tgwrite_string(self.query)
        writer.tgwrite_string(self.offset)

    @staticmethod
    def empty():
        return GetInlineBotResultsRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user


class GetInlineGameHighScoresRequest(TLObject):
    constructor_id = 0xf635e1b
    subclass_of_id = 0x6ccd95fd

    def __init__(self, id, user_id):
        """
        :param TLObject id:
        :param TLObject user_id:

        :returns messages.HighScores: Instance of HighScores.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.user_id = get_input_user(user_id)

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(GetInlineGameHighScoresRequest.constructor_id, signed=False)
        self.id.on_send(writer)
        self.user_id.on_send(writer)

    @staticmethod
    def empty():
        return GetInlineGameHighScoresRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetMaskStickersRequest(TLObject):
    constructor_id = 0x65b8c79f
    subclass_of_id = 0x45834829

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetMaskStickersRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetMaskStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class GetMessageEditDataRequest(TLObject):
    constructor_id = 0xfda68d36
    subclass_of_id = 0xfb47949d

    def __init__(self, peer, id):
        """
        :param TLObject peer:
        :param int id:

        :returns messages.MessageEditData: Instance of MessageEditData.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(GetMessageEditDataRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.id)

    @staticmethod
    def empty():
        return GetMessageEditDataRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetMessagesRequest(TLObject):
    constructor_id = 0x4222fa74
    subclass_of_id = 0xd4b40b5e

    def __init__(self, id):
        """
        :param list[int] id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(GetMessagesRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return GetMessagesRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class GetMessagesViewsRequest(TLObject):
    constructor_id = 0xc4c8a55d
    subclass_of_id = 0x5026710f

    def __init__(self, peer, id, increment):
        """
        :param TLObject peer:
        :param list[int] id:
        :param TLObject increment:

        :returns Vector<int>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.increment = increment

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': [] if self.id is None else self.id[:],
            'increment': self.increment,
        }

    def on_send(self, writer):
        writer.write_int(GetMessagesViewsRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

        writer.tgwrite_bool(self.increment)

    @staticmethod
    def empty():
        return GetMessagesViewsRequest(None, None, None)

    def on_response(self, reader):
        reader.read_int()  # Vector id
        count = reader.read_int()
        self.result = [reader.read_int() for _ in range(count)]

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class GetPeerDialogsRequest(TLObject):
    constructor_id = 0x2d9776b9
    subclass_of_id = 0x3ac70132

    def __init__(self, peers):
        """
        :param list[TLObject] peers:

        :returns messages.PeerDialogs: Instance of PeerDialogs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peers = [get_input_peer(_x) for _x in peers]

    def to_dict(self, recursive=True):
        return {
            'peers': ([] if self.peers is None else [None if x is None else x.to_dict() for x in self.peers]) if recursive else self.peers,
        }

    def on_send(self, writer):
        writer.write_int(GetPeerDialogsRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.peers))
        for _x in self.peers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return GetPeerDialogsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class GetPeerSettingsRequest(TLObject):
    constructor_id = 0x3672e09c
    subclass_of_id = 0xf6a79f84

    def __init__(self, peer):
        """
        :param TLObject peer:

        :returns PeerSettings: Instance of PeerSettings.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def on_send(self, writer):
        writer.write_int(GetPeerSettingsRequest.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return GetPeerSettingsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetPinnedDialogsRequest(TLObject):
    constructor_id = 0xe254d64e
    subclass_of_id = 0x3ac70132

    def __init__(self):
        super().__init__()
        self.result = None
        self.content_related = True

    def to_dict(self, recursive=True):
        return {}

    def on_send(self, writer):
        writer.write_int(GetPinnedDialogsRequest.constructor_id, signed=False)

    @staticmethod
    def empty():
        return GetPinnedDialogsRequest()

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetRecentStickersRequest(TLObject):
    constructor_id = 0x5ea192c9
    subclass_of_id = 0xf76f8683

    def __init__(self, hash, attached=None):
        """
        :param bool | None attached:
        :param int hash:

        :returns messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached
        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'attached': self.attached,
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetRecentStickersRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.attached else 0
        writer.write_int(flags)

        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetRecentStickersRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetSavedGifsRequest(TLObject):
    constructor_id = 0x83bf3d52
    subclass_of_id = 0xa68b61f5

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetSavedGifsRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetSavedGifsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetStickerSetRequest(TLObject):
    constructor_id = 0x2619a90e
    subclass_of_id = 0x9b704a5a

    def __init__(self, stickerset):
        """
        :param TLObject stickerset:

        :returns messages.StickerSet: Instance of StickerSet.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset

    def to_dict(self, recursive=True):
        return {
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
        }

    def on_send(self, writer):
        writer.write_int(GetStickerSetRequest.constructor_id, signed=False)
        self.stickerset.on_send(writer)

    @staticmethod
    def empty():
        return GetStickerSetRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class GetUnreadMentionsRequest(TLObject):
    constructor_id = 0x46578472
    subclass_of_id = 0xd4b40b5e

    def __init__(self, peer, offset_id, add_offset, limit, max_id, min_id):
        """
        :param TLObject peer:
        :param int offset_id:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.offset_id = offset_id
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'offset_id': self.offset_id,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def on_send(self, writer):
        writer.write_int(GetUnreadMentionsRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.offset_id)
        writer.write_int(self.add_offset)
        writer.write_int(self.limit)
        writer.write_int(self.max_id)
        writer.write_int(self.min_id)

    @staticmethod
    def empty():
        return GetUnreadMentionsRequest(None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetWebPageRequest(TLObject):
    constructor_id = 0x32ca8f91
    subclass_of_id = 0x55a97481

    def __init__(self, url, hash):
        """
        :param str url:
        :param int hash:

        :returns WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.url = url
        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetWebPageRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetWebPageRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetWebPagePreviewRequest(TLObject):
    constructor_id = 0x25223e24
    subclass_of_id = 0x476cbe32

    def __init__(self, message):
        """
        :param str message:

        :returns MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.message = message

    def to_dict(self, recursive=True):
        return {
            'message': self.message,
        }

    def on_send(self, writer):
        writer.write_int(GetWebPagePreviewRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.message)

    @staticmethod
    def empty():
        return GetWebPagePreviewRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class HideReportSpamRequest(TLObject):
    constructor_id = 0xa8f1709b
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TLObject peer:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def on_send(self, writer):
        writer.write_int(HideReportSpamRequest.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return HideReportSpamRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ImportChatInviteRequest(TLObject):
    constructor_id = 0x6c50051c
    subclass_of_id = 0x8af52aac

    def __init__(self, hash):
        """
        :param str hash:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(ImportChatInviteRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.hash)

    @staticmethod
    def empty():
        return ImportChatInviteRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InstallStickerSetRequest(TLObject):
    constructor_id = 0xc78fe460
    subclass_of_id = 0x67cb3fe8

    def __init__(self, stickerset, archived):
        """
        :param TLObject stickerset:
        :param TLObject archived:

        :returns messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset
        self.archived = archived

    def to_dict(self, recursive=True):
        return {
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
            'archived': self.archived,
        }

    def on_send(self, writer):
        writer.write_int(InstallStickerSetRequest.constructor_id, signed=False)
        self.stickerset.on_send(writer)
        writer.tgwrite_bool(self.archived)

    @staticmethod
    def empty():
        return InstallStickerSetRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MigrateChatRequest(TLObject):
    constructor_id = 0x15a3b8e3
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(MigrateChatRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return MigrateChatRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadEncryptedHistoryRequest(TLObject):
    constructor_id = 0x7f4b690a
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, max_date):
        """
        :param TLObject peer:
        :param datetime.datetime max_date:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.max_date = max_date

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'max_date': self.max_date,
        }

    def on_send(self, writer):
        writer.write_int(ReadEncryptedHistoryRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.tgwrite_date(self.max_date)

    @staticmethod
    def empty():
        return ReadEncryptedHistoryRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadFeaturedStickersRequest(TLObject):
    constructor_id = 0x5b118126
    subclass_of_id = 0xf5b399ac

    def __init__(self, id):
        """
        :param list[int] id:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(ReadFeaturedStickersRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return ReadFeaturedStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class ReadHistoryRequest(TLObject):
    constructor_id = 0xe306d3a
    subclass_of_id = 0xced3c06e

    def __init__(self, peer, max_id):
        """
        :param TLObject peer:
        :param int max_id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(ReadHistoryRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return ReadHistoryRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadMessageContentsRequest(TLObject):
    constructor_id = 0x36a73f77
    subclass_of_id = 0xced3c06e

    def __init__(self, id):
        """
        :param list[int] id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(ReadMessageContentsRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return ReadMessageContentsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReceivedMessagesRequest(TLObject):
    constructor_id = 0x5a954c0
    subclass_of_id = 0x8565f897

    def __init__(self, max_id):
        """
        :param int max_id:

        :returns Vector<ReceivedNotifyMessage>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(ReceivedMessagesRequest.constructor_id, signed=False)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return ReceivedMessagesRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_vector()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReceivedQueueRequest(TLObject):
    constructor_id = 0x55a5bb66
    subclass_of_id = 0x8918e168

    def __init__(self, max_qts):
        """
        :param int max_qts:

        :returns Vector<long>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.max_qts = max_qts

    def to_dict(self, recursive=True):
        return {
            'max_qts': self.max_qts,
        }

    def on_send(self, writer):
        writer.write_int(ReceivedQueueRequest.constructor_id, signed=False)
        writer.write_int(self.max_qts)

    @staticmethod
    def empty():
        return ReceivedQueueRequest(None)

    def on_response(self, reader):
        reader.read_int()  # Vector id
        count = reader.read_long()
        self.result = [reader.read_long() for _ in range(count)]

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class ReorderPinnedDialogsRequest(TLObject):
    constructor_id = 0x959ff644
    subclass_of_id = 0xf5b399ac

    def __init__(self, order, force=None):
        """
        :param bool | None force:
        :param list[TLObject] order:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.force = force
        self.order = [get_input_peer(_x) for _x in order]

    def to_dict(self, recursive=True):
        return {
            'force': self.force,
            'order': ([] if self.order is None else [None if x is None else x.to_dict() for x in self.order]) if recursive else self.order,
        }

    def on_send(self, writer):
        writer.write_int(ReorderPinnedDialogsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.force else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.order))
        for _x in self.order:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ReorderPinnedDialogsRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReorderStickerSetsRequest(TLObject):
    constructor_id = 0x78337739
    subclass_of_id = 0xf5b399ac

    def __init__(self, order, masks=None):
        """
        :param bool | None masks:
        :param list[int] order:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.masks = masks
        self.order = order

    def to_dict(self, recursive=True):
        return {
            'masks': self.masks,
            'order': [] if self.order is None else self.order[:],
        }

    def on_send(self, writer):
        writer.write_int(ReorderStickerSetsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.masks else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.order))
        for _x in self.order:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return ReorderStickerSetsRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReportEncryptedSpamRequest(TLObject):
    constructor_id = 0x4b0c8c0f
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TLObject peer:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def on_send(self, writer):
        writer.write_int(ReportEncryptedSpamRequest.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return ReportEncryptedSpamRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class ReportSpamRequest(TLObject):
    constructor_id = 0xcf1592db
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TLObject peer:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def on_send(self, writer):
        writer.write_int(ReportSpamRequest.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return ReportSpamRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user


class RequestEncryptionRequest(TLObject):
    constructor_id = 0xf64daf43
    subclass_of_id = 0x6d28a37a

    def __init__(self, user_id, g_a, random_id=None):
        """
        :param TLObject user_id:
        :param int random_id:
        :param bytes g_a:

        :returns EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.user_id = get_input_user(user_id)
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(4), 'big', signed=True)
        self.g_a = g_a

    def to_dict(self, recursive=True):
        return {
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'random_id': self.random_id,
            'g_a': self.g_a,
        }

    def on_send(self, writer):
        writer.write_int(RequestEncryptionRequest.constructor_id, signed=False)
        self.user_id.on_send(writer)
        writer.write_int(self.random_id)
        writer.tgwrite_bytes(self.g_a)

    @staticmethod
    def empty():
        return RequestEncryptionRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class SaveDraftRequest(TLObject):
    constructor_id = 0xbc39e14b
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, message, no_webpage=None, reply_to_msg_id=None, entities=None):
        """
        :param bool | None no_webpage:
        :param int | None reply_to_msg_id:
        :param TLObject peer:
        :param str message:
        :param list[TLObject] | None entities:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.reply_to_msg_id = reply_to_msg_id
        self.peer = get_input_peer(peer)
        self.message = message
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'reply_to_msg_id': self.reply_to_msg_id,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'message': self.message,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def on_send(self, writer):
        writer.write_int(SaveDraftRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        self.peer.on_send(writer)
        writer.tgwrite_string(self.message)
        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return SaveDraftRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SaveGifRequest(TLObject):
    constructor_id = 0x327a30cb
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, unsave):
        """
        :param TLObject id:
        :param TLObject unsave:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.unsave = unsave

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'unsave': self.unsave,
        }

    def on_send(self, writer):
        writer.write_int(SaveGifRequest.constructor_id, signed=False)
        self.id.on_send(writer)
        writer.tgwrite_bool(self.unsave)

    @staticmethod
    def empty():
        return SaveGifRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SaveRecentStickerRequest(TLObject):
    constructor_id = 0x392718f8
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, unsave, attached=None):
        """
        :param bool | None attached:
        :param TLObject id:
        :param TLObject unsave:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached
        self.id = id
        self.unsave = unsave

    def to_dict(self, recursive=True):
        return {
            'attached': self.attached,
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'unsave': self.unsave,
        }

    def on_send(self, writer):
        writer.write_int(SaveRecentStickerRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.attached else 0
        writer.write_int(flags)

        self.id.on_send(writer)
        writer.tgwrite_bool(self.unsave)

    @staticmethod
    def empty():
        return SaveRecentStickerRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user, get_input_peer


class SearchRequest(TLObject):
    constructor_id = 0x39e9ea0
    subclass_of_id = 0xd4b40b5e

    def __init__(self, peer, q, filter, min_date, max_date, offset_id, add_offset, limit, max_id, min_id, from_id=None):
        """
        :param TLObject peer:
        :param str q:
        :param TLObject | None from_id:
        :param TLObject filter:
        :param datetime.datetime min_date:
        :param datetime.datetime max_date:
        :param int offset_id:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.q = q
        self.from_id = get_input_user(from_id)
        self.filter = filter
        self.min_date = min_date
        self.max_date = max_date
        self.offset_id = offset_id
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'q': self.q,
            'from_id': (None if self.from_id is None else self.from_id.to_dict()) if recursive else self.from_id,
            'filter': (None if self.filter is None else self.filter.to_dict()) if recursive else self.filter,
            'min_date': self.min_date,
            'max_date': self.max_date,
            'offset_id': self.offset_id,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def on_send(self, writer):
        writer.write_int(SearchRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.from_id else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.tgwrite_string(self.q)
        if self.from_id:
            self.from_id.on_send(writer)

        self.filter.on_send(writer)
        writer.tgwrite_date(self.min_date)
        writer.tgwrite_date(self.max_date)
        writer.write_int(self.offset_id)
        writer.write_int(self.add_offset)
        writer.write_int(self.limit)
        writer.write_int(self.max_id)
        writer.write_int(self.min_id)

    @staticmethod
    def empty():
        return SearchRequest(None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SearchGifsRequest(TLObject):
    constructor_id = 0xbf9a776b
    subclass_of_id = 0xe799ea7

    def __init__(self, q, offset):
        """
        :param str q:
        :param int offset:

        :returns messages.FoundGifs: Instance of FoundGifs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.q = q
        self.offset = offset

    def to_dict(self, recursive=True):
        return {
            'q': self.q,
            'offset': self.offset,
        }

    def on_send(self, writer):
        writer.write_int(SearchGifsRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.q)
        writer.write_int(self.offset)

    @staticmethod
    def empty():
        return SearchGifsRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class SearchGlobalRequest(TLObject):
    constructor_id = 0x9e3cacb0
    subclass_of_id = 0xd4b40b5e

    def __init__(self, q, offset_date, offset_peer, offset_id, limit):
        """
        :param str q:
        :param datetime.datetime offset_date:
        :param TLObject offset_peer:
        :param int offset_id:
        :param int limit:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.q = q
        self.offset_date = offset_date
        self.offset_peer = get_input_peer(offset_peer)
        self.offset_id = offset_id
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'q': self.q,
            'offset_date': self.offset_date,
            'offset_peer': (None if self.offset_peer is None else self.offset_peer.to_dict()) if recursive else self.offset_peer,
            'offset_id': self.offset_id,
            'limit': self.limit,
        }

    def on_send(self, writer):
        writer.write_int(SearchGlobalRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.q)
        writer.tgwrite_date(self.offset_date)
        self.offset_peer.on_send(writer)
        writer.write_int(self.offset_id)
        writer.write_int(self.limit)

    @staticmethod
    def empty():
        return SearchGlobalRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendEncryptedRequest(TLObject):
    constructor_id = 0xa9776773
    subclass_of_id = 0xc99e3e50

    def __init__(self, peer, data, random_id=None):
        """
        :param TLObject peer:
        :param int random_id:
        :param bytes data:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'random_id': self.random_id,
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(SendEncryptedRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_long(self.random_id)
        writer.tgwrite_bytes(self.data)

    @staticmethod
    def empty():
        return SendEncryptedRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendEncryptedFileRequest(TLObject):
    constructor_id = 0x9a901b66
    subclass_of_id = 0xc99e3e50

    def __init__(self, peer, data, file, random_id=None):
        """
        :param TLObject peer:
        :param int random_id:
        :param bytes data:
        :param TLObject file:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data
        self.file = file

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'random_id': self.random_id,
            'data': self.data,
            'file': (None if self.file is None else self.file.to_dict()) if recursive else self.file,
        }

    def on_send(self, writer):
        writer.write_int(SendEncryptedFileRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_long(self.random_id)
        writer.tgwrite_bytes(self.data)
        self.file.on_send(writer)

    @staticmethod
    def empty():
        return SendEncryptedFileRequest(None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendEncryptedServiceRequest(TLObject):
    constructor_id = 0x32d439a4
    subclass_of_id = 0xc99e3e50

    def __init__(self, peer, data, random_id=None):
        """
        :param TLObject peer:
        :param int random_id:
        :param bytes data:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'random_id': self.random_id,
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(SendEncryptedServiceRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_long(self.random_id)
        writer.tgwrite_bytes(self.data)

    @staticmethod
    def empty():
        return SendEncryptedServiceRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class SendInlineBotResultRequest(TLObject):
    constructor_id = 0xb16e06fe
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, query_id, id, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None):
        """
        :param bool | None silent:
        :param bool | None background:
        :param bool | None clear_draft:
        :param TLObject peer:
        :param int | None reply_to_msg_id:
        :param int random_id:
        :param int query_id:
        :param str id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.query_id = query_id
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id,
            'query_id': self.query_id,
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(SendInlineBotResultRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 5) if self.silent else 0
        flags |= (1 << 6) if self.background else 0
        flags |= (1 << 7) if self.clear_draft else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        writer.write_long(self.random_id)
        writer.write_long(self.query_id)
        writer.tgwrite_string(self.id)

    @staticmethod
    def empty():
        return SendInlineBotResultRequest(None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class SendMediaRequest(TLObject):
    constructor_id = 0xc8f16791
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, media, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None, reply_markup=None):
        """
        :param bool | None silent:
        :param bool | None background:
        :param bool | None clear_draft:
        :param TLObject peer:
        :param int | None reply_to_msg_id:
        :param TLObject media:
        :param int random_id:
        :param TLObject | None reply_markup:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.media = media
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'reply_to_msg_id': self.reply_to_msg_id,
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
            'random_id': self.random_id,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def on_send(self, writer):
        writer.write_int(SendMediaRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 5) if self.silent else 0
        flags |= (1 << 6) if self.background else 0
        flags |= (1 << 7) if self.clear_draft else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        self.media.on_send(writer)
        writer.write_long(self.random_id)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return SendMediaRequest(None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class SendMessageRequest(TLObject):
    constructor_id = 0xfa88427a
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, message, no_webpage=None, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None, reply_markup=None, entities=None):
        """
        :param bool | None no_webpage:
        :param bool | None silent:
        :param bool | None background:
        :param bool | None clear_draft:
        :param TLObject peer:
        :param int | None reply_to_msg_id:
        :param str message:
        :param int random_id:
        :param TLObject | None reply_markup:
        :param list[TLObject] | None entities:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.message = message
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'reply_to_msg_id': self.reply_to_msg_id,
            'message': self.message,
            'random_id': self.random_id,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def on_send(self, writer):
        writer.write_int(SendMessageRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 5) if self.silent else 0
        flags |= (1 << 6) if self.background else 0
        flags |= (1 << 7) if self.clear_draft else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        flags |= (1 << 2) if self.reply_markup else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        writer.tgwrite_string(self.message)
        writer.write_long(self.random_id)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return SendMessageRequest(None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class SendScreenshotNotificationRequest(TLObject):
    constructor_id = 0xc97df020
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, reply_to_msg_id, random_id=None):
        """
        :param TLObject peer:
        :param int reply_to_msg_id:
        :param int random_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id,
        }

    def on_send(self, writer):
        writer.write_int(SendScreenshotNotificationRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.reply_to_msg_id)
        writer.write_long(self.random_id)

    @staticmethod
    def empty():
        return SendScreenshotNotificationRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetBotCallbackAnswerRequest(TLObject):
    constructor_id = 0xd58f130a
    subclass_of_id = 0xf5b399ac

    def __init__(self, query_id, cache_time, alert=None, message=None, url=None):
        """
        :param bool | None alert:
        :param int query_id:
        :param str | None message:
        :param str | None url:
        :param int cache_time:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.alert = alert
        self.query_id = query_id
        self.message = message
        self.url = url
        self.cache_time = cache_time

    def to_dict(self, recursive=True):
        return {
            'alert': self.alert,
            'query_id': self.query_id,
            'message': self.message,
            'url': self.url,
            'cache_time': self.cache_time,
        }

    def on_send(self, writer):
        writer.write_int(SetBotCallbackAnswerRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.alert else 0
        flags |= (1 << 0) if self.message else 0
        flags |= (1 << 2) if self.url else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        if self.message:
            writer.tgwrite_string(self.message)

        if self.url:
            writer.tgwrite_string(self.url)

        writer.write_int(self.cache_time)

    @staticmethod
    def empty():
        return SetBotCallbackAnswerRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetBotPrecheckoutResultsRequest(TLObject):
    constructor_id = 0x9c2dd95
    subclass_of_id = 0xf5b399ac

    def __init__(self, query_id, success=None, error=None):
        """
        :param bool | None success:
        :param int query_id:
        :param str | None error:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.success = success
        self.query_id = query_id
        self.error = error

    def to_dict(self, recursive=True):
        return {
            'success': self.success,
            'query_id': self.query_id,
            'error': self.error,
        }

    def on_send(self, writer):
        writer.write_int(SetBotPrecheckoutResultsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.success else 0
        flags |= (1 << 0) if self.error else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        if self.error:
            writer.tgwrite_string(self.error)

    @staticmethod
    def empty():
        return SetBotPrecheckoutResultsRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetBotShippingResultsRequest(TLObject):
    constructor_id = 0xe5f672fa
    subclass_of_id = 0xf5b399ac

    def __init__(self, query_id, error=None, shipping_options=None):
        """
        :param int query_id:
        :param str | None error:
        :param list[TLObject] | None shipping_options:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.query_id = query_id
        self.error = error
        self.shipping_options = shipping_options

    def to_dict(self, recursive=True):
        return {
            'query_id': self.query_id,
            'error': self.error,
            'shipping_options': ([] if self.shipping_options is None else [None if x is None else x.to_dict() for x in self.shipping_options]) if recursive else self.shipping_options,
        }

    def on_send(self, writer):
        writer.write_int(SetBotShippingResultsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.error else 0
        flags |= (1 << 1) if self.shipping_options else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        if self.error:
            writer.tgwrite_string(self.error)

        if self.shipping_options:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.shipping_options))
            for _x in self.shipping_options:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return SetBotShippingResultsRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetEncryptedTypingRequest(TLObject):
    constructor_id = 0x791451ed
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, typing):
        """
        :param TLObject peer:
        :param TLObject typing:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.typing = typing

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'typing': self.typing,
        }

    def on_send(self, writer):
        writer.write_int(SetEncryptedTypingRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.tgwrite_bool(self.typing)

    @staticmethod
    def empty():
        return SetEncryptedTypingRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user, get_input_peer


class SetGameScoreRequest(TLObject):
    constructor_id = 0x8ef8ecc0
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, id, user_id, score, edit_message=None, force=None):
        """
        :param bool | None edit_message:
        :param bool | None force:
        :param TLObject peer:
        :param int id:
        :param TLObject user_id:
        :param int score:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.edit_message = edit_message
        self.force = force
        self.peer = get_input_peer(peer)
        self.id = id
        self.user_id = get_input_user(user_id)
        self.score = score

    def to_dict(self, recursive=True):
        return {
            'edit_message': self.edit_message,
            'force': self.force,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'score': self.score,
        }

    def on_send(self, writer):
        writer.write_int(SetGameScoreRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.edit_message else 0
        flags |= (1 << 1) if self.force else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.id)
        self.user_id.on_send(writer)
        writer.write_int(self.score)

    @staticmethod
    def empty():
        return SetGameScoreRequest(None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetInlineBotResultsRequest(TLObject):
    constructor_id = 0xeb5ea206
    subclass_of_id = 0xf5b399ac

    def __init__(self, query_id, results, cache_time, gallery=None, private=None, next_offset=None, switch_pm=None):
        """
        :param bool | None gallery:
        :param bool | None private:
        :param int query_id:
        :param list[TLObject] results:
        :param int cache_time:
        :param str | None next_offset:
        :param TLObject | None switch_pm:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.gallery = gallery
        self.private = private
        self.query_id = query_id
        self.results = results
        self.cache_time = cache_time
        self.next_offset = next_offset
        self.switch_pm = switch_pm

    def to_dict(self, recursive=True):
        return {
            'gallery': self.gallery,
            'private': self.private,
            'query_id': self.query_id,
            'results': ([] if self.results is None else [None if x is None else x.to_dict() for x in self.results]) if recursive else self.results,
            'cache_time': self.cache_time,
            'next_offset': self.next_offset,
            'switch_pm': (None if self.switch_pm is None else self.switch_pm.to_dict()) if recursive else self.switch_pm,
        }

    def on_send(self, writer):
        writer.write_int(SetInlineBotResultsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.gallery else 0
        flags |= (1 << 1) if self.private else 0
        flags |= (1 << 2) if self.next_offset else 0
        flags |= (1 << 3) if self.switch_pm else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.results))
        for _x in self.results:
            _x.on_send(writer)

        writer.write_int(self.cache_time)
        if self.next_offset:
            writer.tgwrite_string(self.next_offset)

        if self.switch_pm:
            self.switch_pm.on_send(writer)

    @staticmethod
    def empty():
        return SetInlineBotResultsRequest(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_user


class SetInlineGameScoreRequest(TLObject):
    constructor_id = 0x15ad9f64
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, user_id, score, edit_message=None, force=None):
        """
        :param bool | None edit_message:
        :param bool | None force:
        :param TLObject id:
        :param TLObject user_id:
        :param int score:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.edit_message = edit_message
        self.force = force
        self.id = id
        self.user_id = get_input_user(user_id)
        self.score = score

    def to_dict(self, recursive=True):
        return {
            'edit_message': self.edit_message,
            'force': self.force,
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'score': self.score,
        }

    def on_send(self, writer):
        writer.write_int(SetInlineGameScoreRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.edit_message else 0
        flags |= (1 << 1) if self.force else 0
        writer.write_int(flags)

        self.id.on_send(writer)
        self.user_id.on_send(writer)
        writer.write_int(self.score)

    @staticmethod
    def empty():
        return SetInlineGameScoreRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class SetTypingRequest(TLObject):
    constructor_id = 0xa3825e50
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, action):
        """
        :param TLObject peer:
        :param TLObject action:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.action = action

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'action': (None if self.action is None else self.action.to_dict()) if recursive else self.action,
        }

    def on_send(self, writer):
        writer.write_int(SetTypingRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        self.action.on_send(writer)

    @staticmethod
    def empty():
        return SetTypingRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer, get_input_user


class StartBotRequest(TLObject):
    constructor_id = 0xe6df7378
    subclass_of_id = 0x8af52aac

    def __init__(self, bot, peer, start_param, random_id=None):
        """
        :param TLObject bot:
        :param TLObject peer:
        :param int random_id:
        :param str start_param:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.bot = get_input_user(bot)
        self.peer = get_input_peer(peer)
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.start_param = start_param

    def to_dict(self, recursive=True):
        return {
            'bot': (None if self.bot is None else self.bot.to_dict()) if recursive else self.bot,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'random_id': self.random_id,
            'start_param': self.start_param,
        }

    def on_send(self, writer):
        writer.write_int(StartBotRequest.constructor_id, signed=False)
        self.bot.on_send(writer)
        self.peer.on_send(writer)
        writer.write_long(self.random_id)
        writer.tgwrite_string(self.start_param)

    @staticmethod
    def empty():
        return StartBotRequest(None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ToggleChatAdminsRequest(TLObject):
    constructor_id = 0xec8bd9e1
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, enabled):
        """
        :param int chat_id:
        :param TLObject enabled:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.enabled = enabled

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'enabled': self.enabled,
        }

    def on_send(self, writer):
        writer.write_int(ToggleChatAdminsRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.tgwrite_bool(self.enabled)

    @staticmethod
    def empty():
        return ToggleChatAdminsRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class ToggleDialogPinRequest(TLObject):
    constructor_id = 0x3289be6a
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, pinned=None):
        """
        :param bool | None pinned:
        :param TLObject peer:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.pinned = pinned
        self.peer = get_input_peer(peer)

    def to_dict(self, recursive=True):
        return {
            'pinned': self.pinned,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def on_send(self, writer):
        writer.write_int(ToggleDialogPinRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.pinned else 0
        writer.write_int(flags)

        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return ToggleDialogPinRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UninstallStickerSetRequest(TLObject):
    constructor_id = 0xf96e55de
    subclass_of_id = 0xf5b399ac

    def __init__(self, stickerset):
        """
        :param TLObject stickerset:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset

    def to_dict(self, recursive=True):
        return {
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
        }

    def on_send(self, writer):
        writer.write_int(UninstallStickerSetRequest.constructor_id, signed=False)
        self.stickerset.on_send(writer)

    @staticmethod
    def empty():
        return UninstallStickerSetRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
from ...utils import get_input_peer


class UploadMediaRequest(TLObject):
    constructor_id = 0x519bc2b1
    subclass_of_id = 0x476cbe32

    def __init__(self, peer, media):
        """
        :param TLObject peer:
        :param TLObject media:

        :returns MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.media = media

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
        }

    def on_send(self, writer):
        writer.write_int(UploadMediaRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        self.media.on_send(writer)

    @staticmethod
    def empty():
        return UploadMediaRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
