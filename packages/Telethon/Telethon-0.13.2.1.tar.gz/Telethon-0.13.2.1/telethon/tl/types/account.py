"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject


class Authorizations(TLObject):
    constructor_id = 0x1250abde
    subclass_of_id = 0xbf5e0ff

    def __init__(self, authorizations):
        """
        :param authorizations: Telegram type: "Authorization". Must be a list.

        Constructor for account.Authorizations: Instance of Authorizations.
        """
        super().__init__()

        self.authorizations = authorizations

    def to_dict(self):
        return {
            'authorizations': [] if self.authorizations is None else [None if x is None else x.to_dict() for x in self.authorizations],
        }

    def on_send(self, writer):
        writer.write_int(Authorizations.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.authorizations))
        for _x in self.authorizations:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Authorizations(None)

    def on_response(self, reader):
        reader.read_int()
        self.authorizations = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.authorizations.append(_x)

    def __repr__(self):
        return 'account.authorizations#1250abde authorizations:Vector<Authorization> = account.Authorizations'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class NoPassword(TLObject):
    constructor_id = 0x96dabc18
    subclass_of_id = 0x53a211a3

    def __init__(self, new_salt, email_unconfirmed_pattern):
        """
        :param new_salt: Telegram type: "bytes".
        :param email_unconfirmed_pattern: Telegram type: "string".

        Constructor for account.Password: Instance of either NoPassword, Password.
        """
        super().__init__()

        self.new_salt = new_salt
        self.email_unconfirmed_pattern = email_unconfirmed_pattern

    def to_dict(self):
        return {
            'new_salt': self.new_salt,
            'email_unconfirmed_pattern': self.email_unconfirmed_pattern,
        }

    def on_send(self, writer):
        writer.write_int(NoPassword.constructor_id, signed=False)
        writer.tgwrite_bytes(self.new_salt)
        writer.tgwrite_string(self.email_unconfirmed_pattern)

    @staticmethod
    def empty():
        return NoPassword(None, None)

    def on_response(self, reader):
        self.new_salt = reader.tgread_bytes()
        self.email_unconfirmed_pattern = reader.tgread_string()

    def __repr__(self):
        return 'account.noPassword#96dabc18 new_salt:bytes email_unconfirmed_pattern:string = account.Password'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Password(TLObject):
    constructor_id = 0x7c18141c
    subclass_of_id = 0x53a211a3

    def __init__(self, current_salt, new_salt, hint, has_recovery, email_unconfirmed_pattern):
        """
        :param current_salt: Telegram type: "bytes".
        :param new_salt: Telegram type: "bytes".
        :param hint: Telegram type: "string".
        :param has_recovery: Telegram type: "Bool".
        :param email_unconfirmed_pattern: Telegram type: "string".

        Constructor for account.Password: Instance of either NoPassword, Password.
        """
        super().__init__()

        self.current_salt = current_salt
        self.new_salt = new_salt
        self.hint = hint
        self.has_recovery = has_recovery
        self.email_unconfirmed_pattern = email_unconfirmed_pattern

    def to_dict(self):
        return {
            'current_salt': self.current_salt,
            'new_salt': self.new_salt,
            'hint': self.hint,
            'has_recovery': self.has_recovery,
            'email_unconfirmed_pattern': self.email_unconfirmed_pattern,
        }

    def on_send(self, writer):
        writer.write_int(Password.constructor_id, signed=False)
        writer.tgwrite_bytes(self.current_salt)
        writer.tgwrite_bytes(self.new_salt)
        writer.tgwrite_string(self.hint)
        writer.tgwrite_bool(self.has_recovery)
        writer.tgwrite_string(self.email_unconfirmed_pattern)

    @staticmethod
    def empty():
        return Password(None, None, None, None, None)

    def on_response(self, reader):
        self.current_salt = reader.tgread_bytes()
        self.new_salt = reader.tgread_bytes()
        self.hint = reader.tgread_string()
        self.has_recovery = reader.tgread_bool()
        self.email_unconfirmed_pattern = reader.tgread_string()

    def __repr__(self):
        return 'account.password#7c18141c current_salt:bytes new_salt:bytes hint:string has_recovery:Bool email_unconfirmed_pattern:string = account.Password'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PasswordInputSettings(TLObject):
    constructor_id = 0x86916deb
    subclass_of_id = 0xc426ca6

    def __init__(self, new_salt=None, new_password_hash=None, hint=None, email=None):
        """
        :param new_salt: Telegram type: "bytes".
        :param new_password_hash: Telegram type: "bytes".
        :param hint: Telegram type: "string".
        :param email: Telegram type: "string".

        Constructor for account.PasswordInputSettings: Instance of PasswordInputSettings.
        """
        super().__init__()

        self.new_salt = new_salt
        self.new_password_hash = new_password_hash
        self.hint = hint
        self.email = email

    def to_dict(self):
        return {
            'new_salt': self.new_salt,
            'new_password_hash': self.new_password_hash,
            'hint': self.hint,
            'email': self.email,
        }

    def on_send(self, writer):
        writer.write_int(PasswordInputSettings.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.new_salt else 0
        flags |= (1 << 0) if self.new_password_hash else 0
        flags |= (1 << 0) if self.hint else 0
        flags |= (1 << 1) if self.email else 0
        writer.write_int(flags)

        if self.new_salt:
            writer.tgwrite_bytes(self.new_salt)

        if self.new_password_hash:
            writer.tgwrite_bytes(self.new_password_hash)

        if self.hint:
            writer.tgwrite_string(self.hint)

        if self.email:
            writer.tgwrite_string(self.email)

    @staticmethod
    def empty():
        return PasswordInputSettings(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.new_salt = reader.tgread_bytes()

        if (flags & (1 << 0)) != 0:
            self.new_password_hash = reader.tgread_bytes()

        if (flags & (1 << 0)) != 0:
            self.hint = reader.tgread_string()

        if (flags & (1 << 1)) != 0:
            self.email = reader.tgread_string()

    def __repr__(self):
        return 'account.passwordInputSettings#86916deb flags:# new_salt:flags.0?bytes new_password_hash:flags.0?bytes hint:flags.0?string email:flags.1?string = account.PasswordInputSettings'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PasswordSettings(TLObject):
    constructor_id = 0xb7b72ab3
    subclass_of_id = 0xd23fb078

    def __init__(self, email):
        """
        :param email: Telegram type: "string".

        Constructor for account.PasswordSettings: Instance of PasswordSettings.
        """
        super().__init__()

        self.email = email

    def to_dict(self):
        return {
            'email': self.email,
        }

    def on_send(self, writer):
        writer.write_int(PasswordSettings.constructor_id, signed=False)
        writer.tgwrite_string(self.email)

    @staticmethod
    def empty():
        return PasswordSettings(None)

    def on_response(self, reader):
        self.email = reader.tgread_string()

    def __repr__(self):
        return 'account.passwordSettings#b7b72ab3 email:string = account.PasswordSettings'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyRules(TLObject):
    constructor_id = 0x554abb6f
    subclass_of_id = 0xb55aba82

    def __init__(self, rules, users):
        """
        :param rules: Telegram type: "PrivacyRule". Must be a list.
        :param users: Telegram type: "User". Must be a list.

        Constructor for account.PrivacyRules: Instance of PrivacyRules.
        """
        super().__init__()

        self.rules = rules
        self.users = users

    def to_dict(self):
        return {
            'rules': [] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(PrivacyRules.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.rules))
        for _x in self.rules:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return PrivacyRules(None, None)

    def on_response(self, reader):
        reader.read_int()
        self.rules = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.rules.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'account.privacyRules#554abb6f rules:Vector<PrivacyRule> users:Vector<User> = account.PrivacyRules'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TmpPassword(TLObject):
    constructor_id = 0xdb64fd34
    subclass_of_id = 0xb064992d

    def __init__(self, tmp_password, valid_until):
        """
        :param tmp_password: Telegram type: "bytes".
        :param valid_until: Telegram type: "int".

        Constructor for account.TmpPassword: Instance of TmpPassword.
        """
        super().__init__()

        self.tmp_password = tmp_password
        self.valid_until = valid_until

    def to_dict(self):
        return {
            'tmp_password': self.tmp_password,
            'valid_until': self.valid_until,
        }

    def on_send(self, writer):
        writer.write_int(TmpPassword.constructor_id, signed=False)
        writer.tgwrite_bytes(self.tmp_password)
        writer.write_int(self.valid_until)

    @staticmethod
    def empty():
        return TmpPassword(None, None)

    def on_response(self, reader):
        self.tmp_password = reader.tgread_bytes()
        self.valid_until = reader.read_int()

    def __repr__(self):
        return 'account.tmpPassword#db64fd34 tmp_password:bytes valid_until:int = account.TmpPassword'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

