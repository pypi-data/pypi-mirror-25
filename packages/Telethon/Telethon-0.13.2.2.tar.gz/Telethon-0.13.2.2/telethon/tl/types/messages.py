"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject


class AffectedHistory(TLObject):
    constructor_id = 0xb45c69d1
    subclass_of_id = 0x2c49c116

    def __init__(self, pts, pts_count, offset):
        """
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".
        :param offset: Telegram type: "int".

        Constructor for messages.AffectedHistory: Instance of AffectedHistory.
        """
        super().__init__()

        self.pts = pts
        self.pts_count = pts_count
        self.offset = offset

    def to_dict(self):
        return {
            'pts': self.pts,
            'pts_count': self.pts_count,
            'offset': self.offset,
        }

    def on_send(self, writer):
        writer.write_int(AffectedHistory.constructor_id, signed=False)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)
        writer.write_int(self.offset)

    @staticmethod
    def empty():
        return AffectedHistory(None, None, None)

    def on_response(self, reader):
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()
        self.offset = reader.read_int()

    def __repr__(self):
        return 'messages.affectedHistory#b45c69d1 pts:int pts_count:int offset:int = messages.AffectedHistory'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class AffectedMessages(TLObject):
    constructor_id = 0x84d19185
    subclass_of_id = 0xced3c06e

    def __init__(self, pts, pts_count):
        """
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()

        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(AffectedMessages.constructor_id, signed=False)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return AffectedMessages(None, None)

    def on_response(self, reader):
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'messages.affectedMessages#84d19185 pts:int pts_count:int = messages.AffectedMessages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class AllStickers(TLObject):
    constructor_id = 0xedfd405f
    subclass_of_id = 0x45834829

    def __init__(self, hash, sets):
        """
        :param hash: Telegram type: "int".
        :param sets: Telegram type: "StickerSet". Must be a list.

        Constructor for messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()

        self.hash = hash
        self.sets = sets

    def to_dict(self):
        return {
            'hash': self.hash,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets],
        }

    def on_send(self, writer):
        writer.write_int(AllStickers.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.sets))
        for _x in self.sets:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return AllStickers(None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.sets = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sets.append(_x)

    def __repr__(self):
        return 'messages.allStickers#edfd405f hash:int sets:Vector<StickerSet> = messages.AllStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class AllStickersNotModified(TLObject):
    constructor_id = 0xe86602c3
    subclass_of_id = 0x45834829

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(AllStickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return AllStickersNotModified()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messages.allStickersNotModified#e86602c3 = messages.AllStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ArchivedStickers(TLObject):
    constructor_id = 0x4fcba9c8
    subclass_of_id = 0x7296d771

    def __init__(self, count, sets):
        """
        :param count: Telegram type: "int".
        :param sets: Telegram type: "StickerSetCovered". Must be a list.

        Constructor for messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        super().__init__()

        self.count = count
        self.sets = sets

    def to_dict(self):
        return {
            'count': self.count,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets],
        }

    def on_send(self, writer):
        writer.write_int(ArchivedStickers.constructor_id, signed=False)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.sets))
        for _x in self.sets:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ArchivedStickers(None, None)

    def on_response(self, reader):
        self.count = reader.read_int()
        reader.read_int()
        self.sets = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sets.append(_x)

    def __repr__(self):
        return 'messages.archivedStickers#4fcba9c8 count:int sets:Vector<StickerSetCovered> = messages.ArchivedStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotCallbackAnswer(TLObject):
    constructor_id = 0x36585ea4
    subclass_of_id = 0x6c4dd18c

    def __init__(self, cache_time, alert=None, has_url=None, message=None, url=None):
        """
        :param alert: Telegram type: "true".
        :param has_url: Telegram type: "true".
        :param message: Telegram type: "string".
        :param url: Telegram type: "string".
        :param cache_time: Telegram type: "int".

        Constructor for messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        super().__init__()

        self.alert = alert
        self.has_url = has_url
        self.message = message
        self.url = url
        self.cache_time = cache_time

    def to_dict(self):
        return {
            'alert': self.alert,
            'has_url': self.has_url,
            'message': self.message,
            'url': self.url,
            'cache_time': self.cache_time,
        }

    def on_send(self, writer):
        writer.write_int(BotCallbackAnswer.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.alert else 0
        flags |= (1 << 3) if self.has_url else 0
        flags |= (1 << 0) if self.message else 0
        flags |= (1 << 2) if self.url else 0
        writer.write_int(flags)

        if self.message:
            writer.tgwrite_string(self.message)

        if self.url:
            writer.tgwrite_string(self.url)

        writer.write_int(self.cache_time)

    @staticmethod
    def empty():
        return BotCallbackAnswer(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.alert = True

        if (flags & (1 << 3)) != 0:
            self.has_url = True

        if (flags & (1 << 0)) != 0:
            self.message = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.url = reader.tgread_string()

        self.cache_time = reader.read_int()

    def __repr__(self):
        return 'messages.botCallbackAnswer#36585ea4 flags:# alert:flags.1?true has_url:flags.3?true message:flags.0?string url:flags.2?string cache_time:int = messages.BotCallbackAnswer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotResults(TLObject):
    constructor_id = 0xccd3563d
    subclass_of_id = 0x3ed4d9c9

    def __init__(self, query_id, results, cache_time, gallery=None, next_offset=None, switch_pm=None):
        """
        :param gallery: Telegram type: "true".
        :param query_id: Telegram type: "long".
        :param next_offset: Telegram type: "string".
        :param switch_pm: Telegram type: "InlineBotSwitchPM".
        :param results: Telegram type: "BotInlineResult". Must be a list.
        :param cache_time: Telegram type: "int".

        Constructor for messages.BotResults: Instance of BotResults.
        """
        super().__init__()

        self.gallery = gallery
        self.query_id = query_id
        self.next_offset = next_offset
        self.switch_pm = switch_pm
        self.results = results
        self.cache_time = cache_time

    def to_dict(self):
        return {
            'gallery': self.gallery,
            'query_id': self.query_id,
            'next_offset': self.next_offset,
            'switch_pm': None if self.switch_pm is None else self.switch_pm.to_dict(),
            'results': [] if self.results is None else [None if x is None else x.to_dict() for x in self.results],
            'cache_time': self.cache_time,
        }

    def on_send(self, writer):
        writer.write_int(BotResults.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.gallery else 0
        flags |= (1 << 1) if self.next_offset else 0
        flags |= (1 << 2) if self.switch_pm else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        if self.next_offset:
            writer.tgwrite_string(self.next_offset)

        if self.switch_pm:
            self.switch_pm.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.results))
        for _x in self.results:
            _x.on_send(writer)

        writer.write_int(self.cache_time)

    @staticmethod
    def empty():
        return BotResults(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.gallery = True

        self.query_id = reader.read_long()
        if (flags & (1 << 1)) != 0:
            self.next_offset = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.switch_pm = reader.tgread_object()

        reader.read_int()
        self.results = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.results.append(_x)

        self.cache_time = reader.read_int()

    def __repr__(self):
        return 'messages.botResults#ccd3563d flags:# gallery:flags.0?true query_id:long next_offset:flags.1?string switch_pm:flags.2?InlineBotSwitchPM results:Vector<BotInlineResult> cache_time:int = messages.BotResults'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelMessages(TLObject):
    constructor_id = 0x99262e37
    subclass_of_id = 0xd4b40b5e

    def __init__(self, pts, count, messages, chats, users):
        """
        :param pts: Telegram type: "int".
        :param count: Telegram type: "int".
        :param messages: Telegram type: "Message". Must be a list.
        :param chats: Telegram type: "Chat". Must be a list.
        :param users: Telegram type: "User". Must be a list.

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.pts = pts
        self.count = count
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            'pts': self.pts,
            'count': self.count,
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(ChannelMessages.constructor_id, signed=False)
        flags = 0
        writer.write_int(flags)

        writer.write_int(self.pts)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ChannelMessages(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.pts = reader.read_int()
        self.count = reader.read_int()
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'messages.channelMessages#99262e37 flags:# pts:int count:int messages:Vector<Message> chats:Vector<Chat> users:Vector<User> = messages.Messages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatFull(TLObject):
    constructor_id = 0xe5d7d19c
    subclass_of_id = 0x225a5109

    def __init__(self, full_chat, chats, users):
        """
        :param full_chat: Telegram type: "ChatFull".
        :param chats: Telegram type: "Chat". Must be a list.
        :param users: Telegram type: "User". Must be a list.

        Constructor for messages.ChatFull: Instance of ChatFull.
        """
        super().__init__()

        self.full_chat = full_chat
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            'full_chat': None if self.full_chat is None else self.full_chat.to_dict(),
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(ChatFull.constructor_id, signed=False)
        self.full_chat.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ChatFull(None, None, None)

    def on_response(self, reader):
        self.full_chat = reader.tgread_object()
        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'messages.chatFull#e5d7d19c full_chat:ChatFull chats:Vector<Chat> users:Vector<User> = messages.ChatFull'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Chats(TLObject):
    constructor_id = 0x64ff9fd5
    subclass_of_id = 0x99d5cb14

    def __init__(self, chats):
        """
        :param chats: Telegram type: "Chat". Must be a list.

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()

        self.chats = chats

    def to_dict(self):
        return {
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
        }

    def on_send(self, writer):
        writer.write_int(Chats.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Chats(None)

    def on_response(self, reader):
        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

    def __repr__(self):
        return 'messages.chats#64ff9fd5 chats:Vector<Chat> = messages.Chats'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatsSlice(TLObject):
    constructor_id = 0x9cd81144
    subclass_of_id = 0x99d5cb14

    def __init__(self, count, chats):
        """
        :param count: Telegram type: "int".
        :param chats: Telegram type: "Chat". Must be a list.

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()

        self.count = count
        self.chats = chats

    def to_dict(self):
        return {
            'count': self.count,
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
        }

    def on_send(self, writer):
        writer.write_int(ChatsSlice.constructor_id, signed=False)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ChatsSlice(None, None)

    def on_response(self, reader):
        self.count = reader.read_int()
        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

    def __repr__(self):
        return 'messages.chatsSlice#9cd81144 count:int chats:Vector<Chat> = messages.Chats'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DhConfig(TLObject):
    constructor_id = 0x2c221edd
    subclass_of_id = 0xe488ed8b

    def __init__(self, g, p, version, random):
        """
        :param g: Telegram type: "int".
        :param p: Telegram type: "bytes".
        :param version: Telegram type: "int".
        :param random: Telegram type: "bytes".

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()

        self.g = g
        self.p = p
        self.version = version
        self.random = random

    def to_dict(self):
        return {
            'g': self.g,
            'p': self.p,
            'version': self.version,
            'random': self.random,
        }

    def on_send(self, writer):
        writer.write_int(DhConfig.constructor_id, signed=False)
        writer.write_int(self.g)
        writer.tgwrite_bytes(self.p)
        writer.write_int(self.version)
        writer.tgwrite_bytes(self.random)

    @staticmethod
    def empty():
        return DhConfig(None, None, None, None)

    def on_response(self, reader):
        self.g = reader.read_int()
        self.p = reader.tgread_bytes()
        self.version = reader.read_int()
        self.random = reader.tgread_bytes()

    def __repr__(self):
        return 'messages.dhConfig#2c221edd g:int p:bytes version:int random:bytes = messages.DhConfig'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DhConfigNotModified(TLObject):
    constructor_id = 0xc0e24635
    subclass_of_id = 0xe488ed8b

    def __init__(self, random):
        """
        :param random: Telegram type: "bytes".

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()

        self.random = random

    def to_dict(self):
        return {
            'random': self.random,
        }

    def on_send(self, writer):
        writer.write_int(DhConfigNotModified.constructor_id, signed=False)
        writer.tgwrite_bytes(self.random)

    @staticmethod
    def empty():
        return DhConfigNotModified(None)

    def on_response(self, reader):
        self.random = reader.tgread_bytes()

    def __repr__(self):
        return 'messages.dhConfigNotModified#c0e24635 random:bytes = messages.DhConfig'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Dialogs(TLObject):
    constructor_id = 0x15ba6c40
    subclass_of_id = 0xe1b52ee

    def __init__(self, dialogs, messages, chats, users):
        """
        :param dialogs: Telegram type: "Dialog". Must be a list.
        :param messages: Telegram type: "Message". Must be a list.
        :param chats: Telegram type: "Chat". Must be a list.
        :param users: Telegram type: "User". Must be a list.

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()

        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(Dialogs.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.dialogs))
        for _x in self.dialogs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Dialogs(None, None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.dialogs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.dialogs.append(_x)

        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'messages.dialogs#15ba6c40 dialogs:Vector<Dialog> messages:Vector<Message> chats:Vector<Chat> users:Vector<User> = messages.Dialogs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DialogsSlice(TLObject):
    constructor_id = 0x71e094f3
    subclass_of_id = 0xe1b52ee

    def __init__(self, count, dialogs, messages, chats, users):
        """
        :param count: Telegram type: "int".
        :param dialogs: Telegram type: "Dialog". Must be a list.
        :param messages: Telegram type: "Message". Must be a list.
        :param chats: Telegram type: "Chat". Must be a list.
        :param users: Telegram type: "User". Must be a list.

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()

        self.count = count
        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            'count': self.count,
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(DialogsSlice.constructor_id, signed=False)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.dialogs))
        for _x in self.dialogs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return DialogsSlice(None, None, None, None, None)

    def on_response(self, reader):
        self.count = reader.read_int()
        reader.read_int()
        self.dialogs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.dialogs.append(_x)

        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'messages.dialogsSlice#71e094f3 count:int dialogs:Vector<Dialog> messages:Vector<Message> chats:Vector<Chat> users:Vector<User> = messages.Dialogs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FavedStickers(TLObject):
    constructor_id = 0xf37f2f16
    subclass_of_id = 0x8e736fb9

    def __init__(self, hash, packs, stickers):
        """
        :param hash: Telegram type: "int".
        :param packs: Telegram type: "StickerPack". Must be a list.
        :param stickers: Telegram type: "Document". Must be a list.

        Constructor for messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        super().__init__()

        self.hash = hash
        self.packs = packs
        self.stickers = stickers

    def to_dict(self):
        return {
            'hash': self.hash,
            'packs': [] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs],
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
        }

    def on_send(self, writer):
        writer.write_int(FavedStickers.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.packs))
        for _x in self.packs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.stickers))
        for _x in self.stickers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return FavedStickers(None, None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.packs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.packs.append(_x)

        reader.read_int()
        self.stickers = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.stickers.append(_x)

    def __repr__(self):
        return 'messages.favedStickers#f37f2f16 hash:int packs:Vector<StickerPack> stickers:Vector<Document> = messages.FavedStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FavedStickersNotModified(TLObject):
    constructor_id = 0x9e8fa6d3
    subclass_of_id = 0x8e736fb9

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(FavedStickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return FavedStickersNotModified()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messages.favedStickersNotModified#9e8fa6d3 = messages.FavedStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FeaturedStickers(TLObject):
    constructor_id = 0xf89d88e5
    subclass_of_id = 0x2614b722

    def __init__(self, hash, sets, unread):
        """
        :param hash: Telegram type: "int".
        :param sets: Telegram type: "StickerSetCovered". Must be a list.
        :param unread: Telegram type: "long". Must be a list.

        Constructor for messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        super().__init__()

        self.hash = hash
        self.sets = sets
        self.unread = unread

    def to_dict(self):
        return {
            'hash': self.hash,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets],
            'unread': [] if self.unread is None else self.unread[:],
        }

    def on_send(self, writer):
        writer.write_int(FeaturedStickers.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.sets))
        for _x in self.sets:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.unread))
        for _x in self.unread:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return FeaturedStickers(None, None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.sets = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sets.append(_x)

        reader.read_int()
        self.unread = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.unread.append(_x)

    def __repr__(self):
        return 'messages.featuredStickers#f89d88e5 hash:int sets:Vector<StickerSetCovered> unread:Vector<long> = messages.FeaturedStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FeaturedStickersNotModified(TLObject):
    constructor_id = 0x4ede3cf
    subclass_of_id = 0x2614b722

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(FeaturedStickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return FeaturedStickersNotModified()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messages.featuredStickersNotModified#04ede3cf = messages.FeaturedStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FoundGifs(TLObject):
    constructor_id = 0x450a1c0a
    subclass_of_id = 0xe799ea7

    def __init__(self, next_offset, results):
        """
        :param next_offset: Telegram type: "int".
        :param results: Telegram type: "FoundGif". Must be a list.

        Constructor for messages.FoundGifs: Instance of FoundGifs.
        """
        super().__init__()

        self.next_offset = next_offset
        self.results = results

    def to_dict(self):
        return {
            'next_offset': self.next_offset,
            'results': [] if self.results is None else [None if x is None else x.to_dict() for x in self.results],
        }

    def on_send(self, writer):
        writer.write_int(FoundGifs.constructor_id, signed=False)
        writer.write_int(self.next_offset)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.results))
        for _x in self.results:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return FoundGifs(None, None)

    def on_response(self, reader):
        self.next_offset = reader.read_int()
        reader.read_int()
        self.results = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.results.append(_x)

    def __repr__(self):
        return 'messages.foundGifs#450a1c0a next_offset:int results:Vector<FoundGif> = messages.FoundGifs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class HighScores(TLObject):
    constructor_id = 0x9a3bfd99
    subclass_of_id = 0x6ccd95fd

    def __init__(self, scores, users):
        """
        :param scores: Telegram type: "HighScore". Must be a list.
        :param users: Telegram type: "User". Must be a list.

        Constructor for messages.HighScores: Instance of HighScores.
        """
        super().__init__()

        self.scores = scores
        self.users = users

    def to_dict(self):
        return {
            'scores': [] if self.scores is None else [None if x is None else x.to_dict() for x in self.scores],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(HighScores.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.scores))
        for _x in self.scores:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return HighScores(None, None)

    def on_response(self, reader):
        reader.read_int()
        self.scores = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.scores.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'messages.highScores#9a3bfd99 scores:Vector<HighScore> users:Vector<User> = messages.HighScores'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEditData(TLObject):
    constructor_id = 0x26b5dde6
    subclass_of_id = 0xfb47949d

    def __init__(self, caption=None):
        """
        :param caption: Telegram type: "true".

        Constructor for messages.MessageEditData: Instance of MessageEditData.
        """
        super().__init__()

        self.caption = caption

    def to_dict(self):
        return {
            'caption': self.caption,
        }

    def on_send(self, writer):
        writer.write_int(MessageEditData.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.caption else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return MessageEditData(None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.caption = True

    def __repr__(self):
        return 'messages.messageEditData#26b5dde6 flags:# caption:flags.0?true = messages.MessageEditData'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Messages(TLObject):
    constructor_id = 0x8c718e87
    subclass_of_id = 0xd4b40b5e

    def __init__(self, messages, chats, users):
        """
        :param messages: Telegram type: "Message". Must be a list.
        :param chats: Telegram type: "Chat". Must be a list.
        :param users: Telegram type: "User". Must be a list.

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(Messages.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Messages(None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'messages.messages#8c718e87 messages:Vector<Message> chats:Vector<Chat> users:Vector<User> = messages.Messages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessagesSlice(TLObject):
    constructor_id = 0xb446ae3
    subclass_of_id = 0xd4b40b5e

    def __init__(self, count, messages, chats, users):
        """
        :param count: Telegram type: "int".
        :param messages: Telegram type: "Message". Must be a list.
        :param chats: Telegram type: "Chat". Must be a list.
        :param users: Telegram type: "User". Must be a list.

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.count = count
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            'count': self.count,
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(MessagesSlice.constructor_id, signed=False)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return MessagesSlice(None, None, None, None)

    def on_response(self, reader):
        self.count = reader.read_int()
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'messages.messagesSlice#0b446ae3 count:int messages:Vector<Message> chats:Vector<Chat> users:Vector<User> = messages.Messages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerDialogs(TLObject):
    constructor_id = 0x3371c354
    subclass_of_id = 0x3ac70132

    def __init__(self, dialogs, messages, chats, users, state):
        """
        :param dialogs: Telegram type: "Dialog". Must be a list.
        :param messages: Telegram type: "Message". Must be a list.
        :param chats: Telegram type: "Chat". Must be a list.
        :param users: Telegram type: "User". Must be a list.
        :param state: Telegram type: "updates.State".

        Constructor for messages.PeerDialogs: Instance of PeerDialogs.
        """
        super().__init__()

        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users
        self.state = state

    def to_dict(self):
        return {
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'state': None if self.state is None else self.state.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PeerDialogs.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.dialogs))
        for _x in self.dialogs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.messages))
        for _x in self.messages:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

        self.state.on_send(writer)

    @staticmethod
    def empty():
        return PeerDialogs(None, None, None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.dialogs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.dialogs.append(_x)

        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.messages.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

        self.state = reader.tgread_object()

    def __repr__(self):
        return 'messages.peerDialogs#3371c354 dialogs:Vector<Dialog> messages:Vector<Message> chats:Vector<Chat> users:Vector<User> state:updates.State = messages.PeerDialogs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class RecentStickers(TLObject):
    constructor_id = 0x5ce20970
    subclass_of_id = 0xf76f8683

    def __init__(self, hash, stickers):
        """
        :param hash: Telegram type: "int".
        :param stickers: Telegram type: "Document". Must be a list.

        Constructor for messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        super().__init__()

        self.hash = hash
        self.stickers = stickers

    def to_dict(self):
        return {
            'hash': self.hash,
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
        }

    def on_send(self, writer):
        writer.write_int(RecentStickers.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.stickers))
        for _x in self.stickers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return RecentStickers(None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.stickers = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.stickers.append(_x)

    def __repr__(self):
        return 'messages.recentStickers#5ce20970 hash:int stickers:Vector<Document> = messages.RecentStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class RecentStickersNotModified(TLObject):
    constructor_id = 0xb17f890
    subclass_of_id = 0xf76f8683

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(RecentStickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return RecentStickersNotModified()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messages.recentStickersNotModified#0b17f890 = messages.RecentStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SavedGifs(TLObject):
    constructor_id = 0x2e0709a5
    subclass_of_id = 0xa68b61f5

    def __init__(self, hash, gifs):
        """
        :param hash: Telegram type: "int".
        :param gifs: Telegram type: "Document". Must be a list.

        Constructor for messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        super().__init__()

        self.hash = hash
        self.gifs = gifs

    def to_dict(self):
        return {
            'hash': self.hash,
            'gifs': [] if self.gifs is None else [None if x is None else x.to_dict() for x in self.gifs],
        }

    def on_send(self, writer):
        writer.write_int(SavedGifs.constructor_id, signed=False)
        writer.write_int(self.hash)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.gifs))
        for _x in self.gifs:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return SavedGifs(None, None)

    def on_response(self, reader):
        self.hash = reader.read_int()
        reader.read_int()
        self.gifs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.gifs.append(_x)

    def __repr__(self):
        return 'messages.savedGifs#2e0709a5 hash:int gifs:Vector<Document> = messages.SavedGifs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SavedGifsNotModified(TLObject):
    constructor_id = 0xe8025ca2
    subclass_of_id = 0xa68b61f5

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SavedGifsNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SavedGifsNotModified()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messages.savedGifsNotModified#e8025ca2 = messages.SavedGifs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SentEncryptedFile(TLObject):
    constructor_id = 0x9493ff32
    subclass_of_id = 0xc99e3e50

    def __init__(self, date, file):
        """
        :param date: Telegram type: "date".
        :param file: Telegram type: "EncryptedFile".

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()

        self.date = date
        self.file = file

    def to_dict(self):
        return {
            'date': self.date,
            'file': None if self.file is None else self.file.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(SentEncryptedFile.constructor_id, signed=False)
        writer.tgwrite_date(self.date)
        self.file.on_send(writer)

    @staticmethod
    def empty():
        return SentEncryptedFile(None, None)

    def on_response(self, reader):
        self.date = reader.tgread_date()
        self.file = reader.tgread_object()

    def __repr__(self):
        return 'messages.sentEncryptedFile#9493ff32 date:int file:EncryptedFile = messages.SentEncryptedMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SentEncryptedMessage(TLObject):
    constructor_id = 0x560f8935
    subclass_of_id = 0xc99e3e50

    def __init__(self, date):
        """
        :param date: Telegram type: "date".

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()

        self.date = date

    def to_dict(self):
        return {
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(SentEncryptedMessage.constructor_id, signed=False)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return SentEncryptedMessage(None)

    def on_response(self, reader):
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'messages.sentEncryptedMessage#560f8935 date:int = messages.SentEncryptedMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class StickerSet(TLObject):
    constructor_id = 0xb60a24a6
    subclass_of_id = 0x9b704a5a

    def __init__(self, set, packs, documents):
        """
        :param set: Telegram type: "StickerSet".
        :param packs: Telegram type: "StickerPack". Must be a list.
        :param documents: Telegram type: "Document". Must be a list.

        Constructor for messages.StickerSet: Instance of StickerSet.
        """
        super().__init__()

        self.set = set
        self.packs = packs
        self.documents = documents

    def to_dict(self):
        return {
            'set': None if self.set is None else self.set.to_dict(),
            'packs': [] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents],
        }

    def on_send(self, writer):
        writer.write_int(StickerSet.constructor_id, signed=False)
        self.set.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.packs))
        for _x in self.packs:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.documents))
        for _x in self.documents:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return StickerSet(None, None, None)

    def on_response(self, reader):
        self.set = reader.tgread_object()
        reader.read_int()
        self.packs = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.packs.append(_x)

        reader.read_int()
        self.documents = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.documents.append(_x)

    def __repr__(self):
        return 'messages.stickerSet#b60a24a6 set:StickerSet packs:Vector<StickerPack> documents:Vector<Document> = messages.StickerSet'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class StickerSetInstallResultArchive(TLObject):
    constructor_id = 0x35e410a8
    subclass_of_id = 0x67cb3fe8

    def __init__(self, sets):
        """
        :param sets: Telegram type: "StickerSetCovered". Must be a list.

        Constructor for messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        super().__init__()

        self.sets = sets

    def to_dict(self):
        return {
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets],
        }

    def on_send(self, writer):
        writer.write_int(StickerSetInstallResultArchive.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.sets))
        for _x in self.sets:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return StickerSetInstallResultArchive(None)

    def on_response(self, reader):
        reader.read_int()
        self.sets = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sets.append(_x)

    def __repr__(self):
        return 'messages.stickerSetInstallResultArchive#35e410a8 sets:Vector<StickerSetCovered> = messages.StickerSetInstallResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class StickerSetInstallResultSuccess(TLObject):
    constructor_id = 0x38641628
    subclass_of_id = 0x67cb3fe8

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(StickerSetInstallResultSuccess.constructor_id, signed=False)

    @staticmethod
    def empty():
        return StickerSetInstallResultSuccess()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messages.stickerSetInstallResultSuccess#38641628 = messages.StickerSetInstallResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Stickers(TLObject):
    constructor_id = 0x8a8ecd32
    subclass_of_id = 0xd73bb9de

    def __init__(self, hash, stickers):
        """
        :param hash: Telegram type: "string".
        :param stickers: Telegram type: "Document". Must be a list.

        Constructor for messages.Stickers: Instance of either StickersNotModified, Stickers.
        """
        super().__init__()

        self.hash = hash
        self.stickers = stickers

    def to_dict(self):
        return {
            'hash': self.hash,
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
        }

    def on_send(self, writer):
        writer.write_int(Stickers.constructor_id, signed=False)
        writer.tgwrite_string(self.hash)
        writer.write_int(0x1cb5c415, signed=False)  # Vector's constructor ID
        writer.write_int(len(self.stickers))
        for _x in self.stickers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Stickers(None, None)

    def on_response(self, reader):
        self.hash = reader.tgread_string()
        reader.read_int()
        self.stickers = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.stickers.append(_x)

    def __repr__(self):
        return 'messages.stickers#8a8ecd32 hash:string stickers:Vector<Document> = messages.Stickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class StickersNotModified(TLObject):
    constructor_id = 0xf1749a22
    subclass_of_id = 0xd73bb9de

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(StickersNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return StickersNotModified()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messages.stickersNotModified#f1749a22 = messages.Stickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

