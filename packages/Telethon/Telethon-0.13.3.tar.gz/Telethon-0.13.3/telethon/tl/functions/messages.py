"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject


class AcceptEncryptionRequest(TLObject):
    constructor_id = 0x3dbc0415
    subclass_of_id = 0x6d28a37a

    def __init__(self, peer, g_b, key_fingerprint):
        """
        :param peer: Telegram type: "InputEncryptedChat".
        :param g_b: Telegram type: "bytes".
        :param key_fingerprint: Telegram type: "long".

        :returns EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.g_b = g_b
        self.key_fingerprint = key_fingerprint

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'g_b': self.g_b,
            'key_fingerprint': self.key_fingerprint,
        }

    def on_send(self, writer):
        writer.write_int(AcceptEncryptionRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.tgwrite_bytes(self.g_b)
        writer.write_long(self.key_fingerprint)

    @staticmethod
    def empty():
        return AcceptEncryptionRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.acceptEncryption#3dbc0415 peer:InputEncryptedChat g_b:bytes key_fingerprint:long = EncryptedChat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user


class AddChatUserRequest(TLObject):
    constructor_id = 0xf9a0aa09
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, user_id, fwd_limit):
        """
        :param chat_id: Telegram type: "int".
        :param user_id: Telegram type: "InputUser".
        :param fwd_limit: Telegram type: "int".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)
        self.fwd_limit = fwd_limit

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'fwd_limit': self.fwd_limit,
        }

    def on_send(self, writer):
        writer.write_int(AddChatUserRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        self.user_id.on_send(writer)
        writer.write_int(self.fwd_limit)

    @staticmethod
    def empty():
        return AddChatUserRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.addChatUser#f9a0aa09 chat_id:int user_id:InputUser fwd_limit:int = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class CheckChatInviteRequest(TLObject):
    constructor_id = 0x3eadb1bb
    subclass_of_id = 0x4561736

    def __init__(self, hash):
        """
        :param hash: Telegram type: "string".

        :returns ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(CheckChatInviteRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.hash)

    @staticmethod
    def empty():
        return CheckChatInviteRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.checkChatInvite#3eadb1bb hash:string = ChatInvite'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ClearRecentStickersRequest(TLObject):
    constructor_id = 0x8999602d
    subclass_of_id = 0xf5b399ac

    def __init__(self, attached=None):
        """
        :param attached: Telegram type: "true".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached

    def to_dict(self):
        return {
            'attached': self.attached,
        }

    def on_send(self, writer):
        writer.write_int(ClearRecentStickersRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.attached else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return ClearRecentStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.clearRecentStickers#8999602d flags:# attached:flags.0?true = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user


class CreateChatRequest(TLObject):
    constructor_id = 0x9cb126e
    subclass_of_id = 0x8af52aac

    def __init__(self, users, title):
        """
        :param users: Telegram type: "InputUser". Must be a list.
        :param title: Telegram type: "string".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.users = [get_input_user(_x) for _x in users]
        self.title = title

    def to_dict(self):
        return {
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'title': self.title,
        }

    def on_send(self, writer):
        writer.write_int(CreateChatRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

        writer.tgwrite_string(self.title)

    @staticmethod
    def empty():
        return CreateChatRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.createChat#09cb126e users:Vector<InputUser> title:string = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user


class DeleteChatUserRequest(TLObject):
    constructor_id = 0xe0611f16
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, user_id):
        """
        :param chat_id: Telegram type: "int".
        :param user_id: Telegram type: "InputUser".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(DeleteChatUserRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        self.user_id.on_send(writer)

    @staticmethod
    def empty():
        return DeleteChatUserRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.deleteChatUser#e0611f16 chat_id:int user_id:InputUser = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class DeleteHistoryRequest(TLObject):
    constructor_id = 0x1c015b09
    subclass_of_id = 0x2c49c116

    def __init__(self, peer, max_id, just_clear=None):
        """
        :param just_clear: Telegram type: "true".
        :param peer: Telegram type: "InputPeer".
        :param max_id: Telegram type: "int".

        :returns messages.AffectedHistory: Instance of AffectedHistory.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.just_clear = just_clear
        self.peer = get_input_peer(peer)
        self.max_id = max_id

    def to_dict(self):
        return {
            'just_clear': self.just_clear,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(DeleteHistoryRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.just_clear else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return DeleteHistoryRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.deleteHistory#1c015b09 flags:# just_clear:flags.0?true peer:InputPeer max_id:int = messages.AffectedHistory'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DeleteMessagesRequest(TLObject):
    constructor_id = 0xe58e95d2
    subclass_of_id = 0xced3c06e

    def __init__(self, id, revoke=None):
        """
        :param revoke: Telegram type: "true".
        :param id: Telegram type: "int". Must be a list.

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.revoke = revoke
        self.id = id

    def to_dict(self):
        return {
            'revoke': self.revoke,
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(DeleteMessagesRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.revoke else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return DeleteMessagesRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.deleteMessages#e58e95d2 flags:# revoke:flags.0?true id:Vector<int> = messages.AffectedMessages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DiscardEncryptionRequest(TLObject):
    constructor_id = 0xedd923c5
    subclass_of_id = 0xf5b399ac

    def __init__(self, chat_id):
        """
        :param chat_id: Telegram type: "int".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(DiscardEncryptionRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return DiscardEncryptionRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.discardEncryption#edd923c5 chat_id:int = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user


class EditChatAdminRequest(TLObject):
    constructor_id = 0xa9e69f2e
    subclass_of_id = 0xf5b399ac

    def __init__(self, chat_id, user_id, is_admin):
        """
        :param chat_id: Telegram type: "int".
        :param user_id: Telegram type: "InputUser".
        :param is_admin: Telegram type: "Bool".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)
        self.is_admin = is_admin

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'is_admin': self.is_admin,
        }

    def on_send(self, writer):
        writer.write_int(EditChatAdminRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        self.user_id.on_send(writer)
        writer.tgwrite_bool(self.is_admin)

    @staticmethod
    def empty():
        return EditChatAdminRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.editChatAdmin#a9e69f2e chat_id:int user_id:InputUser is_admin:Bool = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EditChatPhotoRequest(TLObject):
    constructor_id = 0xca4c79d8
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, photo):
        """
        :param chat_id: Telegram type: "int".
        :param photo: Telegram type: "InputChatPhoto".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.photo = photo

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'photo': None if self.photo is None else self.photo.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(EditChatPhotoRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        self.photo.on_send(writer)

    @staticmethod
    def empty():
        return EditChatPhotoRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.editChatPhoto#ca4c79d8 chat_id:int photo:InputChatPhoto = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EditChatTitleRequest(TLObject):
    constructor_id = 0xdc452855
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, title):
        """
        :param chat_id: Telegram type: "int".
        :param title: Telegram type: "string".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.title = title

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'title': self.title,
        }

    def on_send(self, writer):
        writer.write_int(EditChatTitleRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.tgwrite_string(self.title)

    @staticmethod
    def empty():
        return EditChatTitleRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.editChatTitle#dc452855 chat_id:int title:string = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EditInlineBotMessageRequest(TLObject):
    constructor_id = 0x130c2c85
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, no_webpage=None, message=None, reply_markup=None, entities=None):
        """
        :param no_webpage: Telegram type: "true".
        :param id: Telegram type: "InputBotInlineMessageID".
        :param message: Telegram type: "string".
        :param reply_markup: Telegram type: "ReplyMarkup".
        :param entities: Telegram type: "MessageEntity". Must be a list.

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.id = id
        self.message = message
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self):
        return {
            'no_webpage': self.no_webpage,
            'id': None if self.id is None else self.id.to_dict(),
            'message': self.message,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
        }

    def on_send(self, writer):
        writer.write_int(EditInlineBotMessageRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 11) if self.message else 0
        flags |= (1 << 2) if self.reply_markup else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        self.id.on_send(writer)
        if self.message:
            writer.tgwrite_string(self.message)

        if self.reply_markup:
            self.reply_markup.on_send(writer)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return EditInlineBotMessageRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.editInlineBotMessage#130c2c85 flags:# no_webpage:flags.1?true id:InputBotInlineMessageID message:flags.11?string reply_markup:flags.2?ReplyMarkup entities:flags.3?Vector<MessageEntity> = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class EditMessageRequest(TLObject):
    constructor_id = 0xce91e4ca
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, id, no_webpage=None, message=None, reply_markup=None, entities=None):
        """
        :param no_webpage: Telegram type: "true".
        :param peer: Telegram type: "InputPeer".
        :param id: Telegram type: "int".
        :param message: Telegram type: "string".
        :param reply_markup: Telegram type: "ReplyMarkup".
        :param entities: Telegram type: "MessageEntity". Must be a list.

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.peer = get_input_peer(peer)
        self.id = id
        self.message = message
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self):
        return {
            'no_webpage': self.no_webpage,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id,
            'message': self.message,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
        }

    def on_send(self, writer):
        writer.write_int(EditMessageRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 11) if self.message else 0
        flags |= (1 << 2) if self.reply_markup else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.id)
        if self.message:
            writer.tgwrite_string(self.message)

        if self.reply_markup:
            self.reply_markup.on_send(writer)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return EditMessageRequest(None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.editMessage#ce91e4ca flags:# no_webpage:flags.1?true peer:InputPeer id:int message:flags.11?string reply_markup:flags.2?ReplyMarkup entities:flags.3?Vector<MessageEntity> = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ExportChatInviteRequest(TLObject):
    constructor_id = 0x7d885289
    subclass_of_id = 0xb4748a58

    def __init__(self, chat_id):
        """
        :param chat_id: Telegram type: "int".

        :returns ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(ExportChatInviteRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return ExportChatInviteRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.exportChatInvite#7d885289 chat_id:int = ExportedChatInvite'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FaveStickerRequest(TLObject):
    constructor_id = 0xb9ffc55b
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, unfave):
        """
        :param id: Telegram type: "InputDocument".
        :param unfave: Telegram type: "Bool".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.unfave = unfave

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
            'unfave': self.unfave,
        }

    def on_send(self, writer):
        writer.write_int(FaveStickerRequest.constructor_id, signed=False)
        self.id.on_send(writer)
        writer.tgwrite_bool(self.unfave)

    @staticmethod
    def empty():
        return FaveStickerRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.faveSticker#b9ffc55b id:InputDocument unfave:Bool = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer
import os


class ForwardMessageRequest(TLObject):
    constructor_id = 0x33963bf9
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, id, random_id=None):
        """
        :param peer: Telegram type: "InputPeer".
        :param id: Telegram type: "int".
        :param random_id: Telegram type: "long".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id,
            'random_id': self.random_id,
        }

    def on_send(self, writer):
        writer.write_int(ForwardMessageRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.id)
        writer.write_long(self.random_id)

    @staticmethod
    def empty():
        return ForwardMessageRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.forwardMessage#33963bf9 peer:InputPeer id:int random_id:long = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer
import os


class ForwardMessagesRequest(TLObject):
    constructor_id = 0x708e0195
    subclass_of_id = 0x8af52aac

    def __init__(self, from_peer, id, to_peer, silent=None, background=None, with_my_score=None, random_id=None):
        """
        :param silent: Telegram type: "true".
        :param background: Telegram type: "true".
        :param with_my_score: Telegram type: "true".
        :param from_peer: Telegram type: "InputPeer".
        :param id: Telegram type: "int". Must be a list.
        :param random_id: Telegram type: "long". Must be a list.
        :param to_peer: Telegram type: "InputPeer".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.with_my_score = with_my_score
        self.from_peer = get_input_peer(from_peer)
        self.id = id
        self.random_id = random_id if random_id is not None else [int.from_bytes(os.urandom(8), 'big', signed=True) for _ in range(len(id))]
        self.to_peer = get_input_peer(to_peer)

    def to_dict(self):
        return {
            'silent': self.silent,
            'background': self.background,
            'with_my_score': self.with_my_score,
            'from_peer': None if self.from_peer is None else self.from_peer.to_dict(),
            'id': [] if self.id is None else self.id[:],
            'random_id': [] if self.random_id is None else self.random_id[:],
            'to_peer': None if self.to_peer is None else self.to_peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ForwardMessagesRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 5) if self.silent else 0
        flags |= (1 << 6) if self.background else 0
        flags |= (1 << 8) if self.with_my_score else 0
        writer.write_int(flags)

        self.from_peer.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.random_id))
        for _x in self.random_id:
            writer.write_long(_x)

        self.to_peer.on_send(writer)

    @staticmethod
    def empty():
        return ForwardMessagesRequest(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.forwardMessages#708e0195 flags:# silent:flags.5?true background:flags.6?true with_my_score:flags.8?true from_peer:InputPeer id:Vector<int> random_id:Vector<long> to_peer:InputPeer = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetAllChatsRequest(TLObject):
    constructor_id = 0xeba80ff0
    subclass_of_id = 0x99d5cb14

    def __init__(self, except_ids):
        """
        :param except_ids: Telegram type: "int". Must be a list.

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.except_ids = except_ids

    def to_dict(self):
        return {
            'except_ids': [] if self.except_ids is None else self.except_ids[:],
        }

    def on_send(self, writer):
        writer.write_int(GetAllChatsRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.except_ids))
        for _x in self.except_ids:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return GetAllChatsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getAllChats#eba80ff0 except_ids:Vector<int> = messages.Chats'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetAllDraftsRequest(TLObject):
    constructor_id = 0x6a3f8d65
    subclass_of_id = 0x8af52aac

    def __init__(self):
        super().__init__()
        self.result = None
        self.content_related = True

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(GetAllDraftsRequest.constructor_id, signed=False)

    @staticmethod
    def empty():
        return GetAllDraftsRequest()

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getAllDrafts#6a3f8d65 = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetAllStickersRequest(TLObject):
    constructor_id = 0x1c9618b1
    subclass_of_id = 0x45834829

    def __init__(self, hash):
        """
        :param hash: Telegram type: "int".

        :returns messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetAllStickersRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetAllStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getAllStickers#1c9618b1 hash:int = messages.AllStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetArchivedStickersRequest(TLObject):
    constructor_id = 0x57f17692
    subclass_of_id = 0x7296d771

    def __init__(self, offset_id, limit, masks=None):
        """
        :param masks: Telegram type: "true".
        :param offset_id: Telegram type: "long".
        :param limit: Telegram type: "int".

        :returns messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.masks = masks
        self.offset_id = offset_id
        self.limit = limit

    def to_dict(self):
        return {
            'masks': self.masks,
            'offset_id': self.offset_id,
            'limit': self.limit,
        }

    def on_send(self, writer):
        writer.write_int(GetArchivedStickersRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.masks else 0
        writer.write_int(flags)

        writer.write_long(self.offset_id)
        writer.write_int(self.limit)

    @staticmethod
    def empty():
        return GetArchivedStickersRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getArchivedStickers#57f17692 flags:# masks:flags.0?true offset_id:long limit:int = messages.ArchivedStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetAttachedStickersRequest(TLObject):
    constructor_id = 0xcc5b67cc
    subclass_of_id = 0xcc125f6b

    def __init__(self, media):
        """
        :param media: Telegram type: "InputStickeredMedia".

        :returns Vector<StickerSetCovered>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.media = media

    def to_dict(self):
        return {
            'media': None if self.media is None else self.media.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(GetAttachedStickersRequest.constructor_id, signed=False)
        self.media.on_send(writer)

    @staticmethod
    def empty():
        return GetAttachedStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_vector()

    def __repr__(self):
        return 'messages.getAttachedStickers#cc5b67cc media:InputStickeredMedia = Vector<StickerSetCovered>'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class GetBotCallbackAnswerRequest(TLObject):
    constructor_id = 0x810a9fec
    subclass_of_id = 0x6c4dd18c

    def __init__(self, peer, msg_id, game=None, data=None):
        """
        :param game: Telegram type: "true".
        :param peer: Telegram type: "InputPeer".
        :param msg_id: Telegram type: "int".
        :param data: Telegram type: "bytes".

        :returns messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.game = game
        self.peer = get_input_peer(peer)
        self.msg_id = msg_id
        self.data = data

    def to_dict(self):
        return {
            'game': self.game,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'msg_id': self.msg_id,
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(GetBotCallbackAnswerRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.game else 0
        flags |= (1 << 0) if self.data else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.msg_id)
        if self.data:
            writer.tgwrite_bytes(self.data)

    @staticmethod
    def empty():
        return GetBotCallbackAnswerRequest(None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getBotCallbackAnswer#810a9fec flags:# game:flags.1?true peer:InputPeer msg_id:int data:flags.0?bytes = messages.BotCallbackAnswer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetChatsRequest(TLObject):
    constructor_id = 0x3c6aa187
    subclass_of_id = 0x99d5cb14

    def __init__(self, id):
        """
        :param id: Telegram type: "int". Must be a list.

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(GetChatsRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return GetChatsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getChats#3c6aa187 id:Vector<int> = messages.Chats'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user


class GetCommonChatsRequest(TLObject):
    constructor_id = 0xd0a48c4
    subclass_of_id = 0x99d5cb14

    def __init__(self, user_id, max_id, limit):
        """
        :param user_id: Telegram type: "InputUser".
        :param max_id: Telegram type: "int".
        :param limit: Telegram type: "int".

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.user_id = get_input_user(user_id)
        self.max_id = max_id
        self.limit = limit

    def to_dict(self):
        return {
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'max_id': self.max_id,
            'limit': self.limit,
        }

    def on_send(self, writer):
        writer.write_int(GetCommonChatsRequest.constructor_id, signed=False)
        self.user_id.on_send(writer)
        writer.write_int(self.max_id)
        writer.write_int(self.limit)

    @staticmethod
    def empty():
        return GetCommonChatsRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getCommonChats#0d0a48c4 user_id:InputUser max_id:int limit:int = messages.Chats'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetDhConfigRequest(TLObject):
    constructor_id = 0x26cf8950
    subclass_of_id = 0xe488ed8b

    def __init__(self, version, random_length):
        """
        :param version: Telegram type: "int".
        :param random_length: Telegram type: "int".

        :returns messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.version = version
        self.random_length = random_length

    def to_dict(self):
        return {
            'version': self.version,
            'random_length': self.random_length,
        }

    def on_send(self, writer):
        writer.write_int(GetDhConfigRequest.constructor_id, signed=False)
        writer.write_int(self.version)
        writer.write_int(self.random_length)

    @staticmethod
    def empty():
        return GetDhConfigRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getDhConfig#26cf8950 version:int random_length:int = messages.DhConfig'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class GetDialogsRequest(TLObject):
    constructor_id = 0x191ba9c5
    subclass_of_id = 0xe1b52ee

    def __init__(self, offset_date, offset_id, offset_peer, limit, exclude_pinned=None):
        """
        :param exclude_pinned: Telegram type: "true".
        :param offset_date: Telegram type: "date".
        :param offset_id: Telegram type: "int".
        :param offset_peer: Telegram type: "InputPeer".
        :param limit: Telegram type: "int".

        :returns messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.exclude_pinned = exclude_pinned
        self.offset_date = offset_date
        self.offset_id = offset_id
        self.offset_peer = get_input_peer(offset_peer)
        self.limit = limit

    def to_dict(self):
        return {
            'exclude_pinned': self.exclude_pinned,
            'offset_date': self.offset_date,
            'offset_id': self.offset_id,
            'offset_peer': None if self.offset_peer is None else self.offset_peer.to_dict(),
            'limit': self.limit,
        }

    def on_send(self, writer):
        writer.write_int(GetDialogsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.exclude_pinned else 0
        writer.write_int(flags)

        writer.tgwrite_date(self.offset_date)
        writer.write_int(self.offset_id)
        self.offset_peer.on_send(writer)
        writer.write_int(self.limit)

    @staticmethod
    def empty():
        return GetDialogsRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getDialogs#191ba9c5 flags:# exclude_pinned:flags.0?true offset_date:int offset_id:int offset_peer:InputPeer limit:int = messages.Dialogs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetDocumentByHashRequest(TLObject):
    constructor_id = 0x338e2464
    subclass_of_id = 0x211fe820

    def __init__(self, sha256, size, mime_type):
        """
        :param sha256: Telegram type: "bytes".
        :param size: Telegram type: "int".
        :param mime_type: Telegram type: "string".

        :returns Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.sha256 = sha256
        self.size = size
        self.mime_type = mime_type

    def to_dict(self):
        return {
            'sha256': self.sha256,
            'size': self.size,
            'mime_type': self.mime_type,
        }

    def on_send(self, writer):
        writer.write_int(GetDocumentByHashRequest.constructor_id, signed=False)
        writer.tgwrite_bytes(self.sha256)
        writer.write_int(self.size)
        writer.tgwrite_string(self.mime_type)

    @staticmethod
    def empty():
        return GetDocumentByHashRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getDocumentByHash#338e2464 sha256:bytes size:int mime_type:string = Document'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetFavedStickersRequest(TLObject):
    constructor_id = 0x21ce0b0e
    subclass_of_id = 0x8e736fb9

    def __init__(self, hash):
        """
        :param hash: Telegram type: "int".

        :returns messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetFavedStickersRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetFavedStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getFavedStickers#21ce0b0e hash:int = messages.FavedStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetFeaturedStickersRequest(TLObject):
    constructor_id = 0x2dacca4f
    subclass_of_id = 0x2614b722

    def __init__(self, hash):
        """
        :param hash: Telegram type: "int".

        :returns messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetFeaturedStickersRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetFeaturedStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getFeaturedStickers#2dacca4f hash:int = messages.FeaturedStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetFullChatRequest(TLObject):
    constructor_id = 0x3b831c66
    subclass_of_id = 0x225a5109

    def __init__(self, chat_id):
        """
        :param chat_id: Telegram type: "int".

        :returns messages.ChatFull: Instance of ChatFull.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(GetFullChatRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return GetFullChatRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getFullChat#3b831c66 chat_id:int = messages.ChatFull'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user, get_input_peer


class GetGameHighScoresRequest(TLObject):
    constructor_id = 0xe822649d
    subclass_of_id = 0x6ccd95fd

    def __init__(self, peer, id, user_id):
        """
        :param peer: Telegram type: "InputPeer".
        :param id: Telegram type: "int".
        :param user_id: Telegram type: "InputUser".

        :returns messages.HighScores: Instance of HighScores.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.user_id = get_input_user(user_id)

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(GetGameHighScoresRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.id)
        self.user_id.on_send(writer)

    @staticmethod
    def empty():
        return GetGameHighScoresRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getGameHighScores#e822649d peer:InputPeer id:int user_id:InputUser = messages.HighScores'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class GetHistoryRequest(TLObject):
    constructor_id = 0xafa92846
    subclass_of_id = 0xd4b40b5e

    def __init__(self, peer, offset_id, offset_date, add_offset, limit, max_id, min_id):
        """
        :param peer: Telegram type: "InputPeer".
        :param offset_id: Telegram type: "int".
        :param offset_date: Telegram type: "date".
        :param add_offset: Telegram type: "int".
        :param limit: Telegram type: "int".
        :param max_id: Telegram type: "int".
        :param min_id: Telegram type: "int".

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.offset_id = offset_id
        self.offset_date = offset_date
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'offset_id': self.offset_id,
            'offset_date': self.offset_date,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def on_send(self, writer):
        writer.write_int(GetHistoryRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.offset_id)
        writer.tgwrite_date(self.offset_date)
        writer.write_int(self.add_offset)
        writer.write_int(self.limit)
        writer.write_int(self.max_id)
        writer.write_int(self.min_id)

    @staticmethod
    def empty():
        return GetHistoryRequest(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getHistory#afa92846 peer:InputPeer offset_id:int offset_date:int add_offset:int limit:int max_id:int min_id:int = messages.Messages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user, get_input_peer


class GetInlineBotResultsRequest(TLObject):
    constructor_id = 0x514e999d
    subclass_of_id = 0x3ed4d9c9

    def __init__(self, bot, peer, query, offset, geo_point=None):
        """
        :param bot: Telegram type: "InputUser".
        :param peer: Telegram type: "InputPeer".
        :param geo_point: Telegram type: "InputGeoPoint".
        :param query: Telegram type: "string".
        :param offset: Telegram type: "string".

        :returns messages.BotResults: Instance of BotResults.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.bot = get_input_user(bot)
        self.peer = get_input_peer(peer)
        self.geo_point = geo_point
        self.query = query
        self.offset = offset

    def to_dict(self):
        return {
            'bot': None if self.bot is None else self.bot.to_dict(),
            'peer': None if self.peer is None else self.peer.to_dict(),
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'query': self.query,
            'offset': self.offset,
        }

    def on_send(self, writer):
        writer.write_int(GetInlineBotResultsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.geo_point else 0
        writer.write_int(flags)

        self.bot.on_send(writer)
        self.peer.on_send(writer)
        if self.geo_point:
            self.geo_point.on_send(writer)

        writer.tgwrite_string(self.query)
        writer.tgwrite_string(self.offset)

    @staticmethod
    def empty():
        return GetInlineBotResultsRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getInlineBotResults#514e999d flags:# bot:InputUser peer:InputPeer geo_point:flags.0?InputGeoPoint query:string offset:string = messages.BotResults'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user


class GetInlineGameHighScoresRequest(TLObject):
    constructor_id = 0xf635e1b
    subclass_of_id = 0x6ccd95fd

    def __init__(self, id, user_id):
        """
        :param id: Telegram type: "InputBotInlineMessageID".
        :param user_id: Telegram type: "InputUser".

        :returns messages.HighScores: Instance of HighScores.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.user_id = get_input_user(user_id)

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(GetInlineGameHighScoresRequest.constructor_id, signed=False)
        self.id.on_send(writer)
        self.user_id.on_send(writer)

    @staticmethod
    def empty():
        return GetInlineGameHighScoresRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getInlineGameHighScores#0f635e1b id:InputBotInlineMessageID user_id:InputUser = messages.HighScores'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetMaskStickersRequest(TLObject):
    constructor_id = 0x65b8c79f
    subclass_of_id = 0x45834829

    def __init__(self, hash):
        """
        :param hash: Telegram type: "int".

        :returns messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetMaskStickersRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetMaskStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getMaskStickers#65b8c79f hash:int = messages.AllStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class GetMessageEditDataRequest(TLObject):
    constructor_id = 0xfda68d36
    subclass_of_id = 0xfb47949d

    def __init__(self, peer, id):
        """
        :param peer: Telegram type: "InputPeer".
        :param id: Telegram type: "int".

        :returns messages.MessageEditData: Instance of MessageEditData.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(GetMessageEditDataRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.id)

    @staticmethod
    def empty():
        return GetMessageEditDataRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getMessageEditData#fda68d36 peer:InputPeer id:int = messages.MessageEditData'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetMessagesRequest(TLObject):
    constructor_id = 0x4222fa74
    subclass_of_id = 0xd4b40b5e

    def __init__(self, id):
        """
        :param id: Telegram type: "int". Must be a list.

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(GetMessagesRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return GetMessagesRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getMessages#4222fa74 id:Vector<int> = messages.Messages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class GetMessagesViewsRequest(TLObject):
    constructor_id = 0xc4c8a55d
    subclass_of_id = 0x5026710f

    def __init__(self, peer, id, increment):
        """
        :param peer: Telegram type: "InputPeer".
        :param id: Telegram type: "int". Must be a list.
        :param increment: Telegram type: "Bool".

        :returns Vector<int>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.increment = increment

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': [] if self.id is None else self.id[:],
            'increment': self.increment,
        }

    def on_send(self, writer):
        writer.write_int(GetMessagesViewsRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

        writer.tgwrite_bool(self.increment)

    @staticmethod
    def empty():
        return GetMessagesViewsRequest(None, None, None)

    def on_response(self, reader):
        reader.read_int()  # Vector id
        count = reader.read_int()
        self.result = [reader.read_int() for _ in range(count)]

    def __repr__(self):
        return 'messages.getMessagesViews#c4c8a55d peer:InputPeer id:Vector<int> increment:Bool = Vector<int>'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class GetPeerDialogsRequest(TLObject):
    constructor_id = 0x2d9776b9
    subclass_of_id = 0x3ac70132

    def __init__(self, peers):
        """
        :param peers: Telegram type: "InputPeer". Must be a list.

        :returns messages.PeerDialogs: Instance of PeerDialogs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peers = [get_input_peer(_x) for _x in peers]

    def to_dict(self):
        return {
            'peers': [] if self.peers is None else [None if x is None else x.to_dict() for x in self.peers],
        }

    def on_send(self, writer):
        writer.write_int(GetPeerDialogsRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.peers))
        for _x in self.peers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return GetPeerDialogsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getPeerDialogs#2d9776b9 peers:Vector<InputPeer> = messages.PeerDialogs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class GetPeerSettingsRequest(TLObject):
    constructor_id = 0x3672e09c
    subclass_of_id = 0xf6a79f84

    def __init__(self, peer):
        """
        :param peer: Telegram type: "InputPeer".

        :returns PeerSettings: Instance of PeerSettings.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(GetPeerSettingsRequest.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return GetPeerSettingsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getPeerSettings#3672e09c peer:InputPeer = PeerSettings'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetPinnedDialogsRequest(TLObject):
    constructor_id = 0xe254d64e
    subclass_of_id = 0x3ac70132

    def __init__(self):
        super().__init__()
        self.result = None
        self.content_related = True

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(GetPinnedDialogsRequest.constructor_id, signed=False)

    @staticmethod
    def empty():
        return GetPinnedDialogsRequest()

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getPinnedDialogs#e254d64e = messages.PeerDialogs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetRecentStickersRequest(TLObject):
    constructor_id = 0x5ea192c9
    subclass_of_id = 0xf76f8683

    def __init__(self, hash, attached=None):
        """
        :param attached: Telegram type: "true".
        :param hash: Telegram type: "int".

        :returns messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached
        self.hash = hash

    def to_dict(self):
        return {
            'attached': self.attached,
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetRecentStickersRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.attached else 0
        writer.write_int(flags)

        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetRecentStickersRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getRecentStickers#5ea192c9 flags:# attached:flags.0?true hash:int = messages.RecentStickers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetSavedGifsRequest(TLObject):
    constructor_id = 0x83bf3d52
    subclass_of_id = 0xa68b61f5

    def __init__(self, hash):
        """
        :param hash: Telegram type: "int".

        :returns messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetSavedGifsRequest.constructor_id, signed=False)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetSavedGifsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getSavedGifs#83bf3d52 hash:int = messages.SavedGifs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetStickerSetRequest(TLObject):
    constructor_id = 0x2619a90e
    subclass_of_id = 0x9b704a5a

    def __init__(self, stickerset):
        """
        :param stickerset: Telegram type: "InputStickerSet".

        :returns messages.StickerSet: Instance of StickerSet.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset

    def to_dict(self):
        return {
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(GetStickerSetRequest.constructor_id, signed=False)
        self.stickerset.on_send(writer)

    @staticmethod
    def empty():
        return GetStickerSetRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getStickerSet#2619a90e stickerset:InputStickerSet = messages.StickerSet'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class GetUnreadMentionsRequest(TLObject):
    constructor_id = 0x46578472
    subclass_of_id = 0xd4b40b5e

    def __init__(self, peer, offset_id, add_offset, limit, max_id, min_id):
        """
        :param peer: Telegram type: "InputPeer".
        :param offset_id: Telegram type: "int".
        :param add_offset: Telegram type: "int".
        :param limit: Telegram type: "int".
        :param max_id: Telegram type: "int".
        :param min_id: Telegram type: "int".

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.offset_id = offset_id
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'offset_id': self.offset_id,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def on_send(self, writer):
        writer.write_int(GetUnreadMentionsRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.offset_id)
        writer.write_int(self.add_offset)
        writer.write_int(self.limit)
        writer.write_int(self.max_id)
        writer.write_int(self.min_id)

    @staticmethod
    def empty():
        return GetUnreadMentionsRequest(None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getUnreadMentions#46578472 peer:InputPeer offset_id:int add_offset:int limit:int max_id:int min_id:int = messages.Messages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetWebPageRequest(TLObject):
    constructor_id = 0x32ca8f91
    subclass_of_id = 0x55a97481

    def __init__(self, url, hash):
        """
        :param url: Telegram type: "string".
        :param hash: Telegram type: "int".

        :returns WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.url = url
        self.hash = hash

    def to_dict(self):
        return {
            'url': self.url,
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(GetWebPageRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return GetWebPageRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getWebPage#32ca8f91 url:string hash:int = WebPage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GetWebPagePreviewRequest(TLObject):
    constructor_id = 0x25223e24
    subclass_of_id = 0x476cbe32

    def __init__(self, message):
        """
        :param message: Telegram type: "string".

        :returns MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.message = message

    def to_dict(self):
        return {
            'message': self.message,
        }

    def on_send(self, writer):
        writer.write_int(GetWebPagePreviewRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.message)

    @staticmethod
    def empty():
        return GetWebPagePreviewRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.getWebPagePreview#25223e24 message:string = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class HideReportSpamRequest(TLObject):
    constructor_id = 0xa8f1709b
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer):
        """
        :param peer: Telegram type: "InputPeer".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(HideReportSpamRequest.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return HideReportSpamRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.hideReportSpam#a8f1709b peer:InputPeer = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ImportChatInviteRequest(TLObject):
    constructor_id = 0x6c50051c
    subclass_of_id = 0x8af52aac

    def __init__(self, hash):
        """
        :param hash: Telegram type: "string".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self):
        return {
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(ImportChatInviteRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.hash)

    @staticmethod
    def empty():
        return ImportChatInviteRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.importChatInvite#6c50051c hash:string = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InstallStickerSetRequest(TLObject):
    constructor_id = 0xc78fe460
    subclass_of_id = 0x67cb3fe8

    def __init__(self, stickerset, archived):
        """
        :param stickerset: Telegram type: "InputStickerSet".
        :param archived: Telegram type: "Bool".

        :returns messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset
        self.archived = archived

    def to_dict(self):
        return {
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
            'archived': self.archived,
        }

    def on_send(self, writer):
        writer.write_int(InstallStickerSetRequest.constructor_id, signed=False)
        self.stickerset.on_send(writer)
        writer.tgwrite_bool(self.archived)

    @staticmethod
    def empty():
        return InstallStickerSetRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.installStickerSet#c78fe460 stickerset:InputStickerSet archived:Bool = messages.StickerSetInstallResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MigrateChatRequest(TLObject):
    constructor_id = 0x15a3b8e3
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id):
        """
        :param chat_id: Telegram type: "int".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(MigrateChatRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return MigrateChatRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.migrateChat#15a3b8e3 chat_id:int = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReadEncryptedHistoryRequest(TLObject):
    constructor_id = 0x7f4b690a
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, max_date):
        """
        :param peer: Telegram type: "InputEncryptedChat".
        :param max_date: Telegram type: "date".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.max_date = max_date

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_date': self.max_date,
        }

    def on_send(self, writer):
        writer.write_int(ReadEncryptedHistoryRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.tgwrite_date(self.max_date)

    @staticmethod
    def empty():
        return ReadEncryptedHistoryRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.readEncryptedHistory#7f4b690a peer:InputEncryptedChat max_date:int = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReadFeaturedStickersRequest(TLObject):
    constructor_id = 0x5b118126
    subclass_of_id = 0xf5b399ac

    def __init__(self, id):
        """
        :param id: Telegram type: "long". Must be a list.

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(ReadFeaturedStickersRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return ReadFeaturedStickersRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.readFeaturedStickers#5b118126 id:Vector<long> = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class ReadHistoryRequest(TLObject):
    constructor_id = 0xe306d3a
    subclass_of_id = 0xced3c06e

    def __init__(self, peer, max_id):
        """
        :param peer: Telegram type: "InputPeer".
        :param max_id: Telegram type: "int".

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.max_id = max_id

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(ReadHistoryRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return ReadHistoryRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.readHistory#0e306d3a peer:InputPeer max_id:int = messages.AffectedMessages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReadMessageContentsRequest(TLObject):
    constructor_id = 0x36a73f77
    subclass_of_id = 0xced3c06e

    def __init__(self, id):
        """
        :param id: Telegram type: "int". Must be a list.

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def on_send(self, writer):
        writer.write_int(ReadMessageContentsRequest.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.id))
        for _x in self.id:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return ReadMessageContentsRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.readMessageContents#36a73f77 id:Vector<int> = messages.AffectedMessages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReceivedMessagesRequest(TLObject):
    constructor_id = 0x5a954c0
    subclass_of_id = 0x8565f897

    def __init__(self, max_id):
        """
        :param max_id: Telegram type: "int".

        :returns Vector<ReceivedNotifyMessage>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.max_id = max_id

    def to_dict(self):
        return {
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(ReceivedMessagesRequest.constructor_id, signed=False)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return ReceivedMessagesRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_vector()

    def __repr__(self):
        return 'messages.receivedMessages#05a954c0 max_id:int = Vector<ReceivedNotifyMessage>'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReceivedQueueRequest(TLObject):
    constructor_id = 0x55a5bb66
    subclass_of_id = 0x8918e168

    def __init__(self, max_qts):
        """
        :param max_qts: Telegram type: "int".

        :returns Vector<long>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.max_qts = max_qts

    def to_dict(self):
        return {
            'max_qts': self.max_qts,
        }

    def on_send(self, writer):
        writer.write_int(ReceivedQueueRequest.constructor_id, signed=False)
        writer.write_int(self.max_qts)

    @staticmethod
    def empty():
        return ReceivedQueueRequest(None)

    def on_response(self, reader):
        reader.read_int()  # Vector id
        count = reader.read_long()
        self.result = [reader.read_long() for _ in range(count)]

    def __repr__(self):
        return 'messages.receivedQueue#55a5bb66 max_qts:int = Vector<long>'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class ReorderPinnedDialogsRequest(TLObject):
    constructor_id = 0x959ff644
    subclass_of_id = 0xf5b399ac

    def __init__(self, order, force=None):
        """
        :param force: Telegram type: "true".
        :param order: Telegram type: "InputPeer". Must be a list.

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.force = force
        self.order = [get_input_peer(_x) for _x in order]

    def to_dict(self):
        return {
            'force': self.force,
            'order': [] if self.order is None else [None if x is None else x.to_dict() for x in self.order],
        }

    def on_send(self, writer):
        writer.write_int(ReorderPinnedDialogsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.force else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.order))
        for _x in self.order:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ReorderPinnedDialogsRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.reorderPinnedDialogs#959ff644 flags:# force:flags.0?true order:Vector<InputPeer> = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReorderStickerSetsRequest(TLObject):
    constructor_id = 0x78337739
    subclass_of_id = 0xf5b399ac

    def __init__(self, order, masks=None):
        """
        :param masks: Telegram type: "true".
        :param order: Telegram type: "long". Must be a list.

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.masks = masks
        self.order = order

    def to_dict(self):
        return {
            'masks': self.masks,
            'order': [] if self.order is None else self.order[:],
        }

    def on_send(self, writer):
        writer.write_int(ReorderStickerSetsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.masks else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.order))
        for _x in self.order:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return ReorderStickerSetsRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.reorderStickerSets#78337739 flags:# masks:flags.0?true order:Vector<long> = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReportEncryptedSpamRequest(TLObject):
    constructor_id = 0x4b0c8c0f
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer):
        """
        :param peer: Telegram type: "InputEncryptedChat".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ReportEncryptedSpamRequest.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return ReportEncryptedSpamRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.reportEncryptedSpam#4b0c8c0f peer:InputEncryptedChat = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class ReportSpamRequest(TLObject):
    constructor_id = 0xcf1592db
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer):
        """
        :param peer: Telegram type: "InputPeer".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ReportSpamRequest.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return ReportSpamRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.reportSpam#cf1592db peer:InputPeer = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user
import os


class RequestEncryptionRequest(TLObject):
    constructor_id = 0xf64daf43
    subclass_of_id = 0x6d28a37a

    def __init__(self, user_id, g_a, random_id=None):
        """
        :param user_id: Telegram type: "InputUser".
        :param random_id: Telegram type: "int".
        :param g_a: Telegram type: "bytes".

        :returns EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.user_id = get_input_user(user_id)
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(4), 'big', signed=True)
        self.g_a = g_a

    def to_dict(self):
        return {
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'random_id': self.random_id,
            'g_a': self.g_a,
        }

    def on_send(self, writer):
        writer.write_int(RequestEncryptionRequest.constructor_id, signed=False)
        self.user_id.on_send(writer)
        writer.write_int(self.random_id)
        writer.tgwrite_bytes(self.g_a)

    @staticmethod
    def empty():
        return RequestEncryptionRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.requestEncryption#f64daf43 user_id:InputUser random_id:int g_a:bytes = EncryptedChat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class SaveDraftRequest(TLObject):
    constructor_id = 0xbc39e14b
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, message, no_webpage=None, reply_to_msg_id=None, entities=None):
        """
        :param no_webpage: Telegram type: "true".
        :param reply_to_msg_id: Telegram type: "int".
        :param peer: Telegram type: "InputPeer".
        :param message: Telegram type: "string".
        :param entities: Telegram type: "MessageEntity". Must be a list.

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.reply_to_msg_id = reply_to_msg_id
        self.peer = get_input_peer(peer)
        self.message = message
        self.entities = entities

    def to_dict(self):
        return {
            'no_webpage': self.no_webpage,
            'reply_to_msg_id': self.reply_to_msg_id,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
        }

    def on_send(self, writer):
        writer.write_int(SaveDraftRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        self.peer.on_send(writer)
        writer.tgwrite_string(self.message)
        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return SaveDraftRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.saveDraft#bc39e14b flags:# no_webpage:flags.1?true reply_to_msg_id:flags.0?int peer:InputPeer message:string entities:flags.3?Vector<MessageEntity> = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SaveGifRequest(TLObject):
    constructor_id = 0x327a30cb
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, unsave):
        """
        :param id: Telegram type: "InputDocument".
        :param unsave: Telegram type: "Bool".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.unsave = unsave

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
            'unsave': self.unsave,
        }

    def on_send(self, writer):
        writer.write_int(SaveGifRequest.constructor_id, signed=False)
        self.id.on_send(writer)
        writer.tgwrite_bool(self.unsave)

    @staticmethod
    def empty():
        return SaveGifRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.saveGif#327a30cb id:InputDocument unsave:Bool = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SaveRecentStickerRequest(TLObject):
    constructor_id = 0x392718f8
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, unsave, attached=None):
        """
        :param attached: Telegram type: "true".
        :param id: Telegram type: "InputDocument".
        :param unsave: Telegram type: "Bool".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached
        self.id = id
        self.unsave = unsave

    def to_dict(self):
        return {
            'attached': self.attached,
            'id': None if self.id is None else self.id.to_dict(),
            'unsave': self.unsave,
        }

    def on_send(self, writer):
        writer.write_int(SaveRecentStickerRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.attached else 0
        writer.write_int(flags)

        self.id.on_send(writer)
        writer.tgwrite_bool(self.unsave)

    @staticmethod
    def empty():
        return SaveRecentStickerRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.saveRecentSticker#392718f8 flags:# attached:flags.0?true id:InputDocument unsave:Bool = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user, get_input_peer


class SearchRequest(TLObject):
    constructor_id = 0x39e9ea0
    subclass_of_id = 0xd4b40b5e

    def __init__(self, peer, q, filter, min_date, max_date, offset_id, add_offset, limit, max_id, min_id, from_id=None):
        """
        :param peer: Telegram type: "InputPeer".
        :param q: Telegram type: "string".
        :param from_id: Telegram type: "InputUser".
        :param filter: Telegram type: "MessagesFilter".
        :param min_date: Telegram type: "date".
        :param max_date: Telegram type: "date".
        :param offset_id: Telegram type: "int".
        :param add_offset: Telegram type: "int".
        :param limit: Telegram type: "int".
        :param max_id: Telegram type: "int".
        :param min_id: Telegram type: "int".

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.q = q
        self.from_id = get_input_user(from_id)
        self.filter = filter
        self.min_date = min_date
        self.max_date = max_date
        self.offset_id = offset_id
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'q': self.q,
            'from_id': None if self.from_id is None else self.from_id.to_dict(),
            'filter': None if self.filter is None else self.filter.to_dict(),
            'min_date': self.min_date,
            'max_date': self.max_date,
            'offset_id': self.offset_id,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def on_send(self, writer):
        writer.write_int(SearchRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.from_id else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.tgwrite_string(self.q)
        if self.from_id:
            self.from_id.on_send(writer)

        self.filter.on_send(writer)
        writer.tgwrite_date(self.min_date)
        writer.tgwrite_date(self.max_date)
        writer.write_int(self.offset_id)
        writer.write_int(self.add_offset)
        writer.write_int(self.limit)
        writer.write_int(self.max_id)
        writer.write_int(self.min_id)

    @staticmethod
    def empty():
        return SearchRequest(None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.search#039e9ea0 flags:# peer:InputPeer q:string from_id:flags.0?InputUser filter:MessagesFilter min_date:int max_date:int offset_id:int add_offset:int limit:int max_id:int min_id:int = messages.Messages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SearchGifsRequest(TLObject):
    constructor_id = 0xbf9a776b
    subclass_of_id = 0xe799ea7

    def __init__(self, q, offset):
        """
        :param q: Telegram type: "string".
        :param offset: Telegram type: "int".

        :returns messages.FoundGifs: Instance of FoundGifs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.q = q
        self.offset = offset

    def to_dict(self):
        return {
            'q': self.q,
            'offset': self.offset,
        }

    def on_send(self, writer):
        writer.write_int(SearchGifsRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.q)
        writer.write_int(self.offset)

    @staticmethod
    def empty():
        return SearchGifsRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.searchGifs#bf9a776b q:string offset:int = messages.FoundGifs'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class SearchGlobalRequest(TLObject):
    constructor_id = 0x9e3cacb0
    subclass_of_id = 0xd4b40b5e

    def __init__(self, q, offset_date, offset_peer, offset_id, limit):
        """
        :param q: Telegram type: "string".
        :param offset_date: Telegram type: "date".
        :param offset_peer: Telegram type: "InputPeer".
        :param offset_id: Telegram type: "int".
        :param limit: Telegram type: "int".

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.q = q
        self.offset_date = offset_date
        self.offset_peer = get_input_peer(offset_peer)
        self.offset_id = offset_id
        self.limit = limit

    def to_dict(self):
        return {
            'q': self.q,
            'offset_date': self.offset_date,
            'offset_peer': None if self.offset_peer is None else self.offset_peer.to_dict(),
            'offset_id': self.offset_id,
            'limit': self.limit,
        }

    def on_send(self, writer):
        writer.write_int(SearchGlobalRequest.constructor_id, signed=False)
        writer.tgwrite_string(self.q)
        writer.tgwrite_date(self.offset_date)
        self.offset_peer.on_send(writer)
        writer.write_int(self.offset_id)
        writer.write_int(self.limit)

    @staticmethod
    def empty():
        return SearchGlobalRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.searchGlobal#9e3cacb0 q:string offset_date:int offset_peer:InputPeer offset_id:int limit:int = messages.Messages'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

import os


class SendEncryptedRequest(TLObject):
    constructor_id = 0xa9776773
    subclass_of_id = 0xc99e3e50

    def __init__(self, peer, data, random_id=None):
        """
        :param peer: Telegram type: "InputEncryptedChat".
        :param random_id: Telegram type: "long".
        :param data: Telegram type: "bytes".

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'random_id': self.random_id,
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(SendEncryptedRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_long(self.random_id)
        writer.tgwrite_bytes(self.data)

    @staticmethod
    def empty():
        return SendEncryptedRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.sendEncrypted#a9776773 peer:InputEncryptedChat random_id:long data:bytes = messages.SentEncryptedMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

import os


class SendEncryptedFileRequest(TLObject):
    constructor_id = 0x9a901b66
    subclass_of_id = 0xc99e3e50

    def __init__(self, peer, data, file, random_id=None):
        """
        :param peer: Telegram type: "InputEncryptedChat".
        :param random_id: Telegram type: "long".
        :param data: Telegram type: "bytes".
        :param file: Telegram type: "InputEncryptedFile".

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data
        self.file = file

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'random_id': self.random_id,
            'data': self.data,
            'file': None if self.file is None else self.file.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(SendEncryptedFileRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_long(self.random_id)
        writer.tgwrite_bytes(self.data)
        self.file.on_send(writer)

    @staticmethod
    def empty():
        return SendEncryptedFileRequest(None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.sendEncryptedFile#9a901b66 peer:InputEncryptedChat random_id:long data:bytes file:InputEncryptedFile = messages.SentEncryptedMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

import os


class SendEncryptedServiceRequest(TLObject):
    constructor_id = 0x32d439a4
    subclass_of_id = 0xc99e3e50

    def __init__(self, peer, data, random_id=None):
        """
        :param peer: Telegram type: "InputEncryptedChat".
        :param random_id: Telegram type: "long".
        :param data: Telegram type: "bytes".

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'random_id': self.random_id,
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(SendEncryptedServiceRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_long(self.random_id)
        writer.tgwrite_bytes(self.data)

    @staticmethod
    def empty():
        return SendEncryptedServiceRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.sendEncryptedService#32d439a4 peer:InputEncryptedChat random_id:long data:bytes = messages.SentEncryptedMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer
import os


class SendInlineBotResultRequest(TLObject):
    constructor_id = 0xb16e06fe
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, query_id, id, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None):
        """
        :param silent: Telegram type: "true".
        :param background: Telegram type: "true".
        :param clear_draft: Telegram type: "true".
        :param peer: Telegram type: "InputPeer".
        :param reply_to_msg_id: Telegram type: "int".
        :param random_id: Telegram type: "long".
        :param query_id: Telegram type: "long".
        :param id: Telegram type: "string".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.query_id = query_id
        self.id = id

    def to_dict(self):
        return {
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id,
            'query_id': self.query_id,
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(SendInlineBotResultRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 5) if self.silent else 0
        flags |= (1 << 6) if self.background else 0
        flags |= (1 << 7) if self.clear_draft else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        writer.write_long(self.random_id)
        writer.write_long(self.query_id)
        writer.tgwrite_string(self.id)

    @staticmethod
    def empty():
        return SendInlineBotResultRequest(None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.sendInlineBotResult#b16e06fe flags:# silent:flags.5?true background:flags.6?true clear_draft:flags.7?true peer:InputPeer reply_to_msg_id:flags.0?int random_id:long query_id:long id:string = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer
import os


class SendMediaRequest(TLObject):
    constructor_id = 0xc8f16791
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, media, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None, reply_markup=None):
        """
        :param silent: Telegram type: "true".
        :param background: Telegram type: "true".
        :param clear_draft: Telegram type: "true".
        :param peer: Telegram type: "InputPeer".
        :param reply_to_msg_id: Telegram type: "int".
        :param media: Telegram type: "InputMedia".
        :param random_id: Telegram type: "long".
        :param reply_markup: Telegram type: "ReplyMarkup".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.media = media
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'reply_to_msg_id': self.reply_to_msg_id,
            'media': None if self.media is None else self.media.to_dict(),
            'random_id': self.random_id,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(SendMediaRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 5) if self.silent else 0
        flags |= (1 << 6) if self.background else 0
        flags |= (1 << 7) if self.clear_draft else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        self.media.on_send(writer)
        writer.write_long(self.random_id)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return SendMediaRequest(None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.sendMedia#c8f16791 flags:# silent:flags.5?true background:flags.6?true clear_draft:flags.7?true peer:InputPeer reply_to_msg_id:flags.0?int media:InputMedia random_id:long reply_markup:flags.2?ReplyMarkup = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer
import os


class SendMessageRequest(TLObject):
    constructor_id = 0xfa88427a
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, message, no_webpage=None, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None, reply_markup=None, entities=None):
        """
        :param no_webpage: Telegram type: "true".
        :param silent: Telegram type: "true".
        :param background: Telegram type: "true".
        :param clear_draft: Telegram type: "true".
        :param peer: Telegram type: "InputPeer".
        :param reply_to_msg_id: Telegram type: "int".
        :param message: Telegram type: "string".
        :param random_id: Telegram type: "long".
        :param reply_markup: Telegram type: "ReplyMarkup".
        :param entities: Telegram type: "MessageEntity". Must be a list.

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.message = message
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self):
        return {
            'no_webpage': self.no_webpage,
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'reply_to_msg_id': self.reply_to_msg_id,
            'message': self.message,
            'random_id': self.random_id,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
        }

    def on_send(self, writer):
        writer.write_int(SendMessageRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 5) if self.silent else 0
        flags |= (1 << 6) if self.background else 0
        flags |= (1 << 7) if self.clear_draft else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        flags |= (1 << 2) if self.reply_markup else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        writer.tgwrite_string(self.message)
        writer.write_long(self.random_id)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return SendMessageRequest(None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.sendMessage#fa88427a flags:# no_webpage:flags.1?true silent:flags.5?true background:flags.6?true clear_draft:flags.7?true peer:InputPeer reply_to_msg_id:flags.0?int message:string random_id:long reply_markup:flags.2?ReplyMarkup entities:flags.3?Vector<MessageEntity> = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer
import os


class SendScreenshotNotificationRequest(TLObject):
    constructor_id = 0xc97df020
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, reply_to_msg_id, random_id=None):
        """
        :param peer: Telegram type: "InputPeer".
        :param reply_to_msg_id: Telegram type: "int".
        :param random_id: Telegram type: "long".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id,
        }

    def on_send(self, writer):
        writer.write_int(SendScreenshotNotificationRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.reply_to_msg_id)
        writer.write_long(self.random_id)

    @staticmethod
    def empty():
        return SendScreenshotNotificationRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.sendScreenshotNotification#c97df020 peer:InputPeer reply_to_msg_id:int random_id:long = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SetBotCallbackAnswerRequest(TLObject):
    constructor_id = 0xd58f130a
    subclass_of_id = 0xf5b399ac

    def __init__(self, query_id, cache_time, alert=None, message=None, url=None):
        """
        :param alert: Telegram type: "true".
        :param query_id: Telegram type: "long".
        :param message: Telegram type: "string".
        :param url: Telegram type: "string".
        :param cache_time: Telegram type: "int".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.alert = alert
        self.query_id = query_id
        self.message = message
        self.url = url
        self.cache_time = cache_time

    def to_dict(self):
        return {
            'alert': self.alert,
            'query_id': self.query_id,
            'message': self.message,
            'url': self.url,
            'cache_time': self.cache_time,
        }

    def on_send(self, writer):
        writer.write_int(SetBotCallbackAnswerRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.alert else 0
        flags |= (1 << 0) if self.message else 0
        flags |= (1 << 2) if self.url else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        if self.message:
            writer.tgwrite_string(self.message)

        if self.url:
            writer.tgwrite_string(self.url)

        writer.write_int(self.cache_time)

    @staticmethod
    def empty():
        return SetBotCallbackAnswerRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.setBotCallbackAnswer#d58f130a flags:# alert:flags.1?true query_id:long message:flags.0?string url:flags.2?string cache_time:int = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SetBotPrecheckoutResultsRequest(TLObject):
    constructor_id = 0x9c2dd95
    subclass_of_id = 0xf5b399ac

    def __init__(self, query_id, success=None, error=None):
        """
        :param success: Telegram type: "true".
        :param query_id: Telegram type: "long".
        :param error: Telegram type: "string".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.success = success
        self.query_id = query_id
        self.error = error

    def to_dict(self):
        return {
            'success': self.success,
            'query_id': self.query_id,
            'error': self.error,
        }

    def on_send(self, writer):
        writer.write_int(SetBotPrecheckoutResultsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.success else 0
        flags |= (1 << 0) if self.error else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        if self.error:
            writer.tgwrite_string(self.error)

    @staticmethod
    def empty():
        return SetBotPrecheckoutResultsRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.setBotPrecheckoutResults#09c2dd95 flags:# success:flags.1?true query_id:long error:flags.0?string = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SetBotShippingResultsRequest(TLObject):
    constructor_id = 0xe5f672fa
    subclass_of_id = 0xf5b399ac

    def __init__(self, query_id, error=None, shipping_options=None):
        """
        :param query_id: Telegram type: "long".
        :param error: Telegram type: "string".
        :param shipping_options: Telegram type: "ShippingOption". Must be a list.

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.query_id = query_id
        self.error = error
        self.shipping_options = shipping_options

    def to_dict(self):
        return {
            'query_id': self.query_id,
            'error': self.error,
            'shipping_options': [] if self.shipping_options is None else [None if x is None else x.to_dict() for x in self.shipping_options],
        }

    def on_send(self, writer):
        writer.write_int(SetBotShippingResultsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.error else 0
        flags |= (1 << 1) if self.shipping_options else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        if self.error:
            writer.tgwrite_string(self.error)

        if self.shipping_options:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.shipping_options))
            for _x in self.shipping_options:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return SetBotShippingResultsRequest(None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.setBotShippingResults#e5f672fa flags:# query_id:long error:flags.0?string shipping_options:flags.1?Vector<ShippingOption> = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SetEncryptedTypingRequest(TLObject):
    constructor_id = 0x791451ed
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, typing):
        """
        :param peer: Telegram type: "InputEncryptedChat".
        :param typing: Telegram type: "Bool".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.typing = typing

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'typing': self.typing,
        }

    def on_send(self, writer):
        writer.write_int(SetEncryptedTypingRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.tgwrite_bool(self.typing)

    @staticmethod
    def empty():
        return SetEncryptedTypingRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.setEncryptedTyping#791451ed peer:InputEncryptedChat typing:Bool = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user, get_input_peer


class SetGameScoreRequest(TLObject):
    constructor_id = 0x8ef8ecc0
    subclass_of_id = 0x8af52aac

    def __init__(self, peer, id, user_id, score, edit_message=None, force=None):
        """
        :param edit_message: Telegram type: "true".
        :param force: Telegram type: "true".
        :param peer: Telegram type: "InputPeer".
        :param id: Telegram type: "int".
        :param user_id: Telegram type: "InputUser".
        :param score: Telegram type: "int".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.edit_message = edit_message
        self.force = force
        self.peer = get_input_peer(peer)
        self.id = id
        self.user_id = get_input_user(user_id)
        self.score = score

    def to_dict(self):
        return {
            'edit_message': self.edit_message,
            'force': self.force,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'score': self.score,
        }

    def on_send(self, writer):
        writer.write_int(SetGameScoreRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.edit_message else 0
        flags |= (1 << 1) if self.force else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.id)
        self.user_id.on_send(writer)
        writer.write_int(self.score)

    @staticmethod
    def empty():
        return SetGameScoreRequest(None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.setGameScore#8ef8ecc0 flags:# edit_message:flags.0?true force:flags.1?true peer:InputPeer id:int user_id:InputUser score:int = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SetInlineBotResultsRequest(TLObject):
    constructor_id = 0xeb5ea206
    subclass_of_id = 0xf5b399ac

    def __init__(self, query_id, results, cache_time, gallery=None, private=None, next_offset=None, switch_pm=None):
        """
        :param gallery: Telegram type: "true".
        :param private: Telegram type: "true".
        :param query_id: Telegram type: "long".
        :param results: Telegram type: "InputBotInlineResult". Must be a list.
        :param cache_time: Telegram type: "int".
        :param next_offset: Telegram type: "string".
        :param switch_pm: Telegram type: "InlineBotSwitchPM".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.gallery = gallery
        self.private = private
        self.query_id = query_id
        self.results = results
        self.cache_time = cache_time
        self.next_offset = next_offset
        self.switch_pm = switch_pm

    def to_dict(self):
        return {
            'gallery': self.gallery,
            'private': self.private,
            'query_id': self.query_id,
            'results': [] if self.results is None else [None if x is None else x.to_dict() for x in self.results],
            'cache_time': self.cache_time,
            'next_offset': self.next_offset,
            'switch_pm': None if self.switch_pm is None else self.switch_pm.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(SetInlineBotResultsRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.gallery else 0
        flags |= (1 << 1) if self.private else 0
        flags |= (1 << 2) if self.next_offset else 0
        flags |= (1 << 3) if self.switch_pm else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.results))
        for _x in self.results:
            _x.on_send(writer)

        writer.write_int(self.cache_time)
        if self.next_offset:
            writer.tgwrite_string(self.next_offset)

        if self.switch_pm:
            self.switch_pm.on_send(writer)

    @staticmethod
    def empty():
        return SetInlineBotResultsRequest(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.setInlineBotResults#eb5ea206 flags:# gallery:flags.0?true private:flags.1?true query_id:long results:Vector<InputBotInlineResult> cache_time:int next_offset:flags.2?string switch_pm:flags.3?InlineBotSwitchPM = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user


class SetInlineGameScoreRequest(TLObject):
    constructor_id = 0x15ad9f64
    subclass_of_id = 0xf5b399ac

    def __init__(self, id, user_id, score, edit_message=None, force=None):
        """
        :param edit_message: Telegram type: "true".
        :param force: Telegram type: "true".
        :param id: Telegram type: "InputBotInlineMessageID".
        :param user_id: Telegram type: "InputUser".
        :param score: Telegram type: "int".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.edit_message = edit_message
        self.force = force
        self.id = id
        self.user_id = get_input_user(user_id)
        self.score = score

    def to_dict(self):
        return {
            'edit_message': self.edit_message,
            'force': self.force,
            'id': None if self.id is None else self.id.to_dict(),
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'score': self.score,
        }

    def on_send(self, writer):
        writer.write_int(SetInlineGameScoreRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.edit_message else 0
        flags |= (1 << 1) if self.force else 0
        writer.write_int(flags)

        self.id.on_send(writer)
        self.user_id.on_send(writer)
        writer.write_int(self.score)

    @staticmethod
    def empty():
        return SetInlineGameScoreRequest(None, None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.setInlineGameScore#15ad9f64 flags:# edit_message:flags.0?true force:flags.1?true id:InputBotInlineMessageID user_id:InputUser score:int = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class SetTypingRequest(TLObject):
    constructor_id = 0xa3825e50
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, action):
        """
        :param peer: Telegram type: "InputPeer".
        :param action: Telegram type: "SendMessageAction".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.action = action

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'action': None if self.action is None else self.action.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(SetTypingRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        self.action.on_send(writer)

    @staticmethod
    def empty():
        return SetTypingRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.setTyping#a3825e50 peer:InputPeer action:SendMessageAction = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_user, get_input_peer
import os


class StartBotRequest(TLObject):
    constructor_id = 0xe6df7378
    subclass_of_id = 0x8af52aac

    def __init__(self, bot, peer, start_param, random_id=None):
        """
        :param bot: Telegram type: "InputUser".
        :param peer: Telegram type: "InputPeer".
        :param random_id: Telegram type: "long".
        :param start_param: Telegram type: "string".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.bot = get_input_user(bot)
        self.peer = get_input_peer(peer)
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.start_param = start_param

    def to_dict(self):
        return {
            'bot': None if self.bot is None else self.bot.to_dict(),
            'peer': None if self.peer is None else self.peer.to_dict(),
            'random_id': self.random_id,
            'start_param': self.start_param,
        }

    def on_send(self, writer):
        writer.write_int(StartBotRequest.constructor_id, signed=False)
        self.bot.on_send(writer)
        self.peer.on_send(writer)
        writer.write_long(self.random_id)
        writer.tgwrite_string(self.start_param)

    @staticmethod
    def empty():
        return StartBotRequest(None, None, None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.startBot#e6df7378 bot:InputUser peer:InputPeer random_id:long start_param:string = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ToggleChatAdminsRequest(TLObject):
    constructor_id = 0xec8bd9e1
    subclass_of_id = 0x8af52aac

    def __init__(self, chat_id, enabled):
        """
        :param chat_id: Telegram type: "int".
        :param enabled: Telegram type: "Bool".

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.enabled = enabled

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'enabled': self.enabled,
        }

    def on_send(self, writer):
        writer.write_int(ToggleChatAdminsRequest.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.tgwrite_bool(self.enabled)

    @staticmethod
    def empty():
        return ToggleChatAdminsRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.toggleChatAdmins#ec8bd9e1 chat_id:int enabled:Bool = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class ToggleDialogPinRequest(TLObject):
    constructor_id = 0x3289be6a
    subclass_of_id = 0xf5b399ac

    def __init__(self, peer, pinned=None):
        """
        :param pinned: Telegram type: "true".
        :param peer: Telegram type: "InputPeer".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.pinned = pinned
        self.peer = get_input_peer(peer)

    def to_dict(self):
        return {
            'pinned': self.pinned,
            'peer': None if self.peer is None else self.peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ToggleDialogPinRequest.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.pinned else 0
        writer.write_int(flags)

        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return ToggleDialogPinRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.toggleDialogPin#3289be6a flags:# pinned:flags.0?true peer:InputPeer = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UninstallStickerSetRequest(TLObject):
    constructor_id = 0xf96e55de
    subclass_of_id = 0xf5b399ac

    def __init__(self, stickerset):
        """
        :param stickerset: Telegram type: "InputStickerSet".

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset

    def to_dict(self):
        return {
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UninstallStickerSetRequest.constructor_id, signed=False)
        self.stickerset.on_send(writer)

    @staticmethod
    def empty():
        return UninstallStickerSetRequest(None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.uninstallStickerSet#f96e55de stickerset:InputStickerSet = Bool'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

from ...utils import get_input_peer


class UploadMediaRequest(TLObject):
    constructor_id = 0x519bc2b1
    subclass_of_id = 0x476cbe32

    def __init__(self, peer, media):
        """
        :param peer: Telegram type: "InputPeer".
        :param media: Telegram type: "InputMedia".

        :returns MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.media = media

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'media': None if self.media is None else self.media.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UploadMediaRequest.constructor_id, signed=False)
        self.peer.on_send(writer)
        self.media.on_send(writer)

    @staticmethod
    def empty():
        return UploadMediaRequest(None, None)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __repr__(self):
        return 'messages.uploadMedia#519bc2b1 peer:InputPeer media:InputMedia = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

