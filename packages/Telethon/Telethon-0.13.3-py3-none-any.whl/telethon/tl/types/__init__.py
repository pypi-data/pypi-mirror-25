"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from . import help, storage, auth, contacts, messages, updates, photos, upload, account, channels, payments, phone


class AccountDaysTTL(TLObject):
    constructor_id = 0xb8d0afdf
    subclass_of_id = 0xbaa39d88

    def __init__(self, days):
        """
        :param days: Telegram type: "int".

        Constructor for AccountDaysTTL: Instance of AccountDaysTTL.
        """
        super().__init__()

        self.days = days

    def to_dict(self):
        return {
            'days': self.days,
        }

    def on_send(self, writer):
        writer.write_int(AccountDaysTTL.constructor_id, signed=False)
        writer.write_int(self.days)

    @staticmethod
    def empty():
        return AccountDaysTTL(None)

    def on_response(self, reader):
        self.days = reader.read_int()

    def __repr__(self):
        return 'accountDaysTTL#b8d0afdf days:int = AccountDaysTTL'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Authorization(TLObject):
    constructor_id = 0x7bf2e6f6
    subclass_of_id = 0xc913c01a

    def __init__(self, hash, flags, device_model, platform, system_version, api_id, app_name, app_version, date_created, date_active, ip, country, region):
        """
        :param hash: Telegram type: "long".
        :param flags: Telegram type: "int".
        :param device_model: Telegram type: "string".
        :param platform: Telegram type: "string".
        :param system_version: Telegram type: "string".
        :param api_id: Telegram type: "int".
        :param app_name: Telegram type: "string".
        :param app_version: Telegram type: "string".
        :param date_created: Telegram type: "int".
        :param date_active: Telegram type: "int".
        :param ip: Telegram type: "string".
        :param country: Telegram type: "string".
        :param region: Telegram type: "string".

        Constructor for Authorization: Instance of Authorization.
        """
        super().__init__()

        self.hash = hash
        self.flags = flags
        self.device_model = device_model
        self.platform = platform
        self.system_version = system_version
        self.api_id = api_id
        self.app_name = app_name
        self.app_version = app_version
        self.date_created = date_created
        self.date_active = date_active
        self.ip = ip
        self.country = country
        self.region = region

    def to_dict(self):
        return {
            'hash': self.hash,
            'flags': self.flags,
            'device_model': self.device_model,
            'platform': self.platform,
            'system_version': self.system_version,
            'api_id': self.api_id,
            'app_name': self.app_name,
            'app_version': self.app_version,
            'date_created': self.date_created,
            'date_active': self.date_active,
            'ip': self.ip,
            'country': self.country,
            'region': self.region,
        }

    def on_send(self, writer):
        writer.write_int(Authorization.constructor_id, signed=False)
        writer.write_long(self.hash)
        writer.write_int(self.flags)
        writer.tgwrite_string(self.device_model)
        writer.tgwrite_string(self.platform)
        writer.tgwrite_string(self.system_version)
        writer.write_int(self.api_id)
        writer.tgwrite_string(self.app_name)
        writer.tgwrite_string(self.app_version)
        writer.write_int(self.date_created)
        writer.write_int(self.date_active)
        writer.tgwrite_string(self.ip)
        writer.tgwrite_string(self.country)
        writer.tgwrite_string(self.region)

    @staticmethod
    def empty():
        return Authorization(None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.hash = reader.read_long()
        self.flags = reader.read_int()
        self.device_model = reader.tgread_string()
        self.platform = reader.tgread_string()
        self.system_version = reader.tgread_string()
        self.api_id = reader.read_int()
        self.app_name = reader.tgread_string()
        self.app_version = reader.tgread_string()
        self.date_created = reader.read_int()
        self.date_active = reader.read_int()
        self.ip = reader.tgread_string()
        self.country = reader.tgread_string()
        self.region = reader.tgread_string()

    def __repr__(self):
        return 'authorization#7bf2e6f6 hash:long flags:int device_model:string platform:string system_version:string api_id:int app_name:string app_version:string date_created:int date_active:int ip:string country:string region:string = Authorization'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BadMsgNotification(TLObject):
    constructor_id = 0xa7eff811
    subclass_of_id = 0xcebaa157

    def __init__(self, bad_msg_id, bad_msg_seqno, error_code):
        """
        :param bad_msg_id: Telegram type: "long".
        :param bad_msg_seqno: Telegram type: "int".
        :param error_code: Telegram type: "int".

        Constructor for BadMsgNotification: Instance of either BadMsgNotification, BadServerSalt.
        """
        super().__init__()

        self.bad_msg_id = bad_msg_id
        self.bad_msg_seqno = bad_msg_seqno
        self.error_code = error_code

    def to_dict(self):
        return {
            'bad_msg_id': self.bad_msg_id,
            'bad_msg_seqno': self.bad_msg_seqno,
            'error_code': self.error_code,
        }

    def on_send(self, writer):
        writer.write_int(BadMsgNotification.constructor_id, signed=False)
        writer.write_long(self.bad_msg_id)
        writer.write_int(self.bad_msg_seqno)
        writer.write_int(self.error_code)

    @staticmethod
    def empty():
        return BadMsgNotification(None, None, None)

    def on_response(self, reader):
        self.bad_msg_id = reader.read_long()
        self.bad_msg_seqno = reader.read_int()
        self.error_code = reader.read_int()

    def __repr__(self):
        return 'bad_msg_notification#a7eff811 bad_msg_id:long bad_msg_seqno:int error_code:int = BadMsgNotification'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BadServerSalt(TLObject):
    constructor_id = 0xedab447b
    subclass_of_id = 0xcebaa157

    def __init__(self, bad_msg_id, bad_msg_seqno, error_code, new_server_salt):
        """
        :param bad_msg_id: Telegram type: "long".
        :param bad_msg_seqno: Telegram type: "int".
        :param error_code: Telegram type: "int".
        :param new_server_salt: Telegram type: "long".

        Constructor for BadMsgNotification: Instance of either BadMsgNotification, BadServerSalt.
        """
        super().__init__()

        self.bad_msg_id = bad_msg_id
        self.bad_msg_seqno = bad_msg_seqno
        self.error_code = error_code
        self.new_server_salt = new_server_salt

    def to_dict(self):
        return {
            'bad_msg_id': self.bad_msg_id,
            'bad_msg_seqno': self.bad_msg_seqno,
            'error_code': self.error_code,
            'new_server_salt': self.new_server_salt,
        }

    def on_send(self, writer):
        writer.write_int(BadServerSalt.constructor_id, signed=False)
        writer.write_long(self.bad_msg_id)
        writer.write_int(self.bad_msg_seqno)
        writer.write_int(self.error_code)
        writer.write_long(self.new_server_salt)

    @staticmethod
    def empty():
        return BadServerSalt(None, None, None, None)

    def on_response(self, reader):
        self.bad_msg_id = reader.read_long()
        self.bad_msg_seqno = reader.read_int()
        self.error_code = reader.read_int()
        self.new_server_salt = reader.read_long()

    def __repr__(self):
        return 'bad_server_salt#edab447b bad_msg_id:long bad_msg_seqno:int error_code:int new_server_salt:long = BadMsgNotification'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotCommand(TLObject):
    constructor_id = 0xc27ac8c7
    subclass_of_id = 0xe1e62c2

    def __init__(self, command, description):
        """
        :param command: Telegram type: "string".
        :param description: Telegram type: "string".

        Constructor for BotCommand: Instance of BotCommand.
        """
        super().__init__()

        self.command = command
        self.description = description

    def to_dict(self):
        return {
            'command': self.command,
            'description': self.description,
        }

    def on_send(self, writer):
        writer.write_int(BotCommand.constructor_id, signed=False)
        writer.tgwrite_string(self.command)
        writer.tgwrite_string(self.description)

    @staticmethod
    def empty():
        return BotCommand(None, None)

    def on_response(self, reader):
        self.command = reader.tgread_string()
        self.description = reader.tgread_string()

    def __repr__(self):
        return 'botCommand#c27ac8c7 command:string description:string = BotCommand'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotInfo(TLObject):
    constructor_id = 0x98e81d3a
    subclass_of_id = 0xf1f701db

    def __init__(self, user_id, description, commands):
        """
        :param user_id: Telegram type: "int".
        :param description: Telegram type: "string".
        :param commands: Telegram type: "BotCommand". Must be a list.

        Constructor for BotInfo: Instance of BotInfo.
        """
        super().__init__()

        self.user_id = user_id
        self.description = description
        self.commands = commands

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'description': self.description,
            'commands': [] if self.commands is None else [None if x is None else x.to_dict() for x in self.commands],
        }

    def on_send(self, writer):
        writer.write_int(BotInfo.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_string(self.description)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.commands))
        for _x in self.commands:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return BotInfo(None, None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.description = reader.tgread_string()
        reader.read_int()
        self.commands = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.commands.append(_x)

    def __repr__(self):
        return 'botInfo#98e81d3a user_id:int description:string commands:Vector<BotCommand> = BotInfo'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotInlineMediaResult(TLObject):
    constructor_id = 0x17db940b
    subclass_of_id = 0x3832b3d5

    def __init__(self, id, type, send_message, photo=None, document=None, title=None, description=None):
        """
        :param id: Telegram type: "string".
        :param type: Telegram type: "string".
        :param photo: Telegram type: "Photo".
        :param document: Telegram type: "Document".
        :param title: Telegram type: "string".
        :param description: Telegram type: "string".
        :param send_message: Telegram type: "BotInlineMessage".

        Constructor for BotInlineResult: Instance of either BotInlineResult, BotInlineMediaResult.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.photo = photo
        self.document = document
        self.title = title
        self.description = description
        self.send_message = send_message

    def to_dict(self):
        return {
            'id': self.id,
            'type': self.type,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict(),
            'title': self.title,
            'description': self.description,
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(BotInlineMediaResult.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.photo else 0
        flags |= (1 << 1) if self.document else 0
        flags |= (1 << 2) if self.title else 0
        flags |= (1 << 3) if self.description else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.type)
        if self.photo:
            self.photo.on_send(writer)

        if self.document:
            self.document.on_send(writer)

        if self.title:
            writer.tgwrite_string(self.title)

        if self.description:
            writer.tgwrite_string(self.description)

        self.send_message.on_send(writer)

    @staticmethod
    def empty():
        return BotInlineMediaResult(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.tgread_string()
        self.type = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.photo = reader.tgread_object()

        if (flags & (1 << 1)) != 0:
            self.document = reader.tgread_object()

        if (flags & (1 << 2)) != 0:
            self.title = reader.tgread_string()

        if (flags & (1 << 3)) != 0:
            self.description = reader.tgread_string()

        self.send_message = reader.tgread_object()

    def __repr__(self):
        return 'botInlineMediaResult#17db940b flags:# id:string type:string photo:flags.0?Photo document:flags.1?Document title:flags.2?string description:flags.3?string send_message:BotInlineMessage = BotInlineResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotInlineMessageMediaAuto(TLObject):
    constructor_id = 0xa74b15b
    subclass_of_id = 0xc4910f88

    def __init__(self, caption, reply_markup=None):
        """
        :param caption: Telegram type: "string".
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.caption = caption
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'caption': self.caption,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(BotInlineMessageMediaAuto.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.caption)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return BotInlineMessageMediaAuto(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.caption = reader.tgread_string()
        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'botInlineMessageMediaAuto#0a74b15b flags:# caption:string reply_markup:flags.2?ReplyMarkup = BotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotInlineMessageMediaContact(TLObject):
    constructor_id = 0x35edb4d4
    subclass_of_id = 0xc4910f88

    def __init__(self, phone_number, first_name, last_name, reply_markup=None):
        """
        :param phone_number: Telegram type: "string".
        :param first_name: Telegram type: "string".
        :param last_name: Telegram type: "string".
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(BotInlineMessageMediaContact.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.phone_number)
        writer.tgwrite_string(self.first_name)
        writer.tgwrite_string(self.last_name)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return BotInlineMessageMediaContact(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.phone_number = reader.tgread_string()
        self.first_name = reader.tgread_string()
        self.last_name = reader.tgread_string()
        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'botInlineMessageMediaContact#35edb4d4 flags:# phone_number:string first_name:string last_name:string reply_markup:flags.2?ReplyMarkup = BotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotInlineMessageMediaGeo(TLObject):
    constructor_id = 0x3a8fd8b8
    subclass_of_id = 0xc4910f88

    def __init__(self, geo, reply_markup=None):
        """
        :param geo: Telegram type: "GeoPoint".
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.geo = geo
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'geo': None if self.geo is None else self.geo.to_dict(),
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(BotInlineMessageMediaGeo.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        self.geo.on_send(writer)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return BotInlineMessageMediaGeo(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.geo = reader.tgread_object()
        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'botInlineMessageMediaGeo#3a8fd8b8 flags:# geo:GeoPoint reply_markup:flags.2?ReplyMarkup = BotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotInlineMessageMediaVenue(TLObject):
    constructor_id = 0x4366232e
    subclass_of_id = 0xc4910f88

    def __init__(self, geo, title, address, provider, venue_id, reply_markup=None):
        """
        :param geo: Telegram type: "GeoPoint".
        :param title: Telegram type: "string".
        :param address: Telegram type: "string".
        :param provider: Telegram type: "string".
        :param venue_id: Telegram type: "string".
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.geo = geo
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'geo': None if self.geo is None else self.geo.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(BotInlineMessageMediaVenue.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        self.geo.on_send(writer)
        writer.tgwrite_string(self.title)
        writer.tgwrite_string(self.address)
        writer.tgwrite_string(self.provider)
        writer.tgwrite_string(self.venue_id)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return BotInlineMessageMediaVenue(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.geo = reader.tgread_object()
        self.title = reader.tgread_string()
        self.address = reader.tgread_string()
        self.provider = reader.tgread_string()
        self.venue_id = reader.tgread_string()
        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'botInlineMessageMediaVenue#4366232e flags:# geo:GeoPoint title:string address:string provider:string venue_id:string reply_markup:flags.2?ReplyMarkup = BotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotInlineMessageText(TLObject):
    constructor_id = 0x8c7f65e2
    subclass_of_id = 0xc4910f88

    def __init__(self, message, no_webpage=None, entities=None, reply_markup=None):
        """
        :param no_webpage: Telegram type: "true".
        :param message: Telegram type: "string".
        :param entities: Telegram type: "MessageEntity". Must be a list.
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.no_webpage = no_webpage
        self.message = message
        self.entities = entities
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'no_webpage': self.no_webpage,
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(BotInlineMessageText.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.no_webpage else 0
        flags |= (1 << 1) if self.entities else 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.message)
        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return BotInlineMessageText(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.no_webpage = True

        self.message = reader.tgread_string()
        if (flags & (1 << 1)) != 0:
            reader.read_int()
            self.entities = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.entities.append(_x)

        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'botInlineMessageText#8c7f65e2 flags:# no_webpage:flags.0?true message:string entities:flags.1?Vector<MessageEntity> reply_markup:flags.2?ReplyMarkup = BotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class BotInlineResult(TLObject):
    constructor_id = 0x9bebaeb9
    subclass_of_id = 0x3832b3d5

    def __init__(self, id, type, send_message, title=None, description=None, url=None, thumb_url=None, content_url=None, content_type=None, w=None, h=None, duration=None):
        """
        :param id: Telegram type: "string".
        :param type: Telegram type: "string".
        :param title: Telegram type: "string".
        :param description: Telegram type: "string".
        :param url: Telegram type: "string".
        :param thumb_url: Telegram type: "string".
        :param content_url: Telegram type: "string".
        :param content_type: Telegram type: "string".
        :param w: Telegram type: "int".
        :param h: Telegram type: "int".
        :param duration: Telegram type: "int".
        :param send_message: Telegram type: "BotInlineMessage".

        Constructor for BotInlineResult: Instance of either BotInlineResult, BotInlineMediaResult.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.url = url
        self.thumb_url = thumb_url
        self.content_url = content_url
        self.content_type = content_type
        self.w = w
        self.h = h
        self.duration = duration
        self.send_message = send_message

    def to_dict(self):
        return {
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h,
            'duration': self.duration,
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(BotInlineResult.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.title else 0
        flags |= (1 << 2) if self.description else 0
        flags |= (1 << 3) if self.url else 0
        flags |= (1 << 4) if self.thumb_url else 0
        flags |= (1 << 5) if self.content_url else 0
        flags |= (1 << 5) if self.content_type else 0
        flags |= (1 << 6) if self.w else 0
        flags |= (1 << 6) if self.h else 0
        flags |= (1 << 7) if self.duration else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.type)
        if self.title:
            writer.tgwrite_string(self.title)

        if self.description:
            writer.tgwrite_string(self.description)

        if self.url:
            writer.tgwrite_string(self.url)

        if self.thumb_url:
            writer.tgwrite_string(self.thumb_url)

        if self.content_url:
            writer.tgwrite_string(self.content_url)

        if self.content_type:
            writer.tgwrite_string(self.content_type)

        if self.w:
            writer.write_int(self.w)

        if self.h:
            writer.write_int(self.h)

        if self.duration:
            writer.write_int(self.duration)

        self.send_message.on_send(writer)

    @staticmethod
    def empty():
        return BotInlineResult(None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.tgread_string()
        self.type = reader.tgread_string()
        if (flags & (1 << 1)) != 0:
            self.title = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.description = reader.tgread_string()

        if (flags & (1 << 3)) != 0:
            self.url = reader.tgread_string()

        if (flags & (1 << 4)) != 0:
            self.thumb_url = reader.tgread_string()

        if (flags & (1 << 5)) != 0:
            self.content_url = reader.tgread_string()

        if (flags & (1 << 5)) != 0:
            self.content_type = reader.tgread_string()

        if (flags & (1 << 6)) != 0:
            self.w = reader.read_int()

        if (flags & (1 << 6)) != 0:
            self.h = reader.read_int()

        if (flags & (1 << 7)) != 0:
            self.duration = reader.read_int()

        self.send_message = reader.tgread_object()

    def __repr__(self):
        return 'botInlineResult#9bebaeb9 flags:# id:string type:string title:flags.1?string description:flags.2?string url:flags.3?string thumb_url:flags.4?string content_url:flags.5?string content_type:flags.5?string w:flags.6?int h:flags.6?int duration:flags.7?int send_message:BotInlineMessage = BotInlineResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class CdnConfig(TLObject):
    constructor_id = 0x5725e40a
    subclass_of_id = 0xecda397c

    def __init__(self, public_keys):
        """
        :param public_keys: Telegram type: "CdnPublicKey". Must be a list.

        Constructor for CdnConfig: Instance of CdnConfig.
        """
        super().__init__()

        self.public_keys = public_keys

    def to_dict(self):
        return {
            'public_keys': [] if self.public_keys is None else [None if x is None else x.to_dict() for x in self.public_keys],
        }

    def on_send(self, writer):
        writer.write_int(CdnConfig.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.public_keys))
        for _x in self.public_keys:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return CdnConfig(None)

    def on_response(self, reader):
        reader.read_int()
        self.public_keys = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.public_keys.append(_x)

    def __repr__(self):
        return 'cdnConfig#5725e40a public_keys:Vector<CdnPublicKey> = CdnConfig'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class CdnFileHash(TLObject):
    constructor_id = 0x77eec38f
    subclass_of_id = 0xe776d7e4

    def __init__(self, offset, limit, hash):
        """
        :param offset: Telegram type: "int".
        :param limit: Telegram type: "int".
        :param hash: Telegram type: "bytes".

        Constructor for CdnFileHash: Instance of CdnFileHash.
        """
        super().__init__()

        self.offset = offset
        self.limit = limit
        self.hash = hash

    def to_dict(self):
        return {
            'offset': self.offset,
            'limit': self.limit,
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(CdnFileHash.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.limit)
        writer.tgwrite_bytes(self.hash)

    @staticmethod
    def empty():
        return CdnFileHash(None, None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.limit = reader.read_int()
        self.hash = reader.tgread_bytes()

    def __repr__(self):
        return 'cdnFileHash#77eec38f offset:int limit:int hash:bytes = CdnFileHash'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class CdnPublicKey(TLObject):
    constructor_id = 0xc982eaba
    subclass_of_id = 0x16db47f3

    def __init__(self, dc_id, public_key):
        """
        :param dc_id: Telegram type: "int".
        :param public_key: Telegram type: "string".

        Constructor for CdnPublicKey: Instance of CdnPublicKey.
        """
        super().__init__()

        self.dc_id = dc_id
        self.public_key = public_key

    def to_dict(self):
        return {
            'dc_id': self.dc_id,
            'public_key': self.public_key,
        }

    def on_send(self, writer):
        writer.write_int(CdnPublicKey.constructor_id, signed=False)
        writer.write_int(self.dc_id)
        writer.tgwrite_string(self.public_key)

    @staticmethod
    def empty():
        return CdnPublicKey(None, None)

    def on_response(self, reader):
        self.dc_id = reader.read_int()
        self.public_key = reader.tgread_string()

    def __repr__(self):
        return 'cdnPublicKey#c982eaba dc_id:int public_key:string = CdnPublicKey'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Channel(TLObject):
    constructor_id = 0xcb44b1c
    subclass_of_id = 0xc5af5d94

    def __init__(self, id, title, photo, date, version, creator=None, left=None, editor=None, broadcast=None, verified=None, megagroup=None, restricted=None, democracy=None, signatures=None, min=None, access_hash=None, username=None, restriction_reason=None, admin_rights=None, banned_rights=None):
        """
        :param creator: Telegram type: "true".
        :param left: Telegram type: "true".
        :param editor: Telegram type: "true".
        :param broadcast: Telegram type: "true".
        :param verified: Telegram type: "true".
        :param megagroup: Telegram type: "true".
        :param restricted: Telegram type: "true".
        :param democracy: Telegram type: "true".
        :param signatures: Telegram type: "true".
        :param min: Telegram type: "true".
        :param id: Telegram type: "int".
        :param access_hash: Telegram type: "long".
        :param title: Telegram type: "string".
        :param username: Telegram type: "string".
        :param photo: Telegram type: "ChatPhoto".
        :param date: Telegram type: "date".
        :param version: Telegram type: "int".
        :param restriction_reason: Telegram type: "string".
        :param admin_rights: Telegram type: "ChannelAdminRights".
        :param banned_rights: Telegram type: "ChannelBannedRights".

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.creator = creator
        self.left = left
        self.editor = editor
        self.broadcast = broadcast
        self.verified = verified
        self.megagroup = megagroup
        self.restricted = restricted
        self.democracy = democracy
        self.signatures = signatures
        self.min = min
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.username = username
        self.photo = photo
        self.date = date
        self.version = version
        self.restriction_reason = restriction_reason
        self.admin_rights = admin_rights
        self.banned_rights = banned_rights

    def to_dict(self):
        return {
            'creator': self.creator,
            'left': self.left,
            'editor': self.editor,
            'broadcast': self.broadcast,
            'verified': self.verified,
            'megagroup': self.megagroup,
            'restricted': self.restricted,
            'democracy': self.democracy,
            'signatures': self.signatures,
            'min': self.min,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'username': self.username,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'date': self.date,
            'version': self.version,
            'restriction_reason': self.restriction_reason,
            'admin_rights': None if self.admin_rights is None else self.admin_rights.to_dict(),
            'banned_rights': None if self.banned_rights is None else self.banned_rights.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(Channel.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.creator else 0
        flags |= (1 << 2) if self.left else 0
        flags |= (1 << 3) if self.editor else 0
        flags |= (1 << 5) if self.broadcast else 0
        flags |= (1 << 7) if self.verified else 0
        flags |= (1 << 8) if self.megagroup else 0
        flags |= (1 << 9) if self.restricted else 0
        flags |= (1 << 10) if self.democracy else 0
        flags |= (1 << 11) if self.signatures else 0
        flags |= (1 << 12) if self.min else 0
        flags |= (1 << 13) if self.access_hash else 0
        flags |= (1 << 6) if self.username else 0
        flags |= (1 << 9) if self.restriction_reason else 0
        flags |= (1 << 14) if self.admin_rights else 0
        flags |= (1 << 15) if self.banned_rights else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        if self.access_hash:
            writer.write_long(self.access_hash)

        writer.tgwrite_string(self.title)
        if self.username:
            writer.tgwrite_string(self.username)

        self.photo.on_send(writer)
        writer.tgwrite_date(self.date)
        writer.write_int(self.version)
        if self.restriction_reason:
            writer.tgwrite_string(self.restriction_reason)

        if self.admin_rights:
            self.admin_rights.on_send(writer)

        if self.banned_rights:
            self.banned_rights.on_send(writer)

    @staticmethod
    def empty():
        return Channel(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.creator = True

        if (flags & (1 << 2)) != 0:
            self.left = True

        if (flags & (1 << 3)) != 0:
            self.editor = True

        if (flags & (1 << 5)) != 0:
            self.broadcast = True

        if (flags & (1 << 7)) != 0:
            self.verified = True

        if (flags & (1 << 8)) != 0:
            self.megagroup = True

        if (flags & (1 << 9)) != 0:
            self.restricted = True

        if (flags & (1 << 10)) != 0:
            self.democracy = True

        if (flags & (1 << 11)) != 0:
            self.signatures = True

        if (flags & (1 << 12)) != 0:
            self.min = True

        self.id = reader.read_int()
        if (flags & (1 << 13)) != 0:
            self.access_hash = reader.read_long()

        self.title = reader.tgread_string()
        if (flags & (1 << 6)) != 0:
            self.username = reader.tgread_string()

        self.photo = reader.tgread_object()
        self.date = reader.tgread_date()
        self.version = reader.read_int()
        if (flags & (1 << 9)) != 0:
            self.restriction_reason = reader.tgread_string()

        if (flags & (1 << 14)) != 0:
            self.admin_rights = reader.tgread_object()

        if (flags & (1 << 15)) != 0:
            self.banned_rights = reader.tgread_object()

    def __repr__(self):
        return 'channel#0cb44b1c flags:# creator:flags.0?true left:flags.2?true editor:flags.3?true broadcast:flags.5?true verified:flags.7?true megagroup:flags.8?true restricted:flags.9?true democracy:flags.10?true signatures:flags.11?true min:flags.12?true id:int access_hash:flags.13?long title:string username:flags.6?string photo:ChatPhoto date:int version:int restriction_reason:flags.9?string admin_rights:flags.14?ChannelAdminRights banned_rights:flags.15?ChannelBannedRights = Chat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEvent(TLObject):
    constructor_id = 0x3b5a3e40
    subclass_of_id = 0x408f0999

    def __init__(self, id, date, user_id, action):
        """
        :param id: Telegram type: "long".
        :param date: Telegram type: "date".
        :param user_id: Telegram type: "int".
        :param action: Telegram type: "ChannelAdminLogEventAction".

        Constructor for ChannelAdminLogEvent: Instance of ChannelAdminLogEvent.
        """
        super().__init__()

        self.id = id
        self.date = date
        self.user_id = user_id
        self.action = action

    def to_dict(self):
        return {
            'id': self.id,
            'date': self.date,
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEvent.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.tgwrite_date(self.date)
        writer.write_int(self.user_id)
        self.action.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEvent(None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.date = reader.tgread_date()
        self.user_id = reader.read_int()
        self.action = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEvent#3b5a3e40 id:long date:int user_id:int action:ChannelAdminLogEventAction = ChannelAdminLogEvent'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionChangeAbout(TLObject):
    constructor_id = 0x55188a2e
    subclass_of_id = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param prev_value: Telegram type: "string".
        :param new_value: Telegram type: "string".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_value = prev_value
        self.new_value = new_value

    def to_dict(self):
        return {
            'prev_value': self.prev_value,
            'new_value': self.new_value,
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionChangeAbout.constructor_id, signed=False)
        writer.tgwrite_string(self.prev_value)
        writer.tgwrite_string(self.new_value)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionChangeAbout(None, None)

    def on_response(self, reader):
        self.prev_value = reader.tgread_string()
        self.new_value = reader.tgread_string()

    def __repr__(self):
        return 'channelAdminLogEventActionChangeAbout#55188a2e prev_value:string new_value:string = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionChangePhoto(TLObject):
    constructor_id = 0xb82f55c3
    subclass_of_id = 0xb2b987f3

    def __init__(self, prev_photo, new_photo):
        """
        :param prev_photo: Telegram type: "ChatPhoto".
        :param new_photo: Telegram type: "ChatPhoto".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_photo = prev_photo
        self.new_photo = new_photo

    def to_dict(self):
        return {
            'prev_photo': None if self.prev_photo is None else self.prev_photo.to_dict(),
            'new_photo': None if self.new_photo is None else self.new_photo.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionChangePhoto.constructor_id, signed=False)
        self.prev_photo.on_send(writer)
        self.new_photo.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionChangePhoto(None, None)

    def on_response(self, reader):
        self.prev_photo = reader.tgread_object()
        self.new_photo = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEventActionChangePhoto#b82f55c3 prev_photo:ChatPhoto new_photo:ChatPhoto = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionChangeStickerSet(TLObject):
    constructor_id = 0xb1c3caa7
    subclass_of_id = 0xb2b987f3

    def __init__(self, prev_stickerset, new_stickerset):
        """
        :param prev_stickerset: Telegram type: "InputStickerSet".
        :param new_stickerset: Telegram type: "InputStickerSet".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_stickerset = prev_stickerset
        self.new_stickerset = new_stickerset

    def to_dict(self):
        return {
            'prev_stickerset': None if self.prev_stickerset is None else self.prev_stickerset.to_dict(),
            'new_stickerset': None if self.new_stickerset is None else self.new_stickerset.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionChangeStickerSet.constructor_id, signed=False)
        self.prev_stickerset.on_send(writer)
        self.new_stickerset.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionChangeStickerSet(None, None)

    def on_response(self, reader):
        self.prev_stickerset = reader.tgread_object()
        self.new_stickerset = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEventActionChangeStickerSet#b1c3caa7 prev_stickerset:InputStickerSet new_stickerset:InputStickerSet = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionChangeTitle(TLObject):
    constructor_id = 0xe6dfb825
    subclass_of_id = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param prev_value: Telegram type: "string".
        :param new_value: Telegram type: "string".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_value = prev_value
        self.new_value = new_value

    def to_dict(self):
        return {
            'prev_value': self.prev_value,
            'new_value': self.new_value,
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionChangeTitle.constructor_id, signed=False)
        writer.tgwrite_string(self.prev_value)
        writer.tgwrite_string(self.new_value)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionChangeTitle(None, None)

    def on_response(self, reader):
        self.prev_value = reader.tgread_string()
        self.new_value = reader.tgread_string()

    def __repr__(self):
        return 'channelAdminLogEventActionChangeTitle#e6dfb825 prev_value:string new_value:string = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionChangeUsername(TLObject):
    constructor_id = 0x6a4afc38
    subclass_of_id = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param prev_value: Telegram type: "string".
        :param new_value: Telegram type: "string".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_value = prev_value
        self.new_value = new_value

    def to_dict(self):
        return {
            'prev_value': self.prev_value,
            'new_value': self.new_value,
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionChangeUsername.constructor_id, signed=False)
        writer.tgwrite_string(self.prev_value)
        writer.tgwrite_string(self.new_value)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionChangeUsername(None, None)

    def on_response(self, reader):
        self.prev_value = reader.tgread_string()
        self.new_value = reader.tgread_string()

    def __repr__(self):
        return 'channelAdminLogEventActionChangeUsername#6a4afc38 prev_value:string new_value:string = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionDeleteMessage(TLObject):
    constructor_id = 0x42e047bb
    subclass_of_id = 0xb2b987f3

    def __init__(self, message):
        """
        :param message: Telegram type: "Message".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.message = message

    def to_dict(self):
        return {
            'message': None if self.message is None else self.message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionDeleteMessage.constructor_id, signed=False)
        self.message.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionDeleteMessage(None)

    def on_response(self, reader):
        self.message = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEventActionDeleteMessage#42e047bb message:Message = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionEditMessage(TLObject):
    constructor_id = 0x709b2405
    subclass_of_id = 0xb2b987f3

    def __init__(self, prev_message, new_message):
        """
        :param prev_message: Telegram type: "Message".
        :param new_message: Telegram type: "Message".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_message = prev_message
        self.new_message = new_message

    def to_dict(self):
        return {
            'prev_message': None if self.prev_message is None else self.prev_message.to_dict(),
            'new_message': None if self.new_message is None else self.new_message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionEditMessage.constructor_id, signed=False)
        self.prev_message.on_send(writer)
        self.new_message.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionEditMessage(None, None)

    def on_response(self, reader):
        self.prev_message = reader.tgread_object()
        self.new_message = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEventActionEditMessage#709b2405 prev_message:Message new_message:Message = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionParticipantInvite(TLObject):
    constructor_id = 0xe31c34d8
    subclass_of_id = 0xb2b987f3

    def __init__(self, participant):
        """
        :param participant: Telegram type: "ChannelParticipant".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.participant = participant

    def to_dict(self):
        return {
            'participant': None if self.participant is None else self.participant.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionParticipantInvite.constructor_id, signed=False)
        self.participant.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionParticipantInvite(None)

    def on_response(self, reader):
        self.participant = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEventActionParticipantInvite#e31c34d8 participant:ChannelParticipant = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionParticipantJoin(TLObject):
    constructor_id = 0x183040d3
    subclass_of_id = 0xb2b987f3

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionParticipantJoin.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionParticipantJoin()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'channelAdminLogEventActionParticipantJoin#183040d3 = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionParticipantLeave(TLObject):
    constructor_id = 0xf89777f2
    subclass_of_id = 0xb2b987f3

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionParticipantLeave.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionParticipantLeave()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'channelAdminLogEventActionParticipantLeave#f89777f2 = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionParticipantToggleAdmin(TLObject):
    constructor_id = 0xd5676710
    subclass_of_id = 0xb2b987f3

    def __init__(self, prev_participant, new_participant):
        """
        :param prev_participant: Telegram type: "ChannelParticipant".
        :param new_participant: Telegram type: "ChannelParticipant".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_participant = prev_participant
        self.new_participant = new_participant

    def to_dict(self):
        return {
            'prev_participant': None if self.prev_participant is None else self.prev_participant.to_dict(),
            'new_participant': None if self.new_participant is None else self.new_participant.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionParticipantToggleAdmin.constructor_id, signed=False)
        self.prev_participant.on_send(writer)
        self.new_participant.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionParticipantToggleAdmin(None, None)

    def on_response(self, reader):
        self.prev_participant = reader.tgread_object()
        self.new_participant = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEventActionParticipantToggleAdmin#d5676710 prev_participant:ChannelParticipant new_participant:ChannelParticipant = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionParticipantToggleBan(TLObject):
    constructor_id = 0xe6d83d7e
    subclass_of_id = 0xb2b987f3

    def __init__(self, prev_participant, new_participant):
        """
        :param prev_participant: Telegram type: "ChannelParticipant".
        :param new_participant: Telegram type: "ChannelParticipant".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_participant = prev_participant
        self.new_participant = new_participant

    def to_dict(self):
        return {
            'prev_participant': None if self.prev_participant is None else self.prev_participant.to_dict(),
            'new_participant': None if self.new_participant is None else self.new_participant.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionParticipantToggleBan.constructor_id, signed=False)
        self.prev_participant.on_send(writer)
        self.new_participant.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionParticipantToggleBan(None, None)

    def on_response(self, reader):
        self.prev_participant = reader.tgread_object()
        self.new_participant = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEventActionParticipantToggleBan#e6d83d7e prev_participant:ChannelParticipant new_participant:ChannelParticipant = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionToggleInvites(TLObject):
    constructor_id = 0x1b7907ae
    subclass_of_id = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param new_value: Telegram type: "Bool".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.new_value = new_value

    def to_dict(self):
        return {
            'new_value': self.new_value,
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionToggleInvites.constructor_id, signed=False)
        writer.tgwrite_bool(self.new_value)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionToggleInvites(None)

    def on_response(self, reader):
        self.new_value = reader.tgread_bool()

    def __repr__(self):
        return 'channelAdminLogEventActionToggleInvites#1b7907ae new_value:Bool = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionToggleSignatures(TLObject):
    constructor_id = 0x26ae0971
    subclass_of_id = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param new_value: Telegram type: "Bool".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.new_value = new_value

    def to_dict(self):
        return {
            'new_value': self.new_value,
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionToggleSignatures.constructor_id, signed=False)
        writer.tgwrite_bool(self.new_value)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionToggleSignatures(None)

    def on_response(self, reader):
        self.new_value = reader.tgread_bool()

    def __repr__(self):
        return 'channelAdminLogEventActionToggleSignatures#26ae0971 new_value:Bool = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventActionUpdatePinned(TLObject):
    constructor_id = 0xe9e82c18
    subclass_of_id = 0xb2b987f3

    def __init__(self, message):
        """
        :param message: Telegram type: "Message".

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.message = message

    def to_dict(self):
        return {
            'message': None if self.message is None else self.message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventActionUpdatePinned.constructor_id, signed=False)
        self.message.on_send(writer)

    @staticmethod
    def empty():
        return ChannelAdminLogEventActionUpdatePinned(None)

    def on_response(self, reader):
        self.message = reader.tgread_object()

    def __repr__(self):
        return 'channelAdminLogEventActionUpdatePinned#e9e82c18 message:Message = ChannelAdminLogEventAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminLogEventsFilter(TLObject):
    constructor_id = 0xea107ae4
    subclass_of_id = 0x7cbbf319

    def __init__(self, join=None, leave=None, invite=None, ban=None, unban=None, kick=None, unkick=None, promote=None, demote=None, info=None, settings=None, pinned=None, edit=None, delete=None):
        """
        :param join: Telegram type: "true".
        :param leave: Telegram type: "true".
        :param invite: Telegram type: "true".
        :param ban: Telegram type: "true".
        :param unban: Telegram type: "true".
        :param kick: Telegram type: "true".
        :param unkick: Telegram type: "true".
        :param promote: Telegram type: "true".
        :param demote: Telegram type: "true".
        :param info: Telegram type: "true".
        :param settings: Telegram type: "true".
        :param pinned: Telegram type: "true".
        :param edit: Telegram type: "true".
        :param delete: Telegram type: "true".

        Constructor for ChannelAdminLogEventsFilter: Instance of ChannelAdminLogEventsFilter.
        """
        super().__init__()

        self.join = join
        self.leave = leave
        self.invite = invite
        self.ban = ban
        self.unban = unban
        self.kick = kick
        self.unkick = unkick
        self.promote = promote
        self.demote = demote
        self.info = info
        self.settings = settings
        self.pinned = pinned
        self.edit = edit
        self.delete = delete

    def to_dict(self):
        return {
            'join': self.join,
            'leave': self.leave,
            'invite': self.invite,
            'ban': self.ban,
            'unban': self.unban,
            'kick': self.kick,
            'unkick': self.unkick,
            'promote': self.promote,
            'demote': self.demote,
            'info': self.info,
            'settings': self.settings,
            'pinned': self.pinned,
            'edit': self.edit,
            'delete': self.delete,
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminLogEventsFilter.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.join else 0
        flags |= (1 << 1) if self.leave else 0
        flags |= (1 << 2) if self.invite else 0
        flags |= (1 << 3) if self.ban else 0
        flags |= (1 << 4) if self.unban else 0
        flags |= (1 << 5) if self.kick else 0
        flags |= (1 << 6) if self.unkick else 0
        flags |= (1 << 7) if self.promote else 0
        flags |= (1 << 8) if self.demote else 0
        flags |= (1 << 9) if self.info else 0
        flags |= (1 << 10) if self.settings else 0
        flags |= (1 << 11) if self.pinned else 0
        flags |= (1 << 12) if self.edit else 0
        flags |= (1 << 13) if self.delete else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return ChannelAdminLogEventsFilter(None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.join = True

        if (flags & (1 << 1)) != 0:
            self.leave = True

        if (flags & (1 << 2)) != 0:
            self.invite = True

        if (flags & (1 << 3)) != 0:
            self.ban = True

        if (flags & (1 << 4)) != 0:
            self.unban = True

        if (flags & (1 << 5)) != 0:
            self.kick = True

        if (flags & (1 << 6)) != 0:
            self.unkick = True

        if (flags & (1 << 7)) != 0:
            self.promote = True

        if (flags & (1 << 8)) != 0:
            self.demote = True

        if (flags & (1 << 9)) != 0:
            self.info = True

        if (flags & (1 << 10)) != 0:
            self.settings = True

        if (flags & (1 << 11)) != 0:
            self.pinned = True

        if (flags & (1 << 12)) != 0:
            self.edit = True

        if (flags & (1 << 13)) != 0:
            self.delete = True

    def __repr__(self):
        return 'channelAdminLogEventsFilter#ea107ae4 flags:# join:flags.0?true leave:flags.1?true invite:flags.2?true ban:flags.3?true unban:flags.4?true kick:flags.5?true unkick:flags.6?true promote:flags.7?true demote:flags.8?true info:flags.9?true settings:flags.10?true pinned:flags.11?true edit:flags.12?true delete:flags.13?true = ChannelAdminLogEventsFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelAdminRights(TLObject):
    constructor_id = 0x5d7ceba5
    subclass_of_id = 0x2286545a

    def __init__(self, change_info=None, post_messages=None, edit_messages=None, delete_messages=None, ban_users=None, invite_users=None, invite_link=None, pin_messages=None, add_admins=None):
        """
        :param change_info: Telegram type: "true".
        :param post_messages: Telegram type: "true".
        :param edit_messages: Telegram type: "true".
        :param delete_messages: Telegram type: "true".
        :param ban_users: Telegram type: "true".
        :param invite_users: Telegram type: "true".
        :param invite_link: Telegram type: "true".
        :param pin_messages: Telegram type: "true".
        :param add_admins: Telegram type: "true".

        Constructor for ChannelAdminRights: Instance of ChannelAdminRights.
        """
        super().__init__()

        self.change_info = change_info
        self.post_messages = post_messages
        self.edit_messages = edit_messages
        self.delete_messages = delete_messages
        self.ban_users = ban_users
        self.invite_users = invite_users
        self.invite_link = invite_link
        self.pin_messages = pin_messages
        self.add_admins = add_admins

    def to_dict(self):
        return {
            'change_info': self.change_info,
            'post_messages': self.post_messages,
            'edit_messages': self.edit_messages,
            'delete_messages': self.delete_messages,
            'ban_users': self.ban_users,
            'invite_users': self.invite_users,
            'invite_link': self.invite_link,
            'pin_messages': self.pin_messages,
            'add_admins': self.add_admins,
        }

    def on_send(self, writer):
        writer.write_int(ChannelAdminRights.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.change_info else 0
        flags |= (1 << 1) if self.post_messages else 0
        flags |= (1 << 2) if self.edit_messages else 0
        flags |= (1 << 3) if self.delete_messages else 0
        flags |= (1 << 4) if self.ban_users else 0
        flags |= (1 << 5) if self.invite_users else 0
        flags |= (1 << 6) if self.invite_link else 0
        flags |= (1 << 7) if self.pin_messages else 0
        flags |= (1 << 9) if self.add_admins else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return ChannelAdminRights(None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.change_info = True

        if (flags & (1 << 1)) != 0:
            self.post_messages = True

        if (flags & (1 << 2)) != 0:
            self.edit_messages = True

        if (flags & (1 << 3)) != 0:
            self.delete_messages = True

        if (flags & (1 << 4)) != 0:
            self.ban_users = True

        if (flags & (1 << 5)) != 0:
            self.invite_users = True

        if (flags & (1 << 6)) != 0:
            self.invite_link = True

        if (flags & (1 << 7)) != 0:
            self.pin_messages = True

        if (flags & (1 << 9)) != 0:
            self.add_admins = True

    def __repr__(self):
        return 'channelAdminRights#5d7ceba5 flags:# change_info:flags.0?true post_messages:flags.1?true edit_messages:flags.2?true delete_messages:flags.3?true ban_users:flags.4?true invite_users:flags.5?true invite_link:flags.6?true pin_messages:flags.7?true add_admins:flags.9?true = ChannelAdminRights'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelBannedRights(TLObject):
    constructor_id = 0x58cf4249
    subclass_of_id = 0x5c474079

    def __init__(self, until_date, view_messages=None, send_messages=None, send_media=None, send_stickers=None, send_gifs=None, send_games=None, send_inline=None, embed_links=None):
        """
        :param view_messages: Telegram type: "true".
        :param send_messages: Telegram type: "true".
        :param send_media: Telegram type: "true".
        :param send_stickers: Telegram type: "true".
        :param send_gifs: Telegram type: "true".
        :param send_games: Telegram type: "true".
        :param send_inline: Telegram type: "true".
        :param embed_links: Telegram type: "true".
        :param until_date: Telegram type: "date".

        Constructor for ChannelBannedRights: Instance of ChannelBannedRights.
        """
        super().__init__()

        self.view_messages = view_messages
        self.send_messages = send_messages
        self.send_media = send_media
        self.send_stickers = send_stickers
        self.send_gifs = send_gifs
        self.send_games = send_games
        self.send_inline = send_inline
        self.embed_links = embed_links
        self.until_date = until_date

    def to_dict(self):
        return {
            'view_messages': self.view_messages,
            'send_messages': self.send_messages,
            'send_media': self.send_media,
            'send_stickers': self.send_stickers,
            'send_gifs': self.send_gifs,
            'send_games': self.send_games,
            'send_inline': self.send_inline,
            'embed_links': self.embed_links,
            'until_date': self.until_date,
        }

    def on_send(self, writer):
        writer.write_int(ChannelBannedRights.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.view_messages else 0
        flags |= (1 << 1) if self.send_messages else 0
        flags |= (1 << 2) if self.send_media else 0
        flags |= (1 << 3) if self.send_stickers else 0
        flags |= (1 << 4) if self.send_gifs else 0
        flags |= (1 << 5) if self.send_games else 0
        flags |= (1 << 6) if self.send_inline else 0
        flags |= (1 << 7) if self.embed_links else 0
        writer.write_int(flags)

        writer.tgwrite_date(self.until_date)

    @staticmethod
    def empty():
        return ChannelBannedRights(None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.view_messages = True

        if (flags & (1 << 1)) != 0:
            self.send_messages = True

        if (flags & (1 << 2)) != 0:
            self.send_media = True

        if (flags & (1 << 3)) != 0:
            self.send_stickers = True

        if (flags & (1 << 4)) != 0:
            self.send_gifs = True

        if (flags & (1 << 5)) != 0:
            self.send_games = True

        if (flags & (1 << 6)) != 0:
            self.send_inline = True

        if (flags & (1 << 7)) != 0:
            self.embed_links = True

        self.until_date = reader.tgread_date()

    def __repr__(self):
        return 'channelBannedRights#58cf4249 flags:# view_messages:flags.0?true send_messages:flags.1?true send_media:flags.2?true send_stickers:flags.3?true send_gifs:flags.4?true send_games:flags.5?true send_inline:flags.6?true embed_links:flags.7?true until_date:int = ChannelBannedRights'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelForbidden(TLObject):
    constructor_id = 0x289da732
    subclass_of_id = 0xc5af5d94

    def __init__(self, id, access_hash, title, broadcast=None, megagroup=None, until_date=None):
        """
        :param broadcast: Telegram type: "true".
        :param megagroup: Telegram type: "true".
        :param id: Telegram type: "int".
        :param access_hash: Telegram type: "long".
        :param title: Telegram type: "string".
        :param until_date: Telegram type: "date".

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.broadcast = broadcast
        self.megagroup = megagroup
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.until_date = until_date

    def to_dict(self):
        return {
            'broadcast': self.broadcast,
            'megagroup': self.megagroup,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'until_date': self.until_date,
        }

    def on_send(self, writer):
        writer.write_int(ChannelForbidden.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 5) if self.broadcast else 0
        flags |= (1 << 8) if self.megagroup else 0
        flags |= (1 << 16) if self.until_date else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_string(self.title)
        if self.until_date:
            writer.tgwrite_date(self.until_date)

    @staticmethod
    def empty():
        return ChannelForbidden(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 5)) != 0:
            self.broadcast = True

        if (flags & (1 << 8)) != 0:
            self.megagroup = True

        self.id = reader.read_int()
        self.access_hash = reader.read_long()
        self.title = reader.tgread_string()
        if (flags & (1 << 16)) != 0:
            self.until_date = reader.tgread_date()

    def __repr__(self):
        return 'channelForbidden#289da732 flags:# broadcast:flags.5?true megagroup:flags.8?true id:int access_hash:long title:string until_date:flags.16?int = Chat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelFull(TLObject):
    constructor_id = 0x17f45fcf
    subclass_of_id = 0xd49a2697

    def __init__(self, id, about, read_inbox_max_id, read_outbox_max_id, unread_count, chat_photo, notify_settings, exported_invite, bot_info, can_view_participants=None, can_set_username=None, can_set_stickers=None, participants_count=None, admins_count=None, kicked_count=None, banned_count=None, migrated_from_chat_id=None, migrated_from_max_id=None, pinned_msg_id=None, stickerset=None):
        """
        :param can_view_participants: Telegram type: "true".
        :param can_set_username: Telegram type: "true".
        :param can_set_stickers: Telegram type: "true".
        :param id: Telegram type: "int".
        :param about: Telegram type: "string".
        :param participants_count: Telegram type: "int".
        :param admins_count: Telegram type: "int".
        :param kicked_count: Telegram type: "int".
        :param banned_count: Telegram type: "int".
        :param read_inbox_max_id: Telegram type: "int".
        :param read_outbox_max_id: Telegram type: "int".
        :param unread_count: Telegram type: "int".
        :param chat_photo: Telegram type: "Photo".
        :param notify_settings: Telegram type: "PeerNotifySettings".
        :param exported_invite: Telegram type: "ExportedChatInvite".
        :param bot_info: Telegram type: "BotInfo". Must be a list.
        :param migrated_from_chat_id: Telegram type: "int".
        :param migrated_from_max_id: Telegram type: "int".
        :param pinned_msg_id: Telegram type: "int".
        :param stickerset: Telegram type: "StickerSet".

        Constructor for ChatFull: Instance of either ChatFull, ChannelFull.
        """
        super().__init__()

        self.can_view_participants = can_view_participants
        self.can_set_username = can_set_username
        self.can_set_stickers = can_set_stickers
        self.id = id
        self.about = about
        self.participants_count = participants_count
        self.admins_count = admins_count
        self.kicked_count = kicked_count
        self.banned_count = banned_count
        self.read_inbox_max_id = read_inbox_max_id
        self.read_outbox_max_id = read_outbox_max_id
        self.unread_count = unread_count
        self.chat_photo = chat_photo
        self.notify_settings = notify_settings
        self.exported_invite = exported_invite
        self.bot_info = bot_info
        self.migrated_from_chat_id = migrated_from_chat_id
        self.migrated_from_max_id = migrated_from_max_id
        self.pinned_msg_id = pinned_msg_id
        self.stickerset = stickerset

    def to_dict(self):
        return {
            'can_view_participants': self.can_view_participants,
            'can_set_username': self.can_set_username,
            'can_set_stickers': self.can_set_stickers,
            'id': self.id,
            'about': self.about,
            'participants_count': self.participants_count,
            'admins_count': self.admins_count,
            'kicked_count': self.kicked_count,
            'banned_count': self.banned_count,
            'read_inbox_max_id': self.read_inbox_max_id,
            'read_outbox_max_id': self.read_outbox_max_id,
            'unread_count': self.unread_count,
            'chat_photo': None if self.chat_photo is None else self.chat_photo.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'exported_invite': None if self.exported_invite is None else self.exported_invite.to_dict(),
            'bot_info': [] if self.bot_info is None else [None if x is None else x.to_dict() for x in self.bot_info],
            'migrated_from_chat_id': self.migrated_from_chat_id,
            'migrated_from_max_id': self.migrated_from_max_id,
            'pinned_msg_id': self.pinned_msg_id,
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelFull.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 3) if self.can_view_participants else 0
        flags |= (1 << 6) if self.can_set_username else 0
        flags |= (1 << 7) if self.can_set_stickers else 0
        flags |= (1 << 0) if self.participants_count else 0
        flags |= (1 << 1) if self.admins_count else 0
        flags |= (1 << 2) if self.kicked_count else 0
        flags |= (1 << 2) if self.banned_count else 0
        flags |= (1 << 4) if self.migrated_from_chat_id else 0
        flags |= (1 << 4) if self.migrated_from_max_id else 0
        flags |= (1 << 5) if self.pinned_msg_id else 0
        flags |= (1 << 8) if self.stickerset else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        writer.tgwrite_string(self.about)
        if self.participants_count:
            writer.write_int(self.participants_count)

        if self.admins_count:
            writer.write_int(self.admins_count)

        if self.kicked_count:
            writer.write_int(self.kicked_count)

        if self.banned_count:
            writer.write_int(self.banned_count)

        writer.write_int(self.read_inbox_max_id)
        writer.write_int(self.read_outbox_max_id)
        writer.write_int(self.unread_count)
        self.chat_photo.on_send(writer)
        self.notify_settings.on_send(writer)
        self.exported_invite.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.bot_info))
        for _x in self.bot_info:
            _x.on_send(writer)

        if self.migrated_from_chat_id:
            writer.write_int(self.migrated_from_chat_id)

        if self.migrated_from_max_id:
            writer.write_int(self.migrated_from_max_id)

        if self.pinned_msg_id:
            writer.write_int(self.pinned_msg_id)

        if self.stickerset:
            self.stickerset.on_send(writer)

    @staticmethod
    def empty():
        return ChannelFull(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 3)) != 0:
            self.can_view_participants = True

        if (flags & (1 << 6)) != 0:
            self.can_set_username = True

        if (flags & (1 << 7)) != 0:
            self.can_set_stickers = True

        self.id = reader.read_int()
        self.about = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.participants_count = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.admins_count = reader.read_int()

        if (flags & (1 << 2)) != 0:
            self.kicked_count = reader.read_int()

        if (flags & (1 << 2)) != 0:
            self.banned_count = reader.read_int()

        self.read_inbox_max_id = reader.read_int()
        self.read_outbox_max_id = reader.read_int()
        self.unread_count = reader.read_int()
        self.chat_photo = reader.tgread_object()
        self.notify_settings = reader.tgread_object()
        self.exported_invite = reader.tgread_object()
        reader.read_int()
        self.bot_info = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.bot_info.append(_x)

        if (flags & (1 << 4)) != 0:
            self.migrated_from_chat_id = reader.read_int()

        if (flags & (1 << 4)) != 0:
            self.migrated_from_max_id = reader.read_int()

        if (flags & (1 << 5)) != 0:
            self.pinned_msg_id = reader.read_int()

        if (flags & (1 << 8)) != 0:
            self.stickerset = reader.tgread_object()

    def __repr__(self):
        return 'channelFull#17f45fcf flags:# can_view_participants:flags.3?true can_set_username:flags.6?true can_set_stickers:flags.7?true id:int about:string participants_count:flags.0?int admins_count:flags.1?int kicked_count:flags.2?int banned_count:flags.2?int read_inbox_max_id:int read_outbox_max_id:int unread_count:int chat_photo:Photo notify_settings:PeerNotifySettings exported_invite:ExportedChatInvite bot_info:Vector<BotInfo> migrated_from_chat_id:flags.4?int migrated_from_max_id:flags.4?int pinned_msg_id:flags.5?int stickerset:flags.8?StickerSet = ChatFull'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelMessagesFilter(TLObject):
    constructor_id = 0xcd77d957
    subclass_of_id = 0x13336a56

    def __init__(self, ranges, exclude_new_messages=None):
        """
        :param exclude_new_messages: Telegram type: "true".
        :param ranges: Telegram type: "MessageRange". Must be a list.

        Constructor for ChannelMessagesFilter: Instance of either ChannelMessagesFilterEmpty, ChannelMessagesFilter.
        """
        super().__init__()

        self.exclude_new_messages = exclude_new_messages
        self.ranges = ranges

    def to_dict(self):
        return {
            'exclude_new_messages': self.exclude_new_messages,
            'ranges': [] if self.ranges is None else [None if x is None else x.to_dict() for x in self.ranges],
        }

    def on_send(self, writer):
        writer.write_int(ChannelMessagesFilter.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.exclude_new_messages else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.ranges))
        for _x in self.ranges:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ChannelMessagesFilter(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.exclude_new_messages = True

        reader.read_int()
        self.ranges = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.ranges.append(_x)

    def __repr__(self):
        return 'channelMessagesFilter#cd77d957 flags:# exclude_new_messages:flags.1?true ranges:Vector<MessageRange> = ChannelMessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelMessagesFilterEmpty(TLObject):
    constructor_id = 0x94d42ee7
    subclass_of_id = 0x13336a56

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ChannelMessagesFilterEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ChannelMessagesFilterEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'channelMessagesFilterEmpty#94d42ee7 = ChannelMessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipant(TLObject):
    constructor_id = 0x15ebac1d
    subclass_of_id = 0xd9c7fc18

    def __init__(self, user_id, date):
        """
        :param user_id: Telegram type: "int".
        :param date: Telegram type: "date".

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id
        self.date = date

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(ChannelParticipant.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return ChannelParticipant(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'channelParticipant#15ebac1d user_id:int date:int = ChannelParticipant'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantAdmin(TLObject):
    constructor_id = 0xa82fa898
    subclass_of_id = 0xd9c7fc18

    def __init__(self, user_id, inviter_id, promoted_by, date, admin_rights, can_edit=None):
        """
        :param can_edit: Telegram type: "true".
        :param user_id: Telegram type: "int".
        :param inviter_id: Telegram type: "int".
        :param promoted_by: Telegram type: "int".
        :param date: Telegram type: "date".
        :param admin_rights: Telegram type: "ChannelAdminRights".

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.can_edit = can_edit
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.promoted_by = promoted_by
        self.date = date
        self.admin_rights = admin_rights

    def to_dict(self):
        return {
            'can_edit': self.can_edit,
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'promoted_by': self.promoted_by,
            'date': self.date,
            'admin_rights': None if self.admin_rights is None else self.admin_rights.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelParticipantAdmin.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.can_edit else 0
        writer.write_int(flags)

        writer.write_int(self.user_id)
        writer.write_int(self.inviter_id)
        writer.write_int(self.promoted_by)
        writer.tgwrite_date(self.date)
        self.admin_rights.on_send(writer)

    @staticmethod
    def empty():
        return ChannelParticipantAdmin(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.can_edit = True

        self.user_id = reader.read_int()
        self.inviter_id = reader.read_int()
        self.promoted_by = reader.read_int()
        self.date = reader.tgread_date()
        self.admin_rights = reader.tgread_object()

    def __repr__(self):
        return 'channelParticipantAdmin#a82fa898 flags:# can_edit:flags.0?true user_id:int inviter_id:int promoted_by:int date:int admin_rights:ChannelAdminRights = ChannelParticipant'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantBanned(TLObject):
    constructor_id = 0x222c1886
    subclass_of_id = 0xd9c7fc18

    def __init__(self, user_id, kicked_by, date, banned_rights, left=None):
        """
        :param left: Telegram type: "true".
        :param user_id: Telegram type: "int".
        :param kicked_by: Telegram type: "int".
        :param date: Telegram type: "date".
        :param banned_rights: Telegram type: "ChannelBannedRights".

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.left = left
        self.user_id = user_id
        self.kicked_by = kicked_by
        self.date = date
        self.banned_rights = banned_rights

    def to_dict(self):
        return {
            'left': self.left,
            'user_id': self.user_id,
            'kicked_by': self.kicked_by,
            'date': self.date,
            'banned_rights': None if self.banned_rights is None else self.banned_rights.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChannelParticipantBanned.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.left else 0
        writer.write_int(flags)

        writer.write_int(self.user_id)
        writer.write_int(self.kicked_by)
        writer.tgwrite_date(self.date)
        self.banned_rights.on_send(writer)

    @staticmethod
    def empty():
        return ChannelParticipantBanned(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.left = True

        self.user_id = reader.read_int()
        self.kicked_by = reader.read_int()
        self.date = reader.tgread_date()
        self.banned_rights = reader.tgread_object()

    def __repr__(self):
        return 'channelParticipantBanned#222c1886 flags:# left:flags.0?true user_id:int kicked_by:int date:int banned_rights:ChannelBannedRights = ChannelParticipant'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantCreator(TLObject):
    constructor_id = 0xe3e2e1f9
    subclass_of_id = 0xd9c7fc18

    def __init__(self, user_id):
        """
        :param user_id: Telegram type: "int".

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id

    def to_dict(self):
        return {
            'user_id': self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(ChannelParticipantCreator.constructor_id, signed=False)
        writer.write_int(self.user_id)

    @staticmethod
    def empty():
        return ChannelParticipantCreator(None)

    def on_response(self, reader):
        self.user_id = reader.read_int()

    def __repr__(self):
        return 'channelParticipantCreator#e3e2e1f9 user_id:int = ChannelParticipant'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantSelf(TLObject):
    constructor_id = 0xa3289a6d
    subclass_of_id = 0xd9c7fc18

    def __init__(self, user_id, inviter_id, date):
        """
        :param user_id: Telegram type: "int".
        :param inviter_id: Telegram type: "int".
        :param date: Telegram type: "date".

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(ChannelParticipantSelf.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.write_int(self.inviter_id)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return ChannelParticipantSelf(None, None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.inviter_id = reader.read_int()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'channelParticipantSelf#a3289a6d user_id:int inviter_id:int date:int = ChannelParticipant'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantsAdmins(TLObject):
    constructor_id = 0xb4608969
    subclass_of_id = 0xbf4e2753

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ChannelParticipantsAdmins.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ChannelParticipantsAdmins()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'channelParticipantsAdmins#b4608969 = ChannelParticipantsFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantsBanned(TLObject):
    constructor_id = 0x1427a5e1
    subclass_of_id = 0xbf4e2753

    def __init__(self, q):
        """
        :param q: Telegram type: "string".

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q

    def to_dict(self):
        return {
            'q': self.q,
        }

    def on_send(self, writer):
        writer.write_int(ChannelParticipantsBanned.constructor_id, signed=False)
        writer.tgwrite_string(self.q)

    @staticmethod
    def empty():
        return ChannelParticipantsBanned(None)

    def on_response(self, reader):
        self.q = reader.tgread_string()

    def __repr__(self):
        return 'channelParticipantsBanned#1427a5e1 q:string = ChannelParticipantsFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantsBots(TLObject):
    constructor_id = 0xb0d1865b
    subclass_of_id = 0xbf4e2753

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ChannelParticipantsBots.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ChannelParticipantsBots()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'channelParticipantsBots#b0d1865b = ChannelParticipantsFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantsKicked(TLObject):
    constructor_id = 0xa3b54985
    subclass_of_id = 0xbf4e2753

    def __init__(self, q):
        """
        :param q: Telegram type: "string".

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q

    def to_dict(self):
        return {
            'q': self.q,
        }

    def on_send(self, writer):
        writer.write_int(ChannelParticipantsKicked.constructor_id, signed=False)
        writer.tgwrite_string(self.q)

    @staticmethod
    def empty():
        return ChannelParticipantsKicked(None)

    def on_response(self, reader):
        self.q = reader.tgread_string()

    def __repr__(self):
        return 'channelParticipantsKicked#a3b54985 q:string = ChannelParticipantsFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantsRecent(TLObject):
    constructor_id = 0xde3f3c79
    subclass_of_id = 0xbf4e2753

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ChannelParticipantsRecent.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ChannelParticipantsRecent()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'channelParticipantsRecent#de3f3c79 = ChannelParticipantsFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChannelParticipantsSearch(TLObject):
    constructor_id = 0x656ac4b
    subclass_of_id = 0xbf4e2753

    def __init__(self, q):
        """
        :param q: Telegram type: "string".

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q

    def to_dict(self):
        return {
            'q': self.q,
        }

    def on_send(self, writer):
        writer.write_int(ChannelParticipantsSearch.constructor_id, signed=False)
        writer.tgwrite_string(self.q)

    @staticmethod
    def empty():
        return ChannelParticipantsSearch(None)

    def on_response(self, reader):
        self.q = reader.tgread_string()

    def __repr__(self):
        return 'channelParticipantsSearch#0656ac4b q:string = ChannelParticipantsFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Chat(TLObject):
    constructor_id = 0xd91cdd54
    subclass_of_id = 0xc5af5d94

    def __init__(self, id, title, photo, participants_count, date, version, creator=None, kicked=None, left=None, admins_enabled=None, admin=None, deactivated=None, migrated_to=None):
        """
        :param creator: Telegram type: "true".
        :param kicked: Telegram type: "true".
        :param left: Telegram type: "true".
        :param admins_enabled: Telegram type: "true".
        :param admin: Telegram type: "true".
        :param deactivated: Telegram type: "true".
        :param id: Telegram type: "int".
        :param title: Telegram type: "string".
        :param photo: Telegram type: "ChatPhoto".
        :param participants_count: Telegram type: "int".
        :param date: Telegram type: "date".
        :param version: Telegram type: "int".
        :param migrated_to: Telegram type: "InputChannel".

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.creator = creator
        self.kicked = kicked
        self.left = left
        self.admins_enabled = admins_enabled
        self.admin = admin
        self.deactivated = deactivated
        self.id = id
        self.title = title
        self.photo = photo
        self.participants_count = participants_count
        self.date = date
        self.version = version
        self.migrated_to = migrated_to

    def to_dict(self):
        return {
            'creator': self.creator,
            'kicked': self.kicked,
            'left': self.left,
            'admins_enabled': self.admins_enabled,
            'admin': self.admin,
            'deactivated': self.deactivated,
            'id': self.id,
            'title': self.title,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'participants_count': self.participants_count,
            'date': self.date,
            'version': self.version,
            'migrated_to': None if self.migrated_to is None else self.migrated_to.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(Chat.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.creator else 0
        flags |= (1 << 1) if self.kicked else 0
        flags |= (1 << 2) if self.left else 0
        flags |= (1 << 3) if self.admins_enabled else 0
        flags |= (1 << 4) if self.admin else 0
        flags |= (1 << 5) if self.deactivated else 0
        flags |= (1 << 6) if self.migrated_to else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        writer.tgwrite_string(self.title)
        self.photo.on_send(writer)
        writer.write_int(self.participants_count)
        writer.tgwrite_date(self.date)
        writer.write_int(self.version)
        if self.migrated_to:
            self.migrated_to.on_send(writer)

    @staticmethod
    def empty():
        return Chat(None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.creator = True

        if (flags & (1 << 1)) != 0:
            self.kicked = True

        if (flags & (1 << 2)) != 0:
            self.left = True

        if (flags & (1 << 3)) != 0:
            self.admins_enabled = True

        if (flags & (1 << 4)) != 0:
            self.admin = True

        if (flags & (1 << 5)) != 0:
            self.deactivated = True

        self.id = reader.read_int()
        self.title = reader.tgread_string()
        self.photo = reader.tgread_object()
        self.participants_count = reader.read_int()
        self.date = reader.tgread_date()
        self.version = reader.read_int()
        if (flags & (1 << 6)) != 0:
            self.migrated_to = reader.tgread_object()

    def __repr__(self):
        return 'chat#d91cdd54 flags:# creator:flags.0?true kicked:flags.1?true left:flags.2?true admins_enabled:flags.3?true admin:flags.4?true deactivated:flags.5?true id:int title:string photo:ChatPhoto participants_count:int date:int version:int migrated_to:flags.6?InputChannel = Chat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatEmpty(TLObject):
    constructor_id = 0x9ba2d800
    subclass_of_id = 0xc5af5d94

    def __init__(self, id):
        """
        :param id: Telegram type: "int".

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(ChatEmpty.constructor_id, signed=False)
        writer.write_int(self.id)

    @staticmethod
    def empty():
        return ChatEmpty(None)

    def on_response(self, reader):
        self.id = reader.read_int()

    def __repr__(self):
        return 'chatEmpty#9ba2d800 id:int = Chat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatForbidden(TLObject):
    constructor_id = 0x7328bdb
    subclass_of_id = 0xc5af5d94

    def __init__(self, id, title):
        """
        :param id: Telegram type: "int".
        :param title: Telegram type: "string".

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.id = id
        self.title = title

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
        }

    def on_send(self, writer):
        writer.write_int(ChatForbidden.constructor_id, signed=False)
        writer.write_int(self.id)
        writer.tgwrite_string(self.title)

    @staticmethod
    def empty():
        return ChatForbidden(None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.title = reader.tgread_string()

    def __repr__(self):
        return 'chatForbidden#07328bdb id:int title:string = Chat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatFull(TLObject):
    constructor_id = 0x2e02a614
    subclass_of_id = 0xd49a2697

    def __init__(self, id, participants, chat_photo, notify_settings, exported_invite, bot_info):
        """
        :param id: Telegram type: "int".
        :param participants: Telegram type: "ChatParticipants".
        :param chat_photo: Telegram type: "Photo".
        :param notify_settings: Telegram type: "PeerNotifySettings".
        :param exported_invite: Telegram type: "ExportedChatInvite".
        :param bot_info: Telegram type: "BotInfo". Must be a list.

        Constructor for ChatFull: Instance of either ChatFull, ChannelFull.
        """
        super().__init__()

        self.id = id
        self.participants = participants
        self.chat_photo = chat_photo
        self.notify_settings = notify_settings
        self.exported_invite = exported_invite
        self.bot_info = bot_info

    def to_dict(self):
        return {
            'id': self.id,
            'participants': None if self.participants is None else self.participants.to_dict(),
            'chat_photo': None if self.chat_photo is None else self.chat_photo.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'exported_invite': None if self.exported_invite is None else self.exported_invite.to_dict(),
            'bot_info': [] if self.bot_info is None else [None if x is None else x.to_dict() for x in self.bot_info],
        }

    def on_send(self, writer):
        writer.write_int(ChatFull.constructor_id, signed=False)
        writer.write_int(self.id)
        self.participants.on_send(writer)
        self.chat_photo.on_send(writer)
        self.notify_settings.on_send(writer)
        self.exported_invite.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.bot_info))
        for _x in self.bot_info:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ChatFull(None, None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.participants = reader.tgread_object()
        self.chat_photo = reader.tgread_object()
        self.notify_settings = reader.tgread_object()
        self.exported_invite = reader.tgread_object()
        reader.read_int()
        self.bot_info = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.bot_info.append(_x)

    def __repr__(self):
        return 'chatFull#2e02a614 id:int participants:ChatParticipants chat_photo:Photo notify_settings:PeerNotifySettings exported_invite:ExportedChatInvite bot_info:Vector<BotInfo> = ChatFull'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatInvite(TLObject):
    constructor_id = 0xdb74f558
    subclass_of_id = 0x4561736

    def __init__(self, title, photo, participants_count, channel=None, broadcast=None, public=None, megagroup=None, participants=None):
        """
        :param channel: Telegram type: "true".
        :param broadcast: Telegram type: "true".
        :param public: Telegram type: "true".
        :param megagroup: Telegram type: "true".
        :param title: Telegram type: "string".
        :param photo: Telegram type: "ChatPhoto".
        :param participants_count: Telegram type: "int".
        :param participants: Telegram type: "User". Must be a list.

        Constructor for ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()

        self.channel = channel
        self.broadcast = broadcast
        self.public = public
        self.megagroup = megagroup
        self.title = title
        self.photo = photo
        self.participants_count = participants_count
        self.participants = participants

    def to_dict(self):
        return {
            'channel': self.channel,
            'broadcast': self.broadcast,
            'public': self.public,
            'megagroup': self.megagroup,
            'title': self.title,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'participants_count': self.participants_count,
            'participants': [] if self.participants is None else [None if x is None else x.to_dict() for x in self.participants],
        }

    def on_send(self, writer):
        writer.write_int(ChatInvite.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.channel else 0
        flags |= (1 << 1) if self.broadcast else 0
        flags |= (1 << 2) if self.public else 0
        flags |= (1 << 3) if self.megagroup else 0
        flags |= (1 << 4) if self.participants else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.title)
        self.photo.on_send(writer)
        writer.write_int(self.participants_count)
        if self.participants:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.participants))
            for _x in self.participants:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return ChatInvite(None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.channel = True

        if (flags & (1 << 1)) != 0:
            self.broadcast = True

        if (flags & (1 << 2)) != 0:
            self.public = True

        if (flags & (1 << 3)) != 0:
            self.megagroup = True

        self.title = reader.tgread_string()
        self.photo = reader.tgread_object()
        self.participants_count = reader.read_int()
        if (flags & (1 << 4)) != 0:
            reader.read_int()
            self.participants = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.participants.append(_x)

    def __repr__(self):
        return 'chatInvite#db74f558 flags:# channel:flags.0?true broadcast:flags.1?true public:flags.2?true megagroup:flags.3?true title:string photo:ChatPhoto participants_count:int participants:flags.4?Vector<User> = ChatInvite'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatInviteAlready(TLObject):
    constructor_id = 0x5a686d7c
    subclass_of_id = 0x4561736

    def __init__(self, chat):
        """
        :param chat: Telegram type: "Chat".

        Constructor for ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()

        self.chat = chat

    def to_dict(self):
        return {
            'chat': None if self.chat is None else self.chat.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChatInviteAlready.constructor_id, signed=False)
        self.chat.on_send(writer)

    @staticmethod
    def empty():
        return ChatInviteAlready(None)

    def on_response(self, reader):
        self.chat = reader.tgread_object()

    def __repr__(self):
        return 'chatInviteAlready#5a686d7c chat:Chat = ChatInvite'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatInviteEmpty(TLObject):
    constructor_id = 0x69df3769
    subclass_of_id = 0xb4748a58

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ChatInviteEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ChatInviteEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'chatInviteEmpty#69df3769 = ExportedChatInvite'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatInviteExported(TLObject):
    constructor_id = 0xfc2e05bc
    subclass_of_id = 0xb4748a58

    def __init__(self, link):
        """
        :param link: Telegram type: "string".

        Constructor for ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        super().__init__()

        self.link = link

    def to_dict(self):
        return {
            'link': self.link,
        }

    def on_send(self, writer):
        writer.write_int(ChatInviteExported.constructor_id, signed=False)
        writer.tgwrite_string(self.link)

    @staticmethod
    def empty():
        return ChatInviteExported(None)

    def on_response(self, reader):
        self.link = reader.tgread_string()

    def __repr__(self):
        return 'chatInviteExported#fc2e05bc link:string = ExportedChatInvite'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatParticipant(TLObject):
    constructor_id = 0xc8d7493e
    subclass_of_id = 0x7d7c6f86

    def __init__(self, user_id, inviter_id, date):
        """
        :param user_id: Telegram type: "int".
        :param inviter_id: Telegram type: "int".
        :param date: Telegram type: "date".

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(ChatParticipant.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.write_int(self.inviter_id)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return ChatParticipant(None, None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.inviter_id = reader.read_int()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'chatParticipant#c8d7493e user_id:int inviter_id:int date:int = ChatParticipant'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatParticipantAdmin(TLObject):
    constructor_id = 0xe2d6e436
    subclass_of_id = 0x7d7c6f86

    def __init__(self, user_id, inviter_id, date):
        """
        :param user_id: Telegram type: "int".
        :param inviter_id: Telegram type: "int".
        :param date: Telegram type: "date".

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(ChatParticipantAdmin.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.write_int(self.inviter_id)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return ChatParticipantAdmin(None, None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.inviter_id = reader.read_int()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'chatParticipantAdmin#e2d6e436 user_id:int inviter_id:int date:int = ChatParticipant'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatParticipantCreator(TLObject):
    constructor_id = 0xda13538a
    subclass_of_id = 0x7d7c6f86

    def __init__(self, user_id):
        """
        :param user_id: Telegram type: "int".

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id

    def to_dict(self):
        return {
            'user_id': self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(ChatParticipantCreator.constructor_id, signed=False)
        writer.write_int(self.user_id)

    @staticmethod
    def empty():
        return ChatParticipantCreator(None)

    def on_response(self, reader):
        self.user_id = reader.read_int()

    def __repr__(self):
        return 'chatParticipantCreator#da13538a user_id:int = ChatParticipant'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatParticipants(TLObject):
    constructor_id = 0x3f460fed
    subclass_of_id = 0x1fa89571

    def __init__(self, chat_id, participants, version):
        """
        :param chat_id: Telegram type: "int".
        :param participants: Telegram type: "ChatParticipant". Must be a list.
        :param version: Telegram type: "int".

        Constructor for ChatParticipants: Instance of either ChatParticipantsForbidden, ChatParticipants.
        """
        super().__init__()

        self.chat_id = chat_id
        self.participants = participants
        self.version = version

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'participants': [] if self.participants is None else [None if x is None else x.to_dict() for x in self.participants],
            'version': self.version,
        }

    def on_send(self, writer):
        writer.write_int(ChatParticipants.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.participants))
        for _x in self.participants:
            _x.on_send(writer)

        writer.write_int(self.version)

    @staticmethod
    def empty():
        return ChatParticipants(None, None, None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()
        reader.read_int()
        self.participants = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.participants.append(_x)

        self.version = reader.read_int()

    def __repr__(self):
        return 'chatParticipants#3f460fed chat_id:int participants:Vector<ChatParticipant> version:int = ChatParticipants'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatParticipantsForbidden(TLObject):
    constructor_id = 0xfc900c2b
    subclass_of_id = 0x1fa89571

    def __init__(self, chat_id, self_participant=None):
        """
        :param chat_id: Telegram type: "int".
        :param self_participant: Telegram type: "ChatParticipant".

        Constructor for ChatParticipants: Instance of either ChatParticipantsForbidden, ChatParticipants.
        """
        super().__init__()

        self.chat_id = chat_id
        self.self_participant = self_participant

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'self_participant': None if self.self_participant is None else self.self_participant.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChatParticipantsForbidden.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.self_participant else 0
        writer.write_int(flags)

        writer.write_int(self.chat_id)
        if self.self_participant:
            self.self_participant.on_send(writer)

    @staticmethod
    def empty():
        return ChatParticipantsForbidden(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.chat_id = reader.read_int()
        if (flags & (1 << 0)) != 0:
            self.self_participant = reader.tgread_object()

    def __repr__(self):
        return 'chatParticipantsForbidden#fc900c2b flags:# chat_id:int self_participant:flags.0?ChatParticipant = ChatParticipants'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatPhoto(TLObject):
    constructor_id = 0x6153276a
    subclass_of_id = 0xac3ec4e5

    def __init__(self, photo_small, photo_big):
        """
        :param photo_small: Telegram type: "FileLocation".
        :param photo_big: Telegram type: "FileLocation".

        Constructor for ChatPhoto: Instance of either ChatPhotoEmpty, ChatPhoto.
        """
        super().__init__()

        self.photo_small = photo_small
        self.photo_big = photo_big

    def to_dict(self):
        return {
            'photo_small': None if self.photo_small is None else self.photo_small.to_dict(),
            'photo_big': None if self.photo_big is None else self.photo_big.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ChatPhoto.constructor_id, signed=False)
        self.photo_small.on_send(writer)
        self.photo_big.on_send(writer)

    @staticmethod
    def empty():
        return ChatPhoto(None, None)

    def on_response(self, reader):
        self.photo_small = reader.tgread_object()
        self.photo_big = reader.tgread_object()

    def __repr__(self):
        return 'chatPhoto#6153276a photo_small:FileLocation photo_big:FileLocation = ChatPhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ChatPhotoEmpty(TLObject):
    constructor_id = 0x37c1011c
    subclass_of_id = 0xac3ec4e5

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ChatPhotoEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ChatPhotoEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'chatPhotoEmpty#37c1011c = ChatPhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ClientDHInnerData(TLObject):
    constructor_id = 0x6643b654
    subclass_of_id = 0xf8eeef6a

    def __init__(self, nonce, server_nonce, retry_id, g_b):
        """
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param retry_id: Telegram type: "long".
        :param g_b: Telegram type: "string".

        Constructor for Client_DH_Inner_Data: Instance of ClientDHInnerData.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.retry_id = retry_id
        self.g_b = g_b

    def to_dict(self):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'retry_id': self.retry_id,
            'g_b': self.g_b,
        }

    def on_send(self, writer):
        writer.write_int(ClientDHInnerData.constructor_id, signed=False)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.write_long(self.retry_id)
        writer.tgwrite_string(self.g_b)

    @staticmethod
    def empty():
        return ClientDHInnerData(None, None, None, None)

    def on_response(self, reader):
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.retry_id = reader.read_long()
        self.g_b = reader.tgread_string()

    def __repr__(self):
        return 'client_DH_inner_data#6643b654 nonce:int128 server_nonce:int128 retry_id:long g_b:string = Client_DH_Inner_Data'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Config(TLObject):
    constructor_id = 0x8df376a4
    subclass_of_id = 0xd3262a4a

    def __init__(self, date, expires, test_mode, this_dc, dc_options, chat_size_max, megagroup_size_max, forwarded_count_max, online_update_period_ms, offline_blur_timeout_ms, offline_idle_timeout_ms, online_cloud_timeout_ms, notify_cloud_delay_ms, notify_default_delay_ms, chat_big_size, push_chat_period_ms, push_chat_limit, saved_gifs_limit, edit_time_limit, rating_e_decay, stickers_recent_limit, stickers_faved_limit, pinned_dialogs_count_max, call_receive_timeout_ms, call_ring_timeout_ms, call_connect_timeout_ms, call_packet_timeout_ms, me_url_prefix, disabled_features, phonecalls_enabled=None, tmp_sessions=None, suggested_lang_code=None, lang_pack_version=None):
        """
        :param phonecalls_enabled: Telegram type: "true".
        :param date: Telegram type: "date".
        :param expires: Telegram type: "date".
        :param test_mode: Telegram type: "Bool".
        :param this_dc: Telegram type: "int".
        :param dc_options: Telegram type: "DcOption". Must be a list.
        :param chat_size_max: Telegram type: "int".
        :param megagroup_size_max: Telegram type: "int".
        :param forwarded_count_max: Telegram type: "int".
        :param online_update_period_ms: Telegram type: "int".
        :param offline_blur_timeout_ms: Telegram type: "int".
        :param offline_idle_timeout_ms: Telegram type: "int".
        :param online_cloud_timeout_ms: Telegram type: "int".
        :param notify_cloud_delay_ms: Telegram type: "int".
        :param notify_default_delay_ms: Telegram type: "int".
        :param chat_big_size: Telegram type: "int".
        :param push_chat_period_ms: Telegram type: "int".
        :param push_chat_limit: Telegram type: "int".
        :param saved_gifs_limit: Telegram type: "int".
        :param edit_time_limit: Telegram type: "int".
        :param rating_e_decay: Telegram type: "int".
        :param stickers_recent_limit: Telegram type: "int".
        :param stickers_faved_limit: Telegram type: "int".
        :param tmp_sessions: Telegram type: "int".
        :param pinned_dialogs_count_max: Telegram type: "int".
        :param call_receive_timeout_ms: Telegram type: "int".
        :param call_ring_timeout_ms: Telegram type: "int".
        :param call_connect_timeout_ms: Telegram type: "int".
        :param call_packet_timeout_ms: Telegram type: "int".
        :param me_url_prefix: Telegram type: "string".
        :param suggested_lang_code: Telegram type: "string".
        :param lang_pack_version: Telegram type: "int".
        :param disabled_features: Telegram type: "DisabledFeature". Must be a list.

        Constructor for Config: Instance of Config.
        """
        super().__init__()

        self.phonecalls_enabled = phonecalls_enabled
        self.date = date
        self.expires = expires
        self.test_mode = test_mode
        self.this_dc = this_dc
        self.dc_options = dc_options
        self.chat_size_max = chat_size_max
        self.megagroup_size_max = megagroup_size_max
        self.forwarded_count_max = forwarded_count_max
        self.online_update_period_ms = online_update_period_ms
        self.offline_blur_timeout_ms = offline_blur_timeout_ms
        self.offline_idle_timeout_ms = offline_idle_timeout_ms
        self.online_cloud_timeout_ms = online_cloud_timeout_ms
        self.notify_cloud_delay_ms = notify_cloud_delay_ms
        self.notify_default_delay_ms = notify_default_delay_ms
        self.chat_big_size = chat_big_size
        self.push_chat_period_ms = push_chat_period_ms
        self.push_chat_limit = push_chat_limit
        self.saved_gifs_limit = saved_gifs_limit
        self.edit_time_limit = edit_time_limit
        self.rating_e_decay = rating_e_decay
        self.stickers_recent_limit = stickers_recent_limit
        self.stickers_faved_limit = stickers_faved_limit
        self.tmp_sessions = tmp_sessions
        self.pinned_dialogs_count_max = pinned_dialogs_count_max
        self.call_receive_timeout_ms = call_receive_timeout_ms
        self.call_ring_timeout_ms = call_ring_timeout_ms
        self.call_connect_timeout_ms = call_connect_timeout_ms
        self.call_packet_timeout_ms = call_packet_timeout_ms
        self.me_url_prefix = me_url_prefix
        self.suggested_lang_code = suggested_lang_code
        self.lang_pack_version = lang_pack_version
        self.disabled_features = disabled_features

    def to_dict(self):
        return {
            'phonecalls_enabled': self.phonecalls_enabled,
            'date': self.date,
            'expires': self.expires,
            'test_mode': self.test_mode,
            'this_dc': self.this_dc,
            'dc_options': [] if self.dc_options is None else [None if x is None else x.to_dict() for x in self.dc_options],
            'chat_size_max': self.chat_size_max,
            'megagroup_size_max': self.megagroup_size_max,
            'forwarded_count_max': self.forwarded_count_max,
            'online_update_period_ms': self.online_update_period_ms,
            'offline_blur_timeout_ms': self.offline_blur_timeout_ms,
            'offline_idle_timeout_ms': self.offline_idle_timeout_ms,
            'online_cloud_timeout_ms': self.online_cloud_timeout_ms,
            'notify_cloud_delay_ms': self.notify_cloud_delay_ms,
            'notify_default_delay_ms': self.notify_default_delay_ms,
            'chat_big_size': self.chat_big_size,
            'push_chat_period_ms': self.push_chat_period_ms,
            'push_chat_limit': self.push_chat_limit,
            'saved_gifs_limit': self.saved_gifs_limit,
            'edit_time_limit': self.edit_time_limit,
            'rating_e_decay': self.rating_e_decay,
            'stickers_recent_limit': self.stickers_recent_limit,
            'stickers_faved_limit': self.stickers_faved_limit,
            'tmp_sessions': self.tmp_sessions,
            'pinned_dialogs_count_max': self.pinned_dialogs_count_max,
            'call_receive_timeout_ms': self.call_receive_timeout_ms,
            'call_ring_timeout_ms': self.call_ring_timeout_ms,
            'call_connect_timeout_ms': self.call_connect_timeout_ms,
            'call_packet_timeout_ms': self.call_packet_timeout_ms,
            'me_url_prefix': self.me_url_prefix,
            'suggested_lang_code': self.suggested_lang_code,
            'lang_pack_version': self.lang_pack_version,
            'disabled_features': [] if self.disabled_features is None else [None if x is None else x.to_dict() for x in self.disabled_features],
        }

    def on_send(self, writer):
        writer.write_int(Config.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.phonecalls_enabled else 0
        flags |= (1 << 0) if self.tmp_sessions else 0
        flags |= (1 << 2) if self.suggested_lang_code else 0
        flags |= (1 << 2) if self.lang_pack_version else 0
        writer.write_int(flags)

        writer.tgwrite_date(self.date)
        writer.tgwrite_date(self.expires)
        writer.tgwrite_bool(self.test_mode)
        writer.write_int(self.this_dc)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.dc_options))
        for _x in self.dc_options:
            _x.on_send(writer)

        writer.write_int(self.chat_size_max)
        writer.write_int(self.megagroup_size_max)
        writer.write_int(self.forwarded_count_max)
        writer.write_int(self.online_update_period_ms)
        writer.write_int(self.offline_blur_timeout_ms)
        writer.write_int(self.offline_idle_timeout_ms)
        writer.write_int(self.online_cloud_timeout_ms)
        writer.write_int(self.notify_cloud_delay_ms)
        writer.write_int(self.notify_default_delay_ms)
        writer.write_int(self.chat_big_size)
        writer.write_int(self.push_chat_period_ms)
        writer.write_int(self.push_chat_limit)
        writer.write_int(self.saved_gifs_limit)
        writer.write_int(self.edit_time_limit)
        writer.write_int(self.rating_e_decay)
        writer.write_int(self.stickers_recent_limit)
        writer.write_int(self.stickers_faved_limit)
        if self.tmp_sessions:
            writer.write_int(self.tmp_sessions)

        writer.write_int(self.pinned_dialogs_count_max)
        writer.write_int(self.call_receive_timeout_ms)
        writer.write_int(self.call_ring_timeout_ms)
        writer.write_int(self.call_connect_timeout_ms)
        writer.write_int(self.call_packet_timeout_ms)
        writer.tgwrite_string(self.me_url_prefix)
        if self.suggested_lang_code:
            writer.tgwrite_string(self.suggested_lang_code)

        if self.lang_pack_version:
            writer.write_int(self.lang_pack_version)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.disabled_features))
        for _x in self.disabled_features:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Config(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.phonecalls_enabled = True

        self.date = reader.tgread_date()
        self.expires = reader.tgread_date()
        self.test_mode = reader.tgread_bool()
        self.this_dc = reader.read_int()
        reader.read_int()
        self.dc_options = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.dc_options.append(_x)

        self.chat_size_max = reader.read_int()
        self.megagroup_size_max = reader.read_int()
        self.forwarded_count_max = reader.read_int()
        self.online_update_period_ms = reader.read_int()
        self.offline_blur_timeout_ms = reader.read_int()
        self.offline_idle_timeout_ms = reader.read_int()
        self.online_cloud_timeout_ms = reader.read_int()
        self.notify_cloud_delay_ms = reader.read_int()
        self.notify_default_delay_ms = reader.read_int()
        self.chat_big_size = reader.read_int()
        self.push_chat_period_ms = reader.read_int()
        self.push_chat_limit = reader.read_int()
        self.saved_gifs_limit = reader.read_int()
        self.edit_time_limit = reader.read_int()
        self.rating_e_decay = reader.read_int()
        self.stickers_recent_limit = reader.read_int()
        self.stickers_faved_limit = reader.read_int()
        if (flags & (1 << 0)) != 0:
            self.tmp_sessions = reader.read_int()

        self.pinned_dialogs_count_max = reader.read_int()
        self.call_receive_timeout_ms = reader.read_int()
        self.call_ring_timeout_ms = reader.read_int()
        self.call_connect_timeout_ms = reader.read_int()
        self.call_packet_timeout_ms = reader.read_int()
        self.me_url_prefix = reader.tgread_string()
        if (flags & (1 << 2)) != 0:
            self.suggested_lang_code = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.lang_pack_version = reader.read_int()

        reader.read_int()
        self.disabled_features = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.disabled_features.append(_x)

    def __repr__(self):
        return 'config#8df376a4 flags:# phonecalls_enabled:flags.1?true date:int expires:int test_mode:Bool this_dc:int dc_options:Vector<DcOption> chat_size_max:int megagroup_size_max:int forwarded_count_max:int online_update_period_ms:int offline_blur_timeout_ms:int offline_idle_timeout_ms:int online_cloud_timeout_ms:int notify_cloud_delay_ms:int notify_default_delay_ms:int chat_big_size:int push_chat_period_ms:int push_chat_limit:int saved_gifs_limit:int edit_time_limit:int rating_e_decay:int stickers_recent_limit:int stickers_faved_limit:int tmp_sessions:flags.0?int pinned_dialogs_count_max:int call_receive_timeout_ms:int call_ring_timeout_ms:int call_connect_timeout_ms:int call_packet_timeout_ms:int me_url_prefix:string suggested_lang_code:flags.2?string lang_pack_version:flags.2?int disabled_features:Vector<DisabledFeature> = Config'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Contact(TLObject):
    constructor_id = 0xf911c994
    subclass_of_id = 0x83dfdfa4

    def __init__(self, user_id, mutual):
        """
        :param user_id: Telegram type: "int".
        :param mutual: Telegram type: "Bool".

        Constructor for Contact: Instance of Contact.
        """
        super().__init__()

        self.user_id = user_id
        self.mutual = mutual

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'mutual': self.mutual,
        }

    def on_send(self, writer):
        writer.write_int(Contact.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_bool(self.mutual)

    @staticmethod
    def empty():
        return Contact(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.mutual = reader.tgread_bool()

    def __repr__(self):
        return 'contact#f911c994 user_id:int mutual:Bool = Contact'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ContactBlocked(TLObject):
    constructor_id = 0x561bc879
    subclass_of_id = 0xb12d7ac6

    def __init__(self, user_id, date):
        """
        :param user_id: Telegram type: "int".
        :param date: Telegram type: "date".

        Constructor for ContactBlocked: Instance of ContactBlocked.
        """
        super().__init__()

        self.user_id = user_id
        self.date = date

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(ContactBlocked.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return ContactBlocked(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'contactBlocked#561bc879 user_id:int date:int = ContactBlocked'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ContactLinkContact(TLObject):
    constructor_id = 0xd502c2d0
    subclass_of_id = 0xa053c1da

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ContactLinkContact.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ContactLinkContact()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'contactLinkContact#d502c2d0 = ContactLink'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ContactLinkHasPhone(TLObject):
    constructor_id = 0x268f3f59
    subclass_of_id = 0xa053c1da

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ContactLinkHasPhone.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ContactLinkHasPhone()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'contactLinkHasPhone#268f3f59 = ContactLink'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ContactLinkNone(TLObject):
    constructor_id = 0xfeedd3ad
    subclass_of_id = 0xa053c1da

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ContactLinkNone.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ContactLinkNone()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'contactLinkNone#feedd3ad = ContactLink'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ContactLinkUnknown(TLObject):
    constructor_id = 0x5f4f9247
    subclass_of_id = 0xa053c1da

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(ContactLinkUnknown.constructor_id, signed=False)

    @staticmethod
    def empty():
        return ContactLinkUnknown()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'contactLinkUnknown#5f4f9247 = ContactLink'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ContactStatus(TLObject):
    constructor_id = 0xd3680c61
    subclass_of_id = 0x68c0d74c

    def __init__(self, user_id, status):
        """
        :param user_id: Telegram type: "int".
        :param status: Telegram type: "UserStatus".

        Constructor for ContactStatus: Instance of ContactStatus.
        """
        super().__init__()

        self.user_id = user_id
        self.status = status

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'status': None if self.status is None else self.status.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(ContactStatus.constructor_id, signed=False)
        writer.write_int(self.user_id)
        self.status.on_send(writer)

    @staticmethod
    def empty():
        return ContactStatus(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.status = reader.tgread_object()

    def __repr__(self):
        return 'contactStatus#d3680c61 user_id:int status:UserStatus = ContactStatus'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DataJSON(TLObject):
    constructor_id = 0x7d748d04
    subclass_of_id = 0xad0352e8

    def __init__(self, data):
        """
        :param data: Telegram type: "string".

        Constructor for DataJSON: Instance of DataJSON.
        """
        super().__init__()

        self.data = data

    def to_dict(self):
        return {
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(DataJSON.constructor_id, signed=False)
        writer.tgwrite_string(self.data)

    @staticmethod
    def empty():
        return DataJSON(None)

    def on_response(self, reader):
        self.data = reader.tgread_string()

    def __repr__(self):
        return 'dataJSON#7d748d04 data:string = DataJSON'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DcOption(TLObject):
    constructor_id = 0x5d8c6cc
    subclass_of_id = 0x9e43e123

    def __init__(self, id, ip_address, port, ipv6=None, media_only=None, tcpo_only=None, cdn=None, static=None):
        """
        :param ipv6: Telegram type: "true".
        :param media_only: Telegram type: "true".
        :param tcpo_only: Telegram type: "true".
        :param cdn: Telegram type: "true".
        :param static: Telegram type: "true".
        :param id: Telegram type: "int".
        :param ip_address: Telegram type: "string".
        :param port: Telegram type: "int".

        Constructor for DcOption: Instance of DcOption.
        """
        super().__init__()

        self.ipv6 = ipv6
        self.media_only = media_only
        self.tcpo_only = tcpo_only
        self.cdn = cdn
        self.static = static
        self.id = id
        self.ip_address = ip_address
        self.port = port

    def to_dict(self):
        return {
            'ipv6': self.ipv6,
            'media_only': self.media_only,
            'tcpo_only': self.tcpo_only,
            'cdn': self.cdn,
            'static': self.static,
            'id': self.id,
            'ip_address': self.ip_address,
            'port': self.port,
        }

    def on_send(self, writer):
        writer.write_int(DcOption.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.ipv6 else 0
        flags |= (1 << 1) if self.media_only else 0
        flags |= (1 << 2) if self.tcpo_only else 0
        flags |= (1 << 3) if self.cdn else 0
        flags |= (1 << 4) if self.static else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        writer.tgwrite_string(self.ip_address)
        writer.write_int(self.port)

    @staticmethod
    def empty():
        return DcOption(None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.ipv6 = True

        if (flags & (1 << 1)) != 0:
            self.media_only = True

        if (flags & (1 << 2)) != 0:
            self.tcpo_only = True

        if (flags & (1 << 3)) != 0:
            self.cdn = True

        if (flags & (1 << 4)) != 0:
            self.static = True

        self.id = reader.read_int()
        self.ip_address = reader.tgread_string()
        self.port = reader.read_int()

    def __repr__(self):
        return 'dcOption#05d8c6cc flags:# ipv6:flags.0?true media_only:flags.1?true tcpo_only:flags.2?true cdn:flags.3?true static:flags.4?true id:int ip_address:string port:int = DcOption'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DestroyAuthKeyFail(TLObject):
    constructor_id = 0xea109b13
    subclass_of_id = 0x8291e68e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(DestroyAuthKeyFail.constructor_id, signed=False)

    @staticmethod
    def empty():
        return DestroyAuthKeyFail()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'destroy_auth_key_fail#ea109b13 = DestroyAuthKeyRes'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DestroyAuthKeyNone(TLObject):
    constructor_id = 0xa9f2259
    subclass_of_id = 0x8291e68e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(DestroyAuthKeyNone.constructor_id, signed=False)

    @staticmethod
    def empty():
        return DestroyAuthKeyNone()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'destroy_auth_key_none#0a9f2259 = DestroyAuthKeyRes'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DestroyAuthKeyOk(TLObject):
    constructor_id = 0xf660e1d4
    subclass_of_id = 0x8291e68e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(DestroyAuthKeyOk.constructor_id, signed=False)

    @staticmethod
    def empty():
        return DestroyAuthKeyOk()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'destroy_auth_key_ok#f660e1d4 = DestroyAuthKeyRes'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DestroySessionNone(TLObject):
    constructor_id = 0x62d350c9
    subclass_of_id = 0xaf0ce7bd

    def __init__(self, session_id):
        """
        :param session_id: Telegram type: "long".

        Constructor for DestroySessionRes: Instance of either DestroySessionOk, DestroySessionNone.
        """
        super().__init__()

        self.session_id = session_id

    def to_dict(self):
        return {
            'session_id': self.session_id,
        }

    def on_send(self, writer):
        writer.write_int(DestroySessionNone.constructor_id, signed=False)
        writer.write_long(self.session_id)

    @staticmethod
    def empty():
        return DestroySessionNone(None)

    def on_response(self, reader):
        self.session_id = reader.read_long()

    def __repr__(self):
        return 'destroy_session_none#62d350c9 session_id:long = DestroySessionRes'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DestroySessionOk(TLObject):
    constructor_id = 0xe22045fc
    subclass_of_id = 0xaf0ce7bd

    def __init__(self, session_id):
        """
        :param session_id: Telegram type: "long".

        Constructor for DestroySessionRes: Instance of either DestroySessionOk, DestroySessionNone.
        """
        super().__init__()

        self.session_id = session_id

    def to_dict(self):
        return {
            'session_id': self.session_id,
        }

    def on_send(self, writer):
        writer.write_int(DestroySessionOk.constructor_id, signed=False)
        writer.write_long(self.session_id)

    @staticmethod
    def empty():
        return DestroySessionOk(None)

    def on_response(self, reader):
        self.session_id = reader.read_long()

    def __repr__(self):
        return 'destroy_session_ok#e22045fc session_id:long = DestroySessionRes'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DhGenFail(TLObject):
    constructor_id = 0xa69dae02
    subclass_of_id = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash3):
        """
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param new_nonce_hash3: Telegram type: "int128".

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce_hash3 = new_nonce_hash3

    def to_dict(self):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash3': self.new_nonce_hash3,
        }

    def on_send(self, writer):
        writer.write_int(DhGenFail.constructor_id, signed=False)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.write_large_int(self.new_nonce_hash3, bits=128)

    @staticmethod
    def empty():
        return DhGenFail(None, None, None)

    def on_response(self, reader):
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.new_nonce_hash3 = reader.read_large_int(bits=128)

    def __repr__(self):
        return 'dh_gen_fail#a69dae02 nonce:int128 server_nonce:int128 new_nonce_hash3:int128 = Set_client_DH_params_answer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DhGenOk(TLObject):
    constructor_id = 0x3bcbf734
    subclass_of_id = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash1):
        """
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param new_nonce_hash1: Telegram type: "int128".

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce_hash1 = new_nonce_hash1

    def to_dict(self):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash1': self.new_nonce_hash1,
        }

    def on_send(self, writer):
        writer.write_int(DhGenOk.constructor_id, signed=False)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.write_large_int(self.new_nonce_hash1, bits=128)

    @staticmethod
    def empty():
        return DhGenOk(None, None, None)

    def on_response(self, reader):
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.new_nonce_hash1 = reader.read_large_int(bits=128)

    def __repr__(self):
        return 'dh_gen_ok#3bcbf734 nonce:int128 server_nonce:int128 new_nonce_hash1:int128 = Set_client_DH_params_answer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DhGenRetry(TLObject):
    constructor_id = 0x46dc1fb9
    subclass_of_id = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash2):
        """
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param new_nonce_hash2: Telegram type: "int128".

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce_hash2 = new_nonce_hash2

    def to_dict(self):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash2': self.new_nonce_hash2,
        }

    def on_send(self, writer):
        writer.write_int(DhGenRetry.constructor_id, signed=False)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.write_large_int(self.new_nonce_hash2, bits=128)

    @staticmethod
    def empty():
        return DhGenRetry(None, None, None)

    def on_response(self, reader):
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.new_nonce_hash2 = reader.read_large_int(bits=128)

    def __repr__(self):
        return 'dh_gen_retry#46dc1fb9 nonce:int128 server_nonce:int128 new_nonce_hash2:int128 = Set_client_DH_params_answer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Dialog(TLObject):
    constructor_id = 0xe4def5db
    subclass_of_id = 0x42cddd54

    def __init__(self, peer, top_message, read_inbox_max_id, read_outbox_max_id, unread_count, unread_mentions_count, notify_settings, pinned=None, pts=None, draft=None):
        """
        :param pinned: Telegram type: "true".
        :param peer: Telegram type: "Peer".
        :param top_message: Telegram type: "int".
        :param read_inbox_max_id: Telegram type: "int".
        :param read_outbox_max_id: Telegram type: "int".
        :param unread_count: Telegram type: "int".
        :param unread_mentions_count: Telegram type: "int".
        :param notify_settings: Telegram type: "PeerNotifySettings".
        :param pts: Telegram type: "int".
        :param draft: Telegram type: "DraftMessage".

        Constructor for Dialog: Instance of Dialog.
        """
        super().__init__()

        self.pinned = pinned
        self.peer = peer
        self.top_message = top_message
        self.read_inbox_max_id = read_inbox_max_id
        self.read_outbox_max_id = read_outbox_max_id
        self.unread_count = unread_count
        self.unread_mentions_count = unread_mentions_count
        self.notify_settings = notify_settings
        self.pts = pts
        self.draft = draft

    def to_dict(self):
        return {
            'pinned': self.pinned,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'top_message': self.top_message,
            'read_inbox_max_id': self.read_inbox_max_id,
            'read_outbox_max_id': self.read_outbox_max_id,
            'unread_count': self.unread_count,
            'unread_mentions_count': self.unread_mentions_count,
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'pts': self.pts,
            'draft': None if self.draft is None else self.draft.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(Dialog.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.pinned else 0
        flags |= (1 << 0) if self.pts else 0
        flags |= (1 << 1) if self.draft else 0
        writer.write_int(flags)

        self.peer.on_send(writer)
        writer.write_int(self.top_message)
        writer.write_int(self.read_inbox_max_id)
        writer.write_int(self.read_outbox_max_id)
        writer.write_int(self.unread_count)
        writer.write_int(self.unread_mentions_count)
        self.notify_settings.on_send(writer)
        if self.pts:
            writer.write_int(self.pts)

        if self.draft:
            self.draft.on_send(writer)

    @staticmethod
    def empty():
        return Dialog(None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 2)) != 0:
            self.pinned = True

        self.peer = reader.tgread_object()
        self.top_message = reader.read_int()
        self.read_inbox_max_id = reader.read_int()
        self.read_outbox_max_id = reader.read_int()
        self.unread_count = reader.read_int()
        self.unread_mentions_count = reader.read_int()
        self.notify_settings = reader.tgread_object()
        if (flags & (1 << 0)) != 0:
            self.pts = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.draft = reader.tgread_object()

    def __repr__(self):
        return 'dialog#e4def5db flags:# pinned:flags.2?true peer:Peer top_message:int read_inbox_max_id:int read_outbox_max_id:int unread_count:int unread_mentions_count:int notify_settings:PeerNotifySettings pts:flags.0?int draft:flags.1?DraftMessage = Dialog'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DisabledFeature(TLObject):
    constructor_id = 0xae636f24
    subclass_of_id = 0xcd266f94

    def __init__(self, feature, description):
        """
        :param feature: Telegram type: "string".
        :param description: Telegram type: "string".

        Constructor for DisabledFeature: Instance of DisabledFeature.
        """
        super().__init__()

        self.feature = feature
        self.description = description

    def to_dict(self):
        return {
            'feature': self.feature,
            'description': self.description,
        }

    def on_send(self, writer):
        writer.write_int(DisabledFeature.constructor_id, signed=False)
        writer.tgwrite_string(self.feature)
        writer.tgwrite_string(self.description)

    @staticmethod
    def empty():
        return DisabledFeature(None, None)

    def on_response(self, reader):
        self.feature = reader.tgread_string()
        self.description = reader.tgread_string()

    def __repr__(self):
        return 'disabledFeature#ae636f24 feature:string description:string = DisabledFeature'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Document(TLObject):
    constructor_id = 0x87232bc7
    subclass_of_id = 0x211fe820

    def __init__(self, id, access_hash, date, mime_type, size, thumb, dc_id, version, attributes):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param mime_type: Telegram type: "string".
        :param size: Telegram type: "int".
        :param thumb: Telegram type: "PhotoSize".
        :param dc_id: Telegram type: "int".
        :param version: Telegram type: "int".
        :param attributes: Telegram type: "DocumentAttribute". Must be a list.

        Constructor for Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.mime_type = mime_type
        self.size = size
        self.thumb = thumb
        self.dc_id = dc_id
        self.version = version
        self.attributes = attributes

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'mime_type': self.mime_type,
            'size': self.size,
            'thumb': None if self.thumb is None else self.thumb.to_dict(),
            'dc_id': self.dc_id,
            'version': self.version,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes],
        }

    def on_send(self, writer):
        writer.write_int(Document.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.tgwrite_string(self.mime_type)
        writer.write_int(self.size)
        self.thumb.on_send(writer)
        writer.write_int(self.dc_id)
        writer.write_int(self.version)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.attributes))
        for _x in self.attributes:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Document(None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        self.mime_type = reader.tgread_string()
        self.size = reader.read_int()
        self.thumb = reader.tgread_object()
        self.dc_id = reader.read_int()
        self.version = reader.read_int()
        reader.read_int()
        self.attributes = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.attributes.append(_x)

    def __repr__(self):
        return 'document#87232bc7 id:long access_hash:long date:int mime_type:string size:int thumb:PhotoSize dc_id:int version:int attributes:Vector<DocumentAttribute> = Document'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DocumentAttributeAnimated(TLObject):
    constructor_id = 0x11b58939
    subclass_of_id = 0xf729eb9b

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(DocumentAttributeAnimated.constructor_id, signed=False)

    @staticmethod
    def empty():
        return DocumentAttributeAnimated()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'documentAttributeAnimated#11b58939 = DocumentAttribute'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DocumentAttributeAudio(TLObject):
    constructor_id = 0x9852f9c6
    subclass_of_id = 0xf729eb9b

    def __init__(self, duration, voice=None, title=None, performer=None, waveform=None):
        """
        :param voice: Telegram type: "true".
        :param duration: Telegram type: "int".
        :param title: Telegram type: "string".
        :param performer: Telegram type: "string".
        :param waveform: Telegram type: "bytes".

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.voice = voice
        self.duration = duration
        self.title = title
        self.performer = performer
        self.waveform = waveform

    def to_dict(self):
        return {
            'voice': self.voice,
            'duration': self.duration,
            'title': self.title,
            'performer': self.performer,
            'waveform': self.waveform,
        }

    def on_send(self, writer):
        writer.write_int(DocumentAttributeAudio.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 10) if self.voice else 0
        flags |= (1 << 0) if self.title else 0
        flags |= (1 << 1) if self.performer else 0
        flags |= (1 << 2) if self.waveform else 0
        writer.write_int(flags)

        writer.write_int(self.duration)
        if self.title:
            writer.tgwrite_string(self.title)

        if self.performer:
            writer.tgwrite_string(self.performer)

        if self.waveform:
            writer.tgwrite_bytes(self.waveform)

    @staticmethod
    def empty():
        return DocumentAttributeAudio(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 10)) != 0:
            self.voice = True

        self.duration = reader.read_int()
        if (flags & (1 << 0)) != 0:
            self.title = reader.tgread_string()

        if (flags & (1 << 1)) != 0:
            self.performer = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.waveform = reader.tgread_bytes()

    def __repr__(self):
        return 'documentAttributeAudio#9852f9c6 flags:# voice:flags.10?true duration:int title:flags.0?string performer:flags.1?string waveform:flags.2?bytes = DocumentAttribute'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DocumentAttributeFilename(TLObject):
    constructor_id = 0x15590068
    subclass_of_id = 0xf729eb9b

    def __init__(self, file_name):
        """
        :param file_name: Telegram type: "string".

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.file_name = file_name

    def to_dict(self):
        return {
            'file_name': self.file_name,
        }

    def on_send(self, writer):
        writer.write_int(DocumentAttributeFilename.constructor_id, signed=False)
        writer.tgwrite_string(self.file_name)

    @staticmethod
    def empty():
        return DocumentAttributeFilename(None)

    def on_response(self, reader):
        self.file_name = reader.tgread_string()

    def __repr__(self):
        return 'documentAttributeFilename#15590068 file_name:string = DocumentAttribute'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DocumentAttributeHasStickers(TLObject):
    constructor_id = 0x9801d2f7
    subclass_of_id = 0xf729eb9b

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(DocumentAttributeHasStickers.constructor_id, signed=False)

    @staticmethod
    def empty():
        return DocumentAttributeHasStickers()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'documentAttributeHasStickers#9801d2f7 = DocumentAttribute'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DocumentAttributeImageSize(TLObject):
    constructor_id = 0x6c37c15c
    subclass_of_id = 0xf729eb9b

    def __init__(self, w, h):
        """
        :param w: Telegram type: "int".
        :param h: Telegram type: "int".

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.w = w
        self.h = h

    def to_dict(self):
        return {
            'w': self.w,
            'h': self.h,
        }

    def on_send(self, writer):
        writer.write_int(DocumentAttributeImageSize.constructor_id, signed=False)
        writer.write_int(self.w)
        writer.write_int(self.h)

    @staticmethod
    def empty():
        return DocumentAttributeImageSize(None, None)

    def on_response(self, reader):
        self.w = reader.read_int()
        self.h = reader.read_int()

    def __repr__(self):
        return 'documentAttributeImageSize#6c37c15c w:int h:int = DocumentAttribute'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DocumentAttributeSticker(TLObject):
    constructor_id = 0x6319d612
    subclass_of_id = 0xf729eb9b

    def __init__(self, alt, stickerset, mask=None, mask_coords=None):
        """
        :param mask: Telegram type: "true".
        :param alt: Telegram type: "string".
        :param stickerset: Telegram type: "InputStickerSet".
        :param mask_coords: Telegram type: "MaskCoords".

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.mask = mask
        self.alt = alt
        self.stickerset = stickerset
        self.mask_coords = mask_coords

    def to_dict(self):
        return {
            'mask': self.mask,
            'alt': self.alt,
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
            'mask_coords': None if self.mask_coords is None else self.mask_coords.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(DocumentAttributeSticker.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.mask else 0
        flags |= (1 << 0) if self.mask_coords else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.alt)
        self.stickerset.on_send(writer)
        if self.mask_coords:
            self.mask_coords.on_send(writer)

    @staticmethod
    def empty():
        return DocumentAttributeSticker(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.mask = True

        self.alt = reader.tgread_string()
        self.stickerset = reader.tgread_object()
        if (flags & (1 << 0)) != 0:
            self.mask_coords = reader.tgread_object()

    def __repr__(self):
        return 'documentAttributeSticker#6319d612 flags:# mask:flags.1?true alt:string stickerset:InputStickerSet mask_coords:flags.0?MaskCoords = DocumentAttribute'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DocumentAttributeVideo(TLObject):
    constructor_id = 0xef02ce6
    subclass_of_id = 0xf729eb9b

    def __init__(self, duration, w, h, round_message=None):
        """
        :param round_message: Telegram type: "true".
        :param duration: Telegram type: "int".
        :param w: Telegram type: "int".
        :param h: Telegram type: "int".

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.round_message = round_message
        self.duration = duration
        self.w = w
        self.h = h

    def to_dict(self):
        return {
            'round_message': self.round_message,
            'duration': self.duration,
            'w': self.w,
            'h': self.h,
        }

    def on_send(self, writer):
        writer.write_int(DocumentAttributeVideo.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.round_message else 0
        writer.write_int(flags)

        writer.write_int(self.duration)
        writer.write_int(self.w)
        writer.write_int(self.h)

    @staticmethod
    def empty():
        return DocumentAttributeVideo(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.round_message = True

        self.duration = reader.read_int()
        self.w = reader.read_int()
        self.h = reader.read_int()

    def __repr__(self):
        return 'documentAttributeVideo#0ef02ce6 flags:# round_message:flags.0?true duration:int w:int h:int = DocumentAttribute'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DocumentEmpty(TLObject):
    constructor_id = 0x36f8c871
    subclass_of_id = 0x211fe820

    def __init__(self, id):
        """
        :param id: Telegram type: "long".

        Constructor for Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(DocumentEmpty.constructor_id, signed=False)
        writer.write_long(self.id)

    @staticmethod
    def empty():
        return DocumentEmpty(None)

    def on_response(self, reader):
        self.id = reader.read_long()

    def __repr__(self):
        return 'documentEmpty#36f8c871 id:long = Document'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DraftMessage(TLObject):
    constructor_id = 0xfd8e711f
    subclass_of_id = 0x33d47f45

    def __init__(self, message, date, no_webpage=None, reply_to_msg_id=None, entities=None):
        """
        :param no_webpage: Telegram type: "true".
        :param reply_to_msg_id: Telegram type: "int".
        :param message: Telegram type: "string".
        :param entities: Telegram type: "MessageEntity". Must be a list.
        :param date: Telegram type: "date".

        Constructor for DraftMessage: Instance of either DraftMessageEmpty, DraftMessage.
        """
        super().__init__()

        self.no_webpage = no_webpage
        self.reply_to_msg_id = reply_to_msg_id
        self.message = message
        self.entities = entities
        self.date = date

    def to_dict(self):
        return {
            'no_webpage': self.no_webpage,
            'reply_to_msg_id': self.reply_to_msg_id,
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(DraftMessage.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.no_webpage else 0
        flags |= (1 << 0) if self.reply_to_msg_id else 0
        flags |= (1 << 3) if self.entities else 0
        writer.write_int(flags)

        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        writer.tgwrite_string(self.message)
        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return DraftMessage(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.no_webpage = True

        if (flags & (1 << 0)) != 0:
            self.reply_to_msg_id = reader.read_int()

        self.message = reader.tgread_string()
        if (flags & (1 << 3)) != 0:
            reader.read_int()
            self.entities = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.entities.append(_x)

        self.date = reader.tgread_date()

    def __repr__(self):
        return 'draftMessage#fd8e711f flags:# no_webpage:flags.1?true reply_to_msg_id:flags.0?int message:string entities:flags.3?Vector<MessageEntity> date:int = DraftMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class DraftMessageEmpty(TLObject):
    constructor_id = 0xba4baec5
    subclass_of_id = 0x33d47f45

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(DraftMessageEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return DraftMessageEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'draftMessageEmpty#ba4baec5 = DraftMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EncryptedChat(TLObject):
    constructor_id = 0xfa56ce36
    subclass_of_id = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_or_b, key_fingerprint):
        """
        :param id: Telegram type: "int".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param admin_id: Telegram type: "int".
        :param participant_id: Telegram type: "int".
        :param g_a_or_b: Telegram type: "bytes".
        :param key_fingerprint: Telegram type: "long".

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_or_b = g_a_or_b
        self.key_fingerprint = key_fingerprint

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_or_b': self.g_a_or_b,
            'key_fingerprint': self.key_fingerprint,
        }

    def on_send(self, writer):
        writer.write_int(EncryptedChat.constructor_id, signed=False)
        writer.write_int(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.write_int(self.admin_id)
        writer.write_int(self.participant_id)
        writer.tgwrite_bytes(self.g_a_or_b)
        writer.write_long(self.key_fingerprint)

    @staticmethod
    def empty():
        return EncryptedChat(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        self.admin_id = reader.read_int()
        self.participant_id = reader.read_int()
        self.g_a_or_b = reader.tgread_bytes()
        self.key_fingerprint = reader.read_long()

    def __repr__(self):
        return 'encryptedChat#fa56ce36 id:int access_hash:long date:int admin_id:int participant_id:int g_a_or_b:bytes key_fingerprint:long = EncryptedChat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EncryptedChatDiscarded(TLObject):
    constructor_id = 0x13d6dd27
    subclass_of_id = 0x6d28a37a

    def __init__(self, id):
        """
        :param id: Telegram type: "int".

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(EncryptedChatDiscarded.constructor_id, signed=False)
        writer.write_int(self.id)

    @staticmethod
    def empty():
        return EncryptedChatDiscarded(None)

    def on_response(self, reader):
        self.id = reader.read_int()

    def __repr__(self):
        return 'encryptedChatDiscarded#13d6dd27 id:int = EncryptedChat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EncryptedChatEmpty(TLObject):
    constructor_id = 0xab7ec0a0
    subclass_of_id = 0x6d28a37a

    def __init__(self, id):
        """
        :param id: Telegram type: "int".

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(EncryptedChatEmpty.constructor_id, signed=False)
        writer.write_int(self.id)

    @staticmethod
    def empty():
        return EncryptedChatEmpty(None)

    def on_response(self, reader):
        self.id = reader.read_int()

    def __repr__(self):
        return 'encryptedChatEmpty#ab7ec0a0 id:int = EncryptedChat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EncryptedChatRequested(TLObject):
    constructor_id = 0xc878527e
    subclass_of_id = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a):
        """
        :param id: Telegram type: "int".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param admin_id: Telegram type: "int".
        :param participant_id: Telegram type: "int".
        :param g_a: Telegram type: "bytes".

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a = g_a

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a': self.g_a,
        }

    def on_send(self, writer):
        writer.write_int(EncryptedChatRequested.constructor_id, signed=False)
        writer.write_int(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.write_int(self.admin_id)
        writer.write_int(self.participant_id)
        writer.tgwrite_bytes(self.g_a)

    @staticmethod
    def empty():
        return EncryptedChatRequested(None, None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        self.admin_id = reader.read_int()
        self.participant_id = reader.read_int()
        self.g_a = reader.tgread_bytes()

    def __repr__(self):
        return 'encryptedChatRequested#c878527e id:int access_hash:long date:int admin_id:int participant_id:int g_a:bytes = EncryptedChat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EncryptedChatWaiting(TLObject):
    constructor_id = 0x3bf703dc
    subclass_of_id = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id):
        """
        :param id: Telegram type: "int".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param admin_id: Telegram type: "int".
        :param participant_id: Telegram type: "int".

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
        }

    def on_send(self, writer):
        writer.write_int(EncryptedChatWaiting.constructor_id, signed=False)
        writer.write_int(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.write_int(self.admin_id)
        writer.write_int(self.participant_id)

    @staticmethod
    def empty():
        return EncryptedChatWaiting(None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        self.admin_id = reader.read_int()
        self.participant_id = reader.read_int()

    def __repr__(self):
        return 'encryptedChatWaiting#3bf703dc id:int access_hash:long date:int admin_id:int participant_id:int = EncryptedChat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EncryptedFile(TLObject):
    constructor_id = 0x4a70994c
    subclass_of_id = 0x842a67c0

    def __init__(self, id, access_hash, size, dc_id, key_fingerprint):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param size: Telegram type: "int".
        :param dc_id: Telegram type: "int".
        :param key_fingerprint: Telegram type: "int".

        Constructor for EncryptedFile: Instance of either EncryptedFileEmpty, EncryptedFile.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.size = size
        self.dc_id = dc_id
        self.key_fingerprint = key_fingerprint

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'size': self.size,
            'dc_id': self.dc_id,
            'key_fingerprint': self.key_fingerprint,
        }

    def on_send(self, writer):
        writer.write_int(EncryptedFile.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.write_int(self.size)
        writer.write_int(self.dc_id)
        writer.write_int(self.key_fingerprint)

    @staticmethod
    def empty():
        return EncryptedFile(None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.size = reader.read_int()
        self.dc_id = reader.read_int()
        self.key_fingerprint = reader.read_int()

    def __repr__(self):
        return 'encryptedFile#4a70994c id:long access_hash:long size:int dc_id:int key_fingerprint:int = EncryptedFile'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class EncryptedFileEmpty(TLObject):
    constructor_id = 0xc21f497e
    subclass_of_id = 0x842a67c0

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(EncryptedFileEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return EncryptedFileEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'encryptedFileEmpty#c21f497e = EncryptedFile'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

import os


class EncryptedMessage(TLObject):
    constructor_id = 0xed18c118
    subclass_of_id = 0x239f2e51

    def __init__(self, chat_id, date, bytes, file, random_id=None):
        """
        :param random_id: Telegram type: "long".
        :param chat_id: Telegram type: "int".
        :param date: Telegram type: "date".
        :param bytes: Telegram type: "bytes".
        :param file: Telegram type: "EncryptedFile".

        Constructor for EncryptedMessage: Instance of either EncryptedMessage, EncryptedMessageService.
        """
        super().__init__()

        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.chat_id = chat_id
        self.date = date
        self.bytes = bytes
        self.file = file

    def to_dict(self):
        return {
            'random_id': self.random_id,
            'chat_id': self.chat_id,
            'date': self.date,
            'bytes': self.bytes,
            'file': None if self.file is None else self.file.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(EncryptedMessage.constructor_id, signed=False)
        writer.write_long(self.random_id)
        writer.write_int(self.chat_id)
        writer.tgwrite_date(self.date)
        writer.tgwrite_bytes(self.bytes)
        self.file.on_send(writer)

    @staticmethod
    def empty():
        return EncryptedMessage(None, None, None, None, None)

    def on_response(self, reader):
        self.random_id = reader.read_long()
        self.chat_id = reader.read_int()
        self.date = reader.tgread_date()
        self.bytes = reader.tgread_bytes()
        self.file = reader.tgread_object()

    def __repr__(self):
        return 'encryptedMessage#ed18c118 random_id:long chat_id:int date:int bytes:bytes file:EncryptedFile = EncryptedMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

import os


class EncryptedMessageService(TLObject):
    constructor_id = 0x23734b06
    subclass_of_id = 0x239f2e51

    def __init__(self, chat_id, date, bytes, random_id=None):
        """
        :param random_id: Telegram type: "long".
        :param chat_id: Telegram type: "int".
        :param date: Telegram type: "date".
        :param bytes: Telegram type: "bytes".

        Constructor for EncryptedMessage: Instance of either EncryptedMessage, EncryptedMessageService.
        """
        super().__init__()

        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.chat_id = chat_id
        self.date = date
        self.bytes = bytes

    def to_dict(self):
        return {
            'random_id': self.random_id,
            'chat_id': self.chat_id,
            'date': self.date,
            'bytes': self.bytes,
        }

    def on_send(self, writer):
        writer.write_int(EncryptedMessageService.constructor_id, signed=False)
        writer.write_long(self.random_id)
        writer.write_int(self.chat_id)
        writer.tgwrite_date(self.date)
        writer.tgwrite_bytes(self.bytes)

    @staticmethod
    def empty():
        return EncryptedMessageService(None, None, None, None)

    def on_response(self, reader):
        self.random_id = reader.read_long()
        self.chat_id = reader.read_int()
        self.date = reader.tgread_date()
        self.bytes = reader.tgread_bytes()

    def __repr__(self):
        return 'encryptedMessageService#23734b06 random_id:long chat_id:int date:int bytes:bytes = EncryptedMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Error(TLObject):
    constructor_id = 0xc4b9f9bb
    subclass_of_id = 0x9c1c9375

    def __init__(self, code, text):
        """
        :param code: Telegram type: "int".
        :param text: Telegram type: "string".

        Constructor for Error: Instance of Error.
        """
        super().__init__()

        self.code = code
        self.text = text

    def to_dict(self):
        return {
            'code': self.code,
            'text': self.text,
        }

    def on_send(self, writer):
        writer.write_int(Error.constructor_id, signed=False)
        writer.write_int(self.code)
        writer.tgwrite_string(self.text)

    @staticmethod
    def empty():
        return Error(None, None)

    def on_response(self, reader):
        self.code = reader.read_int()
        self.text = reader.tgread_string()

    def __repr__(self):
        return 'error#c4b9f9bb code:int text:string = Error'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ExportedMessageLink(TLObject):
    constructor_id = 0x1f486803
    subclass_of_id = 0xdee644cc

    def __init__(self, link):
        """
        :param link: Telegram type: "string".

        Constructor for ExportedMessageLink: Instance of ExportedMessageLink.
        """
        super().__init__()

        self.link = link

    def to_dict(self):
        return {
            'link': self.link,
        }

    def on_send(self, writer):
        writer.write_int(ExportedMessageLink.constructor_id, signed=False)
        writer.tgwrite_string(self.link)

    @staticmethod
    def empty():
        return ExportedMessageLink(None)

    def on_response(self, reader):
        self.link = reader.tgread_string()

    def __repr__(self):
        return 'exportedMessageLink#1f486803 link:string = ExportedMessageLink'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FileLocation(TLObject):
    constructor_id = 0x53d69076
    subclass_of_id = 0x90f76823

    def __init__(self, dc_id, volume_id, local_id, secret):
        """
        :param dc_id: Telegram type: "int".
        :param volume_id: Telegram type: "long".
        :param local_id: Telegram type: "int".
        :param secret: Telegram type: "long".

        Constructor for FileLocation: Instance of either FileLocationUnavailable, FileLocation.
        """
        super().__init__()

        self.dc_id = dc_id
        self.volume_id = volume_id
        self.local_id = local_id
        self.secret = secret

    def to_dict(self):
        return {
            'dc_id': self.dc_id,
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret,
        }

    def on_send(self, writer):
        writer.write_int(FileLocation.constructor_id, signed=False)
        writer.write_int(self.dc_id)
        writer.write_long(self.volume_id)
        writer.write_int(self.local_id)
        writer.write_long(self.secret)

    @staticmethod
    def empty():
        return FileLocation(None, None, None, None)

    def on_response(self, reader):
        self.dc_id = reader.read_int()
        self.volume_id = reader.read_long()
        self.local_id = reader.read_int()
        self.secret = reader.read_long()

    def __repr__(self):
        return 'fileLocation#53d69076 dc_id:int volume_id:long local_id:int secret:long = FileLocation'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FileLocationUnavailable(TLObject):
    constructor_id = 0x7c596b46
    subclass_of_id = 0x90f76823

    def __init__(self, volume_id, local_id, secret):
        """
        :param volume_id: Telegram type: "long".
        :param local_id: Telegram type: "int".
        :param secret: Telegram type: "long".

        Constructor for FileLocation: Instance of either FileLocationUnavailable, FileLocation.
        """
        super().__init__()

        self.volume_id = volume_id
        self.local_id = local_id
        self.secret = secret

    def to_dict(self):
        return {
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret,
        }

    def on_send(self, writer):
        writer.write_int(FileLocationUnavailable.constructor_id, signed=False)
        writer.write_long(self.volume_id)
        writer.write_int(self.local_id)
        writer.write_long(self.secret)

    @staticmethod
    def empty():
        return FileLocationUnavailable(None, None, None)

    def on_response(self, reader):
        self.volume_id = reader.read_long()
        self.local_id = reader.read_int()
        self.secret = reader.read_long()

    def __repr__(self):
        return 'fileLocationUnavailable#7c596b46 volume_id:long local_id:int secret:long = FileLocation'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FoundGif(TLObject):
    constructor_id = 0x162ecc1f
    subclass_of_id = 0x5bbc92c3

    def __init__(self, url, thumb_url, content_url, content_type, w, h):
        """
        :param url: Telegram type: "string".
        :param thumb_url: Telegram type: "string".
        :param content_url: Telegram type: "string".
        :param content_type: Telegram type: "string".
        :param w: Telegram type: "int".
        :param h: Telegram type: "int".

        Constructor for FoundGif: Instance of either FoundGif, FoundGifCached.
        """
        super().__init__()

        self.url = url
        self.thumb_url = thumb_url
        self.content_url = content_url
        self.content_type = content_type
        self.w = w
        self.h = h

    def to_dict(self):
        return {
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h,
        }

    def on_send(self, writer):
        writer.write_int(FoundGif.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        writer.tgwrite_string(self.thumb_url)
        writer.tgwrite_string(self.content_url)
        writer.tgwrite_string(self.content_type)
        writer.write_int(self.w)
        writer.write_int(self.h)

    @staticmethod
    def empty():
        return FoundGif(None, None, None, None, None, None)

    def on_response(self, reader):
        self.url = reader.tgread_string()
        self.thumb_url = reader.tgread_string()
        self.content_url = reader.tgread_string()
        self.content_type = reader.tgread_string()
        self.w = reader.read_int()
        self.h = reader.read_int()

    def __repr__(self):
        return 'foundGif#162ecc1f url:string thumb_url:string content_url:string content_type:string w:int h:int = FoundGif'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FoundGifCached(TLObject):
    constructor_id = 0x9c750409
    subclass_of_id = 0x5bbc92c3

    def __init__(self, url, photo, document):
        """
        :param url: Telegram type: "string".
        :param photo: Telegram type: "Photo".
        :param document: Telegram type: "Document".

        Constructor for FoundGif: Instance of either FoundGif, FoundGifCached.
        """
        super().__init__()

        self.url = url
        self.photo = photo
        self.document = document

    def to_dict(self):
        return {
            'url': self.url,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(FoundGifCached.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        self.photo.on_send(writer)
        self.document.on_send(writer)

    @staticmethod
    def empty():
        return FoundGifCached(None, None, None)

    def on_response(self, reader):
        self.url = reader.tgread_string()
        self.photo = reader.tgread_object()
        self.document = reader.tgread_object()

    def __repr__(self):
        return 'foundGifCached#9c750409 url:string photo:Photo document:Document = FoundGif'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FutureSalt(TLObject):
    constructor_id = 0x949d9dc
    subclass_of_id = 0x45e53dcf

    def __init__(self, valid_since, valid_until, salt):
        """
        :param valid_since: Telegram type: "int".
        :param valid_until: Telegram type: "int".
        :param salt: Telegram type: "long".

        Constructor for FutureSalt: Instance of FutureSalt.
        """
        super().__init__()

        self.valid_since = valid_since
        self.valid_until = valid_until
        self.salt = salt

    def to_dict(self):
        return {
            'valid_since': self.valid_since,
            'valid_until': self.valid_until,
            'salt': self.salt,
        }

    def on_send(self, writer):
        writer.write_int(FutureSalt.constructor_id, signed=False)
        writer.write_int(self.valid_since)
        writer.write_int(self.valid_until)
        writer.write_long(self.salt)

    @staticmethod
    def empty():
        return FutureSalt(None, None, None)

    def on_response(self, reader):
        self.valid_since = reader.read_int()
        self.valid_until = reader.read_int()
        self.salt = reader.read_long()

    def __repr__(self):
        return 'future_salt#0949d9dc valid_since:int valid_until:int salt:long = FutureSalt'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class FutureSalts(TLObject):
    constructor_id = 0xae500895
    subclass_of_id = 0x1090f517

    def __init__(self, req_msg_id, now, salts):
        """
        :param req_msg_id: Telegram type: "long".
        :param now: Telegram type: "int".
        :param salts: Telegram type: "future_salt". Must be a list.

        Constructor for FutureSalts: Instance of FutureSalts.
        """
        super().__init__()

        self.req_msg_id = req_msg_id
        self.now = now
        self.salts = salts

    def to_dict(self):
        return {
            'req_msg_id': self.req_msg_id,
            'now': self.now,
            'salts': [] if self.salts is None else [None if x is None else x.to_dict() for x in self.salts],
        }

    def on_send(self, writer):
        writer.write_int(FutureSalts.constructor_id, signed=False)
        writer.write_long(self.req_msg_id)
        writer.write_int(self.now)
        writer.write_int(len(self.salts))
        for _x in self.salts:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return FutureSalts(None, None, None)

    def on_response(self, reader):
        self.req_msg_id = reader.read_long()
        self.now = reader.read_int()
        self.salts = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.salts.append(_x)

    def __repr__(self):
        return 'future_salts#ae500895 req_msg_id:long now:int salts:vector<future_salt> = FutureSalts'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Game(TLObject):
    constructor_id = 0xbdf9653b
    subclass_of_id = 0x83199eb2

    def __init__(self, id, access_hash, short_name, title, description, photo, document=None):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param short_name: Telegram type: "string".
        :param title: Telegram type: "string".
        :param description: Telegram type: "string".
        :param photo: Telegram type: "Photo".
        :param document: Telegram type: "Document".

        Constructor for Game: Instance of Game.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.short_name = short_name
        self.title = title
        self.description = description
        self.photo = photo
        self.document = document

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'short_name': self.short_name,
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(Game.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.document else 0
        writer.write_int(flags)

        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_string(self.short_name)
        writer.tgwrite_string(self.title)
        writer.tgwrite_string(self.description)
        self.photo.on_send(writer)
        if self.document:
            self.document.on_send(writer)

    @staticmethod
    def empty():
        return Game(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.short_name = reader.tgread_string()
        self.title = reader.tgread_string()
        self.description = reader.tgread_string()
        self.photo = reader.tgread_object()
        if (flags & (1 << 0)) != 0:
            self.document = reader.tgread_object()

    def __repr__(self):
        return 'game#bdf9653b flags:# id:long access_hash:long short_name:string title:string description:string photo:Photo document:flags.0?Document = Game'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GeoPoint(TLObject):
    constructor_id = 0x2049d70c
    subclass_of_id = 0xd610e16d

    def __init__(self, long, lat):
        """
        :param long: Telegram type: "double".
        :param lat: Telegram type: "double".

        Constructor for GeoPoint: Instance of either GeoPointEmpty, GeoPoint.
        """
        super().__init__()

        self.long = long
        self.lat = lat

    def to_dict(self):
        return {
            'long': self.long,
            'lat': self.lat,
        }

    def on_send(self, writer):
        writer.write_int(GeoPoint.constructor_id, signed=False)
        writer.write_double(self.long)
        writer.write_double(self.lat)

    @staticmethod
    def empty():
        return GeoPoint(None, None)

    def on_response(self, reader):
        self.long = reader.read_double()
        self.lat = reader.read_double()

    def __repr__(self):
        return 'geoPoint#2049d70c long:double lat:double = GeoPoint'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class GeoPointEmpty(TLObject):
    constructor_id = 0x1117dd5f
    subclass_of_id = 0xd610e16d

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(GeoPointEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return GeoPointEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'geoPointEmpty#1117dd5f = GeoPoint'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class HighScore(TLObject):
    constructor_id = 0x58fffcd0
    subclass_of_id = 0xd32b1e35

    def __init__(self, pos, user_id, score):
        """
        :param pos: Telegram type: "int".
        :param user_id: Telegram type: "int".
        :param score: Telegram type: "int".

        Constructor for HighScore: Instance of HighScore.
        """
        super().__init__()

        self.pos = pos
        self.user_id = user_id
        self.score = score

    def to_dict(self):
        return {
            'pos': self.pos,
            'user_id': self.user_id,
            'score': self.score,
        }

    def on_send(self, writer):
        writer.write_int(HighScore.constructor_id, signed=False)
        writer.write_int(self.pos)
        writer.write_int(self.user_id)
        writer.write_int(self.score)

    @staticmethod
    def empty():
        return HighScore(None, None, None)

    def on_response(self, reader):
        self.pos = reader.read_int()
        self.user_id = reader.read_int()
        self.score = reader.read_int()

    def __repr__(self):
        return 'highScore#58fffcd0 pos:int user_id:int score:int = HighScore'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class HttpWait(TLObject):
    constructor_id = 0x9299359f
    subclass_of_id = 0x1284aed6

    def __init__(self, max_delay, wait_after, max_wait):
        """
        :param max_delay: Telegram type: "int".
        :param wait_after: Telegram type: "int".
        :param max_wait: Telegram type: "int".

        Constructor for HttpWait: Instance of HttpWait.
        """
        super().__init__()

        self.max_delay = max_delay
        self.wait_after = wait_after
        self.max_wait = max_wait

    def to_dict(self):
        return {
            'max_delay': self.max_delay,
            'wait_after': self.wait_after,
            'max_wait': self.max_wait,
        }

    def on_send(self, writer):
        writer.write_int(HttpWait.constructor_id, signed=False)
        writer.write_int(self.max_delay)
        writer.write_int(self.wait_after)
        writer.write_int(self.max_wait)

    @staticmethod
    def empty():
        return HttpWait(None, None, None)

    def on_response(self, reader):
        self.max_delay = reader.read_int()
        self.wait_after = reader.read_int()
        self.max_wait = reader.read_int()

    def __repr__(self):
        return 'http_wait#9299359f max_delay:int wait_after:int max_wait:int = HttpWait'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ImportedContact(TLObject):
    constructor_id = 0xd0028438
    subclass_of_id = 0xb545bbda

    def __init__(self, user_id, client_id):
        """
        :param user_id: Telegram type: "int".
        :param client_id: Telegram type: "long".

        Constructor for ImportedContact: Instance of ImportedContact.
        """
        super().__init__()

        self.user_id = user_id
        self.client_id = client_id

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'client_id': self.client_id,
        }

    def on_send(self, writer):
        writer.write_int(ImportedContact.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.write_long(self.client_id)

    @staticmethod
    def empty():
        return ImportedContact(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.client_id = reader.read_long()

    def __repr__(self):
        return 'importedContact#d0028438 user_id:int client_id:long = ImportedContact'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InlineBotSwitchPM(TLObject):
    constructor_id = 0x3c20629f
    subclass_of_id = 0x82b1f73b

    def __init__(self, text, start_param):
        """
        :param text: Telegram type: "string".
        :param start_param: Telegram type: "string".

        Constructor for InlineBotSwitchPM: Instance of InlineBotSwitchPM.
        """
        super().__init__()

        self.text = text
        self.start_param = start_param

    def to_dict(self):
        return {
            'text': self.text,
            'start_param': self.start_param,
        }

    def on_send(self, writer):
        writer.write_int(InlineBotSwitchPM.constructor_id, signed=False)
        writer.tgwrite_string(self.text)
        writer.tgwrite_string(self.start_param)

    @staticmethod
    def empty():
        return InlineBotSwitchPM(None, None)

    def on_response(self, reader):
        self.text = reader.tgread_string()
        self.start_param = reader.tgread_string()

    def __repr__(self):
        return 'inlineBotSwitchPM#3c20629f text:string start_param:string = InlineBotSwitchPM'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputAppEvent(TLObject):
    constructor_id = 0x770656a8
    subclass_of_id = 0x89322106

    def __init__(self, time, type, peer, data):
        """
        :param time: Telegram type: "double".
        :param type: Telegram type: "string".
        :param peer: Telegram type: "long".
        :param data: Telegram type: "string".

        Constructor for InputAppEvent: Instance of InputAppEvent.
        """
        super().__init__()

        self.time = time
        self.type = type
        self.peer = peer
        self.data = data

    def to_dict(self):
        return {
            'time': self.time,
            'type': self.type,
            'peer': self.peer,
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(InputAppEvent.constructor_id, signed=False)
        writer.write_double(self.time)
        writer.tgwrite_string(self.type)
        writer.write_long(self.peer)
        writer.tgwrite_string(self.data)

    @staticmethod
    def empty():
        return InputAppEvent(None, None, None, None)

    def on_response(self, reader):
        self.time = reader.read_double()
        self.type = reader.tgread_string()
        self.peer = reader.read_long()
        self.data = reader.tgread_string()

    def __repr__(self):
        return 'inputAppEvent#770656a8 time:double type:string peer:long data:string = InputAppEvent'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineMessageGame(TLObject):
    constructor_id = 0x4b425864
    subclass_of_id = 0x53fb4010

    def __init__(self, reply_markup=None):
        """
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineMessageGame.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineMessageGame(None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineMessageGame#4b425864 flags:# reply_markup:flags.2?ReplyMarkup = InputBotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineMessageID(TLObject):
    constructor_id = 0x890c3d89
    subclass_of_id = 0x2dcd6300

    def __init__(self, dc_id, id, access_hash):
        """
        :param dc_id: Telegram type: "int".
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".

        Constructor for InputBotInlineMessageID: Instance of InputBotInlineMessageID.
        """
        super().__init__()

        self.dc_id = dc_id
        self.id = id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'dc_id': self.dc_id,
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineMessageID.constructor_id, signed=False)
        writer.write_int(self.dc_id)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputBotInlineMessageID(None, None, None)

    def on_response(self, reader):
        self.dc_id = reader.read_int()
        self.id = reader.read_long()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputBotInlineMessageID#890c3d89 dc_id:int id:long access_hash:long = InputBotInlineMessageID'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineMessageMediaAuto(TLObject):
    constructor_id = 0x292fed13
    subclass_of_id = 0x53fb4010

    def __init__(self, caption, reply_markup=None):
        """
        :param caption: Telegram type: "string".
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.caption = caption
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'caption': self.caption,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineMessageMediaAuto.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.caption)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineMessageMediaAuto(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.caption = reader.tgread_string()
        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineMessageMediaAuto#292fed13 flags:# caption:string reply_markup:flags.2?ReplyMarkup = InputBotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineMessageMediaContact(TLObject):
    constructor_id = 0x2daf01a7
    subclass_of_id = 0x53fb4010

    def __init__(self, phone_number, first_name, last_name, reply_markup=None):
        """
        :param phone_number: Telegram type: "string".
        :param first_name: Telegram type: "string".
        :param last_name: Telegram type: "string".
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineMessageMediaContact.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.phone_number)
        writer.tgwrite_string(self.first_name)
        writer.tgwrite_string(self.last_name)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineMessageMediaContact(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.phone_number = reader.tgread_string()
        self.first_name = reader.tgread_string()
        self.last_name = reader.tgread_string()
        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineMessageMediaContact#2daf01a7 flags:# phone_number:string first_name:string last_name:string reply_markup:flags.2?ReplyMarkup = InputBotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineMessageMediaGeo(TLObject):
    constructor_id = 0xf4a59de1
    subclass_of_id = 0x53fb4010

    def __init__(self, geo_point, reply_markup=None):
        """
        :param geo_point: Telegram type: "InputGeoPoint".
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.geo_point = geo_point
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineMessageMediaGeo.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        self.geo_point.on_send(writer)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineMessageMediaGeo(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.geo_point = reader.tgread_object()
        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineMessageMediaGeo#f4a59de1 flags:# geo_point:InputGeoPoint reply_markup:flags.2?ReplyMarkup = InputBotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineMessageMediaVenue(TLObject):
    constructor_id = 0xaaafadc8
    subclass_of_id = 0x53fb4010

    def __init__(self, geo_point, title, address, provider, venue_id, reply_markup=None):
        """
        :param geo_point: Telegram type: "InputGeoPoint".
        :param title: Telegram type: "string".
        :param address: Telegram type: "string".
        :param provider: Telegram type: "string".
        :param venue_id: Telegram type: "string".
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.geo_point = geo_point
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineMessageMediaVenue.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        self.geo_point.on_send(writer)
        writer.tgwrite_string(self.title)
        writer.tgwrite_string(self.address)
        writer.tgwrite_string(self.provider)
        writer.tgwrite_string(self.venue_id)
        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineMessageMediaVenue(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.geo_point = reader.tgread_object()
        self.title = reader.tgread_string()
        self.address = reader.tgread_string()
        self.provider = reader.tgread_string()
        self.venue_id = reader.tgread_string()
        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineMessageMediaVenue#aaafadc8 flags:# geo_point:InputGeoPoint title:string address:string provider:string venue_id:string reply_markup:flags.2?ReplyMarkup = InputBotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineMessageText(TLObject):
    constructor_id = 0x3dcd7a87
    subclass_of_id = 0x53fb4010

    def __init__(self, message, no_webpage=None, entities=None, reply_markup=None):
        """
        :param no_webpage: Telegram type: "true".
        :param message: Telegram type: "string".
        :param entities: Telegram type: "MessageEntity". Must be a list.
        :param reply_markup: Telegram type: "ReplyMarkup".

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.no_webpage = no_webpage
        self.message = message
        self.entities = entities
        self.reply_markup = reply_markup

    def to_dict(self):
        return {
            'no_webpage': self.no_webpage,
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineMessageText.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.no_webpage else 0
        flags |= (1 << 1) if self.entities else 0
        flags |= (1 << 2) if self.reply_markup else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.message)
        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

        if self.reply_markup:
            self.reply_markup.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineMessageText(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.no_webpage = True

        self.message = reader.tgread_string()
        if (flags & (1 << 1)) != 0:
            reader.read_int()
            self.entities = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.entities.append(_x)

        if (flags & (1 << 2)) != 0:
            self.reply_markup = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineMessageText#3dcd7a87 flags:# no_webpage:flags.0?true message:string entities:flags.1?Vector<MessageEntity> reply_markup:flags.2?ReplyMarkup = InputBotInlineMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineResult(TLObject):
    constructor_id = 0x2cbbe15a
    subclass_of_id = 0x80a4a3de

    def __init__(self, id, type, send_message, title=None, description=None, url=None, thumb_url=None, content_url=None, content_type=None, w=None, h=None, duration=None):
        """
        :param id: Telegram type: "string".
        :param type: Telegram type: "string".
        :param title: Telegram type: "string".
        :param description: Telegram type: "string".
        :param url: Telegram type: "string".
        :param thumb_url: Telegram type: "string".
        :param content_url: Telegram type: "string".
        :param content_type: Telegram type: "string".
        :param w: Telegram type: "int".
        :param h: Telegram type: "int".
        :param duration: Telegram type: "int".
        :param send_message: Telegram type: "InputBotInlineMessage".

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.url = url
        self.thumb_url = thumb_url
        self.content_url = content_url
        self.content_type = content_type
        self.w = w
        self.h = h
        self.duration = duration
        self.send_message = send_message

    def to_dict(self):
        return {
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h,
            'duration': self.duration,
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineResult.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.title else 0
        flags |= (1 << 2) if self.description else 0
        flags |= (1 << 3) if self.url else 0
        flags |= (1 << 4) if self.thumb_url else 0
        flags |= (1 << 5) if self.content_url else 0
        flags |= (1 << 5) if self.content_type else 0
        flags |= (1 << 6) if self.w else 0
        flags |= (1 << 6) if self.h else 0
        flags |= (1 << 7) if self.duration else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.type)
        if self.title:
            writer.tgwrite_string(self.title)

        if self.description:
            writer.tgwrite_string(self.description)

        if self.url:
            writer.tgwrite_string(self.url)

        if self.thumb_url:
            writer.tgwrite_string(self.thumb_url)

        if self.content_url:
            writer.tgwrite_string(self.content_url)

        if self.content_type:
            writer.tgwrite_string(self.content_type)

        if self.w:
            writer.write_int(self.w)

        if self.h:
            writer.write_int(self.h)

        if self.duration:
            writer.write_int(self.duration)

        self.send_message.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineResult(None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.tgread_string()
        self.type = reader.tgread_string()
        if (flags & (1 << 1)) != 0:
            self.title = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.description = reader.tgread_string()

        if (flags & (1 << 3)) != 0:
            self.url = reader.tgread_string()

        if (flags & (1 << 4)) != 0:
            self.thumb_url = reader.tgread_string()

        if (flags & (1 << 5)) != 0:
            self.content_url = reader.tgread_string()

        if (flags & (1 << 5)) != 0:
            self.content_type = reader.tgread_string()

        if (flags & (1 << 6)) != 0:
            self.w = reader.read_int()

        if (flags & (1 << 6)) != 0:
            self.h = reader.read_int()

        if (flags & (1 << 7)) != 0:
            self.duration = reader.read_int()

        self.send_message = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineResult#2cbbe15a flags:# id:string type:string title:flags.1?string description:flags.2?string url:flags.3?string thumb_url:flags.4?string content_url:flags.5?string content_type:flags.5?string w:flags.6?int h:flags.6?int duration:flags.7?int send_message:InputBotInlineMessage = InputBotInlineResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineResultDocument(TLObject):
    constructor_id = 0xfff8fdc4
    subclass_of_id = 0x80a4a3de

    def __init__(self, id, type, document, send_message, title=None, description=None):
        """
        :param id: Telegram type: "string".
        :param type: Telegram type: "string".
        :param title: Telegram type: "string".
        :param description: Telegram type: "string".
        :param document: Telegram type: "InputDocument".
        :param send_message: Telegram type: "InputBotInlineMessage".

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.document = document
        self.send_message = send_message

    def to_dict(self):
        return {
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'document': None if self.document is None else self.document.to_dict(),
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineResultDocument.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.title else 0
        flags |= (1 << 2) if self.description else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.type)
        if self.title:
            writer.tgwrite_string(self.title)

        if self.description:
            writer.tgwrite_string(self.description)

        self.document.on_send(writer)
        self.send_message.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineResultDocument(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.tgread_string()
        self.type = reader.tgread_string()
        if (flags & (1 << 1)) != 0:
            self.title = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.description = reader.tgread_string()

        self.document = reader.tgread_object()
        self.send_message = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineResultDocument#fff8fdc4 flags:# id:string type:string title:flags.1?string description:flags.2?string document:InputDocument send_message:InputBotInlineMessage = InputBotInlineResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineResultGame(TLObject):
    constructor_id = 0x4fa417f2
    subclass_of_id = 0x80a4a3de

    def __init__(self, id, short_name, send_message):
        """
        :param id: Telegram type: "string".
        :param short_name: Telegram type: "string".
        :param send_message: Telegram type: "InputBotInlineMessage".

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id
        self.short_name = short_name
        self.send_message = send_message

    def to_dict(self):
        return {
            'id': self.id,
            'short_name': self.short_name,
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineResultGame.constructor_id, signed=False)
        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.short_name)
        self.send_message.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineResultGame(None, None, None)

    def on_response(self, reader):
        self.id = reader.tgread_string()
        self.short_name = reader.tgread_string()
        self.send_message = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineResultGame#4fa417f2 id:string short_name:string send_message:InputBotInlineMessage = InputBotInlineResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputBotInlineResultPhoto(TLObject):
    constructor_id = 0xa8d864a7
    subclass_of_id = 0x80a4a3de

    def __init__(self, id, type, photo, send_message):
        """
        :param id: Telegram type: "string".
        :param type: Telegram type: "string".
        :param photo: Telegram type: "InputPhoto".
        :param send_message: Telegram type: "InputBotInlineMessage".

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.photo = photo
        self.send_message = send_message

    def to_dict(self):
        return {
            'id': self.id,
            'type': self.type,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputBotInlineResultPhoto.constructor_id, signed=False)
        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.type)
        self.photo.on_send(writer)
        self.send_message.on_send(writer)

    @staticmethod
    def empty():
        return InputBotInlineResultPhoto(None, None, None, None)

    def on_response(self, reader):
        self.id = reader.tgread_string()
        self.type = reader.tgread_string()
        self.photo = reader.tgread_object()
        self.send_message = reader.tgread_object()

    def __repr__(self):
        return 'inputBotInlineResultPhoto#a8d864a7 id:string type:string photo:InputPhoto send_message:InputBotInlineMessage = InputBotInlineResult'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputChannel(TLObject):
    constructor_id = 0xafeb712e
    subclass_of_id = 0x40f202fd

    def __init__(self, channel_id, access_hash):
        """
        :param channel_id: Telegram type: "int".
        :param access_hash: Telegram type: "long".

        Constructor for InputChannel: Instance of either InputChannelEmpty, InputChannel.
        """
        super().__init__()

        self.channel_id = channel_id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputChannel.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputChannel(None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputChannel#afeb712e channel_id:int access_hash:long = InputChannel'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputChannelEmpty(TLObject):
    constructor_id = 0xee8c1e86
    subclass_of_id = 0x40f202fd

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputChannelEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputChannelEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputChannelEmpty#ee8c1e86 = InputChannel'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputChatPhoto(TLObject):
    constructor_id = 0x8953ad37
    subclass_of_id = 0xd4eb2d74

    def __init__(self, id):
        """
        :param id: Telegram type: "InputPhoto".

        Constructor for InputChatPhoto: Instance of either InputChatPhotoEmpty, InputChatUploadedPhoto, InputChatPhoto.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputChatPhoto.constructor_id, signed=False)
        self.id.on_send(writer)

    @staticmethod
    def empty():
        return InputChatPhoto(None)

    def on_response(self, reader):
        self.id = reader.tgread_object()

    def __repr__(self):
        return 'inputChatPhoto#8953ad37 id:InputPhoto = InputChatPhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputChatPhotoEmpty(TLObject):
    constructor_id = 0x1ca48f57
    subclass_of_id = 0xd4eb2d74

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputChatPhotoEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputChatPhotoEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputChatPhotoEmpty#1ca48f57 = InputChatPhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputChatUploadedPhoto(TLObject):
    constructor_id = 0x927c55b4
    subclass_of_id = 0xd4eb2d74

    def __init__(self, file):
        """
        :param file: Telegram type: "InputFile".

        Constructor for InputChatPhoto: Instance of either InputChatPhotoEmpty, InputChatUploadedPhoto, InputChatPhoto.
        """
        super().__init__()

        self.file = file

    def to_dict(self):
        return {
            'file': None if self.file is None else self.file.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputChatUploadedPhoto.constructor_id, signed=False)
        self.file.on_send(writer)

    @staticmethod
    def empty():
        return InputChatUploadedPhoto(None)

    def on_response(self, reader):
        self.file = reader.tgread_object()

    def __repr__(self):
        return 'inputChatUploadedPhoto#927c55b4 file:InputFile = InputChatPhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputDocument(TLObject):
    constructor_id = 0x18798952
    subclass_of_id = 0xf33fdb68

    def __init__(self, id, access_hash):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".

        Constructor for InputDocument: Instance of either InputDocumentEmpty, InputDocument.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputDocument.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputDocument(None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputDocument#18798952 id:long access_hash:long = InputDocument'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputDocumentEmpty(TLObject):
    constructor_id = 0x72f0eaae
    subclass_of_id = 0xf33fdb68

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputDocumentEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputDocumentEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputDocumentEmpty#72f0eaae = InputDocument'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputDocumentFileLocation(TLObject):
    constructor_id = 0x430f0724
    subclass_of_id = 0x1523d462

    def __init__(self, id, access_hash, version):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param version: Telegram type: "int".

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.version = version

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'version': self.version,
        }

    def on_send(self, writer):
        writer.write_int(InputDocumentFileLocation.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.write_int(self.version)

    @staticmethod
    def empty():
        return InputDocumentFileLocation(None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.version = reader.read_int()

    def __repr__(self):
        return 'inputDocumentFileLocation#430f0724 id:long access_hash:long version:int = InputFileLocation'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputEncryptedChat(TLObject):
    constructor_id = 0xf141b5e1
    subclass_of_id = 0x6c7606c0

    def __init__(self, chat_id, access_hash):
        """
        :param chat_id: Telegram type: "int".
        :param access_hash: Telegram type: "long".

        Constructor for InputEncryptedChat: Instance of InputEncryptedChat.
        """
        super().__init__()

        self.chat_id = chat_id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputEncryptedChat.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputEncryptedChat(None, None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputEncryptedChat#f141b5e1 chat_id:int access_hash:long = InputEncryptedChat'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputEncryptedFile(TLObject):
    constructor_id = 0x5a17b5e5
    subclass_of_id = 0x8574c27a

    def __init__(self, id, access_hash):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputEncryptedFile.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputEncryptedFile(None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputEncryptedFile#5a17b5e5 id:long access_hash:long = InputEncryptedFile'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputEncryptedFileBigUploaded(TLObject):
    constructor_id = 0x2dc173c8
    subclass_of_id = 0x8574c27a

    def __init__(self, id, parts, key_fingerprint):
        """
        :param id: Telegram type: "long".
        :param parts: Telegram type: "int".
        :param key_fingerprint: Telegram type: "int".

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id
        self.parts = parts
        self.key_fingerprint = key_fingerprint

    def to_dict(self):
        return {
            'id': self.id,
            'parts': self.parts,
            'key_fingerprint': self.key_fingerprint,
        }

    def on_send(self, writer):
        writer.write_int(InputEncryptedFileBigUploaded.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_int(self.parts)
        writer.write_int(self.key_fingerprint)

    @staticmethod
    def empty():
        return InputEncryptedFileBigUploaded(None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.parts = reader.read_int()
        self.key_fingerprint = reader.read_int()

    def __repr__(self):
        return 'inputEncryptedFileBigUploaded#2dc173c8 id:long parts:int key_fingerprint:int = InputEncryptedFile'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputEncryptedFileEmpty(TLObject):
    constructor_id = 0x1837c364
    subclass_of_id = 0x8574c27a

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputEncryptedFileEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputEncryptedFileEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputEncryptedFileEmpty#1837c364 = InputEncryptedFile'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputEncryptedFileLocation(TLObject):
    constructor_id = 0xf5235d55
    subclass_of_id = 0x1523d462

    def __init__(self, id, access_hash):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputEncryptedFileLocation.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputEncryptedFileLocation(None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputEncryptedFileLocation#f5235d55 id:long access_hash:long = InputFileLocation'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputEncryptedFileUploaded(TLObject):
    constructor_id = 0x64bd0306
    subclass_of_id = 0x8574c27a

    def __init__(self, id, parts, md5_checksum, key_fingerprint):
        """
        :param id: Telegram type: "long".
        :param parts: Telegram type: "int".
        :param md5_checksum: Telegram type: "string".
        :param key_fingerprint: Telegram type: "int".

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id
        self.parts = parts
        self.md5_checksum = md5_checksum
        self.key_fingerprint = key_fingerprint

    def to_dict(self):
        return {
            'id': self.id,
            'parts': self.parts,
            'md5_checksum': self.md5_checksum,
            'key_fingerprint': self.key_fingerprint,
        }

    def on_send(self, writer):
        writer.write_int(InputEncryptedFileUploaded.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_int(self.parts)
        writer.tgwrite_string(self.md5_checksum)
        writer.write_int(self.key_fingerprint)

    @staticmethod
    def empty():
        return InputEncryptedFileUploaded(None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.parts = reader.read_int()
        self.md5_checksum = reader.tgread_string()
        self.key_fingerprint = reader.read_int()

    def __repr__(self):
        return 'inputEncryptedFileUploaded#64bd0306 id:long parts:int md5_checksum:string key_fingerprint:int = InputEncryptedFile'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputFile(TLObject):
    constructor_id = 0xf52ff27f
    subclass_of_id = 0xe7655f1f

    def __init__(self, id, parts, name, md5_checksum):
        """
        :param id: Telegram type: "long".
        :param parts: Telegram type: "int".
        :param name: Telegram type: "string".
        :param md5_checksum: Telegram type: "string".

        Constructor for InputFile: Instance of either InputFile, InputFileBig.
        """
        super().__init__()

        self.id = id
        self.parts = parts
        self.name = name
        self.md5_checksum = md5_checksum

    def to_dict(self):
        return {
            'id': self.id,
            'parts': self.parts,
            'name': self.name,
            'md5_checksum': self.md5_checksum,
        }

    def on_send(self, writer):
        writer.write_int(InputFile.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_int(self.parts)
        writer.tgwrite_string(self.name)
        writer.tgwrite_string(self.md5_checksum)

    @staticmethod
    def empty():
        return InputFile(None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.parts = reader.read_int()
        self.name = reader.tgread_string()
        self.md5_checksum = reader.tgread_string()

    def __repr__(self):
        return 'inputFile#f52ff27f id:long parts:int name:string md5_checksum:string = InputFile'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputFileBig(TLObject):
    constructor_id = 0xfa4f0bb5
    subclass_of_id = 0xe7655f1f

    def __init__(self, id, parts, name):
        """
        :param id: Telegram type: "long".
        :param parts: Telegram type: "int".
        :param name: Telegram type: "string".

        Constructor for InputFile: Instance of either InputFile, InputFileBig.
        """
        super().__init__()

        self.id = id
        self.parts = parts
        self.name = name

    def to_dict(self):
        return {
            'id': self.id,
            'parts': self.parts,
            'name': self.name,
        }

    def on_send(self, writer):
        writer.write_int(InputFileBig.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_int(self.parts)
        writer.tgwrite_string(self.name)

    @staticmethod
    def empty():
        return InputFileBig(None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.parts = reader.read_int()
        self.name = reader.tgread_string()

    def __repr__(self):
        return 'inputFileBig#fa4f0bb5 id:long parts:int name:string = InputFile'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputFileLocation(TLObject):
    constructor_id = 0x14637196
    subclass_of_id = 0x1523d462

    def __init__(self, volume_id, local_id, secret):
        """
        :param volume_id: Telegram type: "long".
        :param local_id: Telegram type: "int".
        :param secret: Telegram type: "long".

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.volume_id = volume_id
        self.local_id = local_id
        self.secret = secret

    def to_dict(self):
        return {
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret,
        }

    def on_send(self, writer):
        writer.write_int(InputFileLocation.constructor_id, signed=False)
        writer.write_long(self.volume_id)
        writer.write_int(self.local_id)
        writer.write_long(self.secret)

    @staticmethod
    def empty():
        return InputFileLocation(None, None, None)

    def on_response(self, reader):
        self.volume_id = reader.read_long()
        self.local_id = reader.read_int()
        self.secret = reader.read_long()

    def __repr__(self):
        return 'inputFileLocation#14637196 volume_id:long local_id:int secret:long = InputFileLocation'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputGameID(TLObject):
    constructor_id = 0x32c3e77
    subclass_of_id = 0x48d15883

    def __init__(self, id, access_hash):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".

        Constructor for InputGame: Instance of either InputGameID, InputGameShortName.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputGameID.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputGameID(None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputGameID#032c3e77 id:long access_hash:long = InputGame'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputGameShortName(TLObject):
    constructor_id = 0xc331e80a
    subclass_of_id = 0x48d15883

    def __init__(self, bot_id, short_name):
        """
        :param bot_id: Telegram type: "InputUser".
        :param short_name: Telegram type: "string".

        Constructor for InputGame: Instance of either InputGameID, InputGameShortName.
        """
        super().__init__()

        self.bot_id = bot_id
        self.short_name = short_name

    def to_dict(self):
        return {
            'bot_id': None if self.bot_id is None else self.bot_id.to_dict(),
            'short_name': self.short_name,
        }

    def on_send(self, writer):
        writer.write_int(InputGameShortName.constructor_id, signed=False)
        self.bot_id.on_send(writer)
        writer.tgwrite_string(self.short_name)

    @staticmethod
    def empty():
        return InputGameShortName(None, None)

    def on_response(self, reader):
        self.bot_id = reader.tgread_object()
        self.short_name = reader.tgread_string()

    def __repr__(self):
        return 'inputGameShortName#c331e80a bot_id:InputUser short_name:string = InputGame'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputGeoPoint(TLObject):
    constructor_id = 0xf3b7acc9
    subclass_of_id = 0x430d225

    def __init__(self, lat, long):
        """
        :param lat: Telegram type: "double".
        :param long: Telegram type: "double".

        Constructor for InputGeoPoint: Instance of either InputGeoPointEmpty, InputGeoPoint.
        """
        super().__init__()

        self.lat = lat
        self.long = long

    def to_dict(self):
        return {
            'lat': self.lat,
            'long': self.long,
        }

    def on_send(self, writer):
        writer.write_int(InputGeoPoint.constructor_id, signed=False)
        writer.write_double(self.lat)
        writer.write_double(self.long)

    @staticmethod
    def empty():
        return InputGeoPoint(None, None)

    def on_response(self, reader):
        self.lat = reader.read_double()
        self.long = reader.read_double()

    def __repr__(self):
        return 'inputGeoPoint#f3b7acc9 lat:double long:double = InputGeoPoint'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputGeoPointEmpty(TLObject):
    constructor_id = 0xe4c123d6
    subclass_of_id = 0x430d225

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputGeoPointEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputGeoPointEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputGeoPointEmpty#e4c123d6 = InputGeoPoint'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaContact(TLObject):
    constructor_id = 0xa6e45987
    subclass_of_id = 0xfaf846f4

    def __init__(self, phone_number, first_name, last_name):
        """
        :param phone_number: Telegram type: "string".
        :param first_name: Telegram type: "string".
        :param last_name: Telegram type: "string".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name

    def to_dict(self):
        return {
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaContact.constructor_id, signed=False)
        writer.tgwrite_string(self.phone_number)
        writer.tgwrite_string(self.first_name)
        writer.tgwrite_string(self.last_name)

    @staticmethod
    def empty():
        return InputMediaContact(None, None, None)

    def on_response(self, reader):
        self.phone_number = reader.tgread_string()
        self.first_name = reader.tgread_string()
        self.last_name = reader.tgread_string()

    def __repr__(self):
        return 'inputMediaContact#a6e45987 phone_number:string first_name:string last_name:string = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaDocument(TLObject):
    constructor_id = 0x5acb668e
    subclass_of_id = 0xfaf846f4

    def __init__(self, id, caption, ttl_seconds=None):
        """
        :param id: Telegram type: "InputDocument".
        :param caption: Telegram type: "string".
        :param ttl_seconds: Telegram type: "int".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.id = id
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaDocument.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.ttl_seconds else 0
        writer.write_int(flags)

        self.id.on_send(writer)
        writer.tgwrite_string(self.caption)
        if self.ttl_seconds:
            writer.write_int(self.ttl_seconds)

    @staticmethod
    def empty():
        return InputMediaDocument(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.tgread_object()
        self.caption = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.ttl_seconds = reader.read_int()

    def __repr__(self):
        return 'inputMediaDocument#5acb668e flags:# id:InputDocument caption:string ttl_seconds:flags.0?int = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaDocumentExternal(TLObject):
    constructor_id = 0xb6f74335
    subclass_of_id = 0xfaf846f4

    def __init__(self, url, caption, ttl_seconds=None):
        """
        :param url: Telegram type: "string".
        :param caption: Telegram type: "string".
        :param ttl_seconds: Telegram type: "int".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.url = url
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self):
        return {
            'url': self.url,
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaDocumentExternal.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.ttl_seconds else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.url)
        writer.tgwrite_string(self.caption)
        if self.ttl_seconds:
            writer.write_int(self.ttl_seconds)

    @staticmethod
    def empty():
        return InputMediaDocumentExternal(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.url = reader.tgread_string()
        self.caption = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.ttl_seconds = reader.read_int()

    def __repr__(self):
        return 'inputMediaDocumentExternal#b6f74335 flags:# url:string caption:string ttl_seconds:flags.0?int = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaEmpty(TLObject):
    constructor_id = 0x9664f57f
    subclass_of_id = 0xfaf846f4

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMediaEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMediaEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMediaEmpty#9664f57f = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaGame(TLObject):
    constructor_id = 0xd33f43f3
    subclass_of_id = 0xfaf846f4

    def __init__(self, id):
        """
        :param id: Telegram type: "InputGame".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputMediaGame.constructor_id, signed=False)
        self.id.on_send(writer)

    @staticmethod
    def empty():
        return InputMediaGame(None)

    def on_response(self, reader):
        self.id = reader.tgread_object()

    def __repr__(self):
        return 'inputMediaGame#d33f43f3 id:InputGame = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaGeoPoint(TLObject):
    constructor_id = 0xf9c44144
    subclass_of_id = 0xfaf846f4

    def __init__(self, geo_point):
        """
        :param geo_point: Telegram type: "InputGeoPoint".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.geo_point = geo_point

    def to_dict(self):
        return {
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputMediaGeoPoint.constructor_id, signed=False)
        self.geo_point.on_send(writer)

    @staticmethod
    def empty():
        return InputMediaGeoPoint(None)

    def on_response(self, reader):
        self.geo_point = reader.tgread_object()

    def __repr__(self):
        return 'inputMediaGeoPoint#f9c44144 geo_point:InputGeoPoint = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaGifExternal(TLObject):
    constructor_id = 0x4843b0fd
    subclass_of_id = 0xfaf846f4

    def __init__(self, url, q):
        """
        :param url: Telegram type: "string".
        :param q: Telegram type: "string".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.url = url
        self.q = q

    def to_dict(self):
        return {
            'url': self.url,
            'q': self.q,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaGifExternal.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        writer.tgwrite_string(self.q)

    @staticmethod
    def empty():
        return InputMediaGifExternal(None, None)

    def on_response(self, reader):
        self.url = reader.tgread_string()
        self.q = reader.tgread_string()

    def __repr__(self):
        return 'inputMediaGifExternal#4843b0fd url:string q:string = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaInvoice(TLObject):
    constructor_id = 0x92153685
    subclass_of_id = 0xfaf846f4

    def __init__(self, title, description, invoice, payload, provider, start_param, photo=None):
        """
        :param title: Telegram type: "string".
        :param description: Telegram type: "string".
        :param photo: Telegram type: "InputWebDocument".
        :param invoice: Telegram type: "Invoice".
        :param payload: Telegram type: "bytes".
        :param provider: Telegram type: "string".
        :param start_param: Telegram type: "string".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.title = title
        self.description = description
        self.photo = photo
        self.invoice = invoice
        self.payload = payload
        self.provider = provider
        self.start_param = start_param

    def to_dict(self):
        return {
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'invoice': None if self.invoice is None else self.invoice.to_dict(),
            'payload': self.payload,
            'provider': self.provider,
            'start_param': self.start_param,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaInvoice.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.photo else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.title)
        writer.tgwrite_string(self.description)
        if self.photo:
            self.photo.on_send(writer)

        self.invoice.on_send(writer)
        writer.tgwrite_bytes(self.payload)
        writer.tgwrite_string(self.provider)
        writer.tgwrite_string(self.start_param)

    @staticmethod
    def empty():
        return InputMediaInvoice(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.title = reader.tgread_string()
        self.description = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.photo = reader.tgread_object()

        self.invoice = reader.tgread_object()
        self.payload = reader.tgread_bytes()
        self.provider = reader.tgread_string()
        self.start_param = reader.tgread_string()

    def __repr__(self):
        return 'inputMediaInvoice#92153685 flags:# title:string description:string photo:flags.0?InputWebDocument invoice:Invoice payload:bytes provider:string start_param:string = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaPhoto(TLObject):
    constructor_id = 0x81fa373a
    subclass_of_id = 0xfaf846f4

    def __init__(self, id, caption, ttl_seconds=None):
        """
        :param id: Telegram type: "InputPhoto".
        :param caption: Telegram type: "string".
        :param ttl_seconds: Telegram type: "int".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.id = id
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaPhoto.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.ttl_seconds else 0
        writer.write_int(flags)

        self.id.on_send(writer)
        writer.tgwrite_string(self.caption)
        if self.ttl_seconds:
            writer.write_int(self.ttl_seconds)

    @staticmethod
    def empty():
        return InputMediaPhoto(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.tgread_object()
        self.caption = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.ttl_seconds = reader.read_int()

    def __repr__(self):
        return 'inputMediaPhoto#81fa373a flags:# id:InputPhoto caption:string ttl_seconds:flags.0?int = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaPhotoExternal(TLObject):
    constructor_id = 0x922aec1
    subclass_of_id = 0xfaf846f4

    def __init__(self, url, caption, ttl_seconds=None):
        """
        :param url: Telegram type: "string".
        :param caption: Telegram type: "string".
        :param ttl_seconds: Telegram type: "int".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.url = url
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self):
        return {
            'url': self.url,
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaPhotoExternal.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.ttl_seconds else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.url)
        writer.tgwrite_string(self.caption)
        if self.ttl_seconds:
            writer.write_int(self.ttl_seconds)

    @staticmethod
    def empty():
        return InputMediaPhotoExternal(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.url = reader.tgread_string()
        self.caption = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.ttl_seconds = reader.read_int()

    def __repr__(self):
        return 'inputMediaPhotoExternal#0922aec1 flags:# url:string caption:string ttl_seconds:flags.0?int = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaUploadedDocument(TLObject):
    constructor_id = 0xe39621fd
    subclass_of_id = 0xfaf846f4

    def __init__(self, file, mime_type, attributes, caption, thumb=None, stickers=None, ttl_seconds=None):
        """
        :param file: Telegram type: "InputFile".
        :param thumb: Telegram type: "InputFile".
        :param mime_type: Telegram type: "string".
        :param attributes: Telegram type: "DocumentAttribute". Must be a list.
        :param caption: Telegram type: "string".
        :param stickers: Telegram type: "InputDocument". Must be a list.
        :param ttl_seconds: Telegram type: "int".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.file = file
        self.thumb = thumb
        self.mime_type = mime_type
        self.attributes = attributes
        self.caption = caption
        self.stickers = stickers
        self.ttl_seconds = ttl_seconds

    def to_dict(self):
        return {
            'file': None if self.file is None else self.file.to_dict(),
            'thumb': None if self.thumb is None else self.thumb.to_dict(),
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes],
            'caption': self.caption,
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
            'ttl_seconds': self.ttl_seconds,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaUploadedDocument.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.thumb else 0
        flags |= (1 << 0) if self.stickers else 0
        flags |= (1 << 1) if self.ttl_seconds else 0
        writer.write_int(flags)

        self.file.on_send(writer)
        if self.thumb:
            self.thumb.on_send(writer)

        writer.tgwrite_string(self.mime_type)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.attributes))
        for _x in self.attributes:
            _x.on_send(writer)

        writer.tgwrite_string(self.caption)
        if self.stickers:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.stickers))
            for _x in self.stickers:
                if _x:
                    _x.on_send(writer)

        if self.ttl_seconds:
            writer.write_int(self.ttl_seconds)

    @staticmethod
    def empty():
        return InputMediaUploadedDocument(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.file = reader.tgread_object()
        if (flags & (1 << 2)) != 0:
            self.thumb = reader.tgread_object()

        self.mime_type = reader.tgread_string()
        reader.read_int()
        self.attributes = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.attributes.append(_x)

        self.caption = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            reader.read_int()
            self.stickers = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.stickers.append(_x)

        if (flags & (1 << 1)) != 0:
            self.ttl_seconds = reader.read_int()

    def __repr__(self):
        return 'inputMediaUploadedDocument#e39621fd flags:# file:InputFile thumb:flags.2?InputFile mime_type:string attributes:Vector<DocumentAttribute> caption:string stickers:flags.0?Vector<InputDocument> ttl_seconds:flags.1?int = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaUploadedPhoto(TLObject):
    constructor_id = 0x2f37e231
    subclass_of_id = 0xfaf846f4

    def __init__(self, file, caption, stickers=None, ttl_seconds=None):
        """
        :param file: Telegram type: "InputFile".
        :param caption: Telegram type: "string".
        :param stickers: Telegram type: "InputDocument". Must be a list.
        :param ttl_seconds: Telegram type: "int".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.file = file
        self.caption = caption
        self.stickers = stickers
        self.ttl_seconds = ttl_seconds

    def to_dict(self):
        return {
            'file': None if self.file is None else self.file.to_dict(),
            'caption': self.caption,
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
            'ttl_seconds': self.ttl_seconds,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaUploadedPhoto.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.stickers else 0
        flags |= (1 << 1) if self.ttl_seconds else 0
        writer.write_int(flags)

        self.file.on_send(writer)
        writer.tgwrite_string(self.caption)
        if self.stickers:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.stickers))
            for _x in self.stickers:
                if _x:
                    _x.on_send(writer)

        if self.ttl_seconds:
            writer.write_int(self.ttl_seconds)

    @staticmethod
    def empty():
        return InputMediaUploadedPhoto(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.file = reader.tgread_object()
        self.caption = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            reader.read_int()
            self.stickers = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.stickers.append(_x)

        if (flags & (1 << 1)) != 0:
            self.ttl_seconds = reader.read_int()

    def __repr__(self):
        return 'inputMediaUploadedPhoto#2f37e231 flags:# file:InputFile caption:string stickers:flags.0?Vector<InputDocument> ttl_seconds:flags.1?int = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMediaVenue(TLObject):
    constructor_id = 0x2827a81a
    subclass_of_id = 0xfaf846f4

    def __init__(self, geo_point, title, address, provider, venue_id):
        """
        :param geo_point: Telegram type: "InputGeoPoint".
        :param title: Telegram type: "string".
        :param address: Telegram type: "string".
        :param provider: Telegram type: "string".
        :param venue_id: Telegram type: "string".

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.geo_point = geo_point
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id

    def to_dict(self):
        return {
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
        }

    def on_send(self, writer):
        writer.write_int(InputMediaVenue.constructor_id, signed=False)
        self.geo_point.on_send(writer)
        writer.tgwrite_string(self.title)
        writer.tgwrite_string(self.address)
        writer.tgwrite_string(self.provider)
        writer.tgwrite_string(self.venue_id)

    @staticmethod
    def empty():
        return InputMediaVenue(None, None, None, None, None)

    def on_response(self, reader):
        self.geo_point = reader.tgread_object()
        self.title = reader.tgread_string()
        self.address = reader.tgread_string()
        self.provider = reader.tgread_string()
        self.venue_id = reader.tgread_string()

    def __repr__(self):
        return 'inputMediaVenue#2827a81a geo_point:InputGeoPoint title:string address:string provider:string venue_id:string = InputMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessageEntityMentionName(TLObject):
    constructor_id = 0x208e68c9
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length, user_id):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".
        :param user_id: Telegram type: "InputUser".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length
        self.user_id = user_id

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputMessageEntityMentionName.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)
        self.user_id.on_send(writer)

    @staticmethod
    def empty():
        return InputMessageEntityMentionName(None, None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()
        self.user_id = reader.tgread_object()

    def __repr__(self):
        return 'inputMessageEntityMentionName#208e68c9 offset:int length:int user_id:InputUser = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterChatPhotos(TLObject):
    constructor_id = 0x3a20ecb8
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterChatPhotos.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterChatPhotos()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterChatPhotos#3a20ecb8 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterDocument(TLObject):
    constructor_id = 0x9eddf188
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterDocument.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterDocument()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterDocument#9eddf188 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterEmpty(TLObject):
    constructor_id = 0x57e2f66c
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterEmpty#57e2f66c = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterGif(TLObject):
    constructor_id = 0xffc86587
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterGif.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterGif()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterGif#ffc86587 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterMusic(TLObject):
    constructor_id = 0x3751b49e
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterMusic.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterMusic()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterMusic#3751b49e = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterMyMentions(TLObject):
    constructor_id = 0xc1f8e69a
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterMyMentions.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterMyMentions()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterMyMentions#c1f8e69a = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterPhoneCalls(TLObject):
    constructor_id = 0x80c99768
    subclass_of_id = 0x8a36ec14

    def __init__(self, missed=None):
        """
        :param missed: Telegram type: "true".

        Constructor for MessagesFilter: Instance of either InputMessagesFilterEmpty, InputMessagesFilterPhotos, InputMessagesFilterVideo, InputMessagesFilterPhotoVideo, InputMessagesFilterPhotoVideoDocuments, InputMessagesFilterDocument, InputMessagesFilterUrl, InputMessagesFilterGif, InputMessagesFilterVoice, InputMessagesFilterMusic, InputMessagesFilterChatPhotos, InputMessagesFilterPhoneCalls, InputMessagesFilterRoundVoice, InputMessagesFilterRoundVideo, InputMessagesFilterMyMentions.
        """
        super().__init__()

        self.missed = missed

    def to_dict(self):
        return {
            'missed': self.missed,
        }

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterPhoneCalls.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.missed else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return InputMessagesFilterPhoneCalls(None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.missed = True

    def __repr__(self):
        return 'inputMessagesFilterPhoneCalls#80c99768 flags:# missed:flags.0?true = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterPhotoVideo(TLObject):
    constructor_id = 0x56e9f0e4
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterPhotoVideo.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterPhotoVideo()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterPhotoVideo#56e9f0e4 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterPhotoVideoDocuments(TLObject):
    constructor_id = 0xd95e73bb
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterPhotoVideoDocuments.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterPhotoVideoDocuments()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterPhotoVideoDocuments#d95e73bb = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterPhotos(TLObject):
    constructor_id = 0x9609a51c
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterPhotos.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterPhotos()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterPhotos#9609a51c = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterRoundVideo(TLObject):
    constructor_id = 0xb549da53
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterRoundVideo.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterRoundVideo()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterRoundVideo#b549da53 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterRoundVoice(TLObject):
    constructor_id = 0x7a7c17a4
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterRoundVoice.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterRoundVoice()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterRoundVoice#7a7c17a4 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterUrl(TLObject):
    constructor_id = 0x7ef0dd87
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterUrl.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterUrl()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterUrl#7ef0dd87 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterVideo(TLObject):
    constructor_id = 0x9fc00e65
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterVideo.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterVideo()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterVideo#9fc00e65 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputMessagesFilterVoice(TLObject):
    constructor_id = 0x50f5c392
    subclass_of_id = 0x8a36ec14

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputMessagesFilterVoice.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputMessagesFilterVoice()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputMessagesFilterVoice#50f5c392 = MessagesFilter'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputNotifyAll(TLObject):
    constructor_id = 0xa429b886
    subclass_of_id = 0x58981615

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputNotifyAll.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputNotifyAll()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputNotifyAll#a429b886 = InputNotifyPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputNotifyChats(TLObject):
    constructor_id = 0x4a95e84e
    subclass_of_id = 0x58981615

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputNotifyChats.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputNotifyChats()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputNotifyChats#4a95e84e = InputNotifyPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputNotifyPeer(TLObject):
    constructor_id = 0xb8bc5b0c
    subclass_of_id = 0x58981615

    def __init__(self, peer):
        """
        :param peer: Telegram type: "InputPeer".

        Constructor for InputNotifyPeer: Instance of either InputNotifyPeer, InputNotifyUsers, InputNotifyChats, InputNotifyAll.
        """
        super().__init__()

        self.peer = peer

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputNotifyPeer.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return InputNotifyPeer(None)

    def on_response(self, reader):
        self.peer = reader.tgread_object()

    def __repr__(self):
        return 'inputNotifyPeer#b8bc5b0c peer:InputPeer = InputNotifyPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputNotifyUsers(TLObject):
    constructor_id = 0x193b4417
    subclass_of_id = 0x58981615

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputNotifyUsers.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputNotifyUsers()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputNotifyUsers#193b4417 = InputNotifyPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPaymentCredentials(TLObject):
    constructor_id = 0x3417d728
    subclass_of_id = 0x2899a53d

    def __init__(self, data, save=None):
        """
        :param save: Telegram type: "true".
        :param data: Telegram type: "DataJSON".

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials.
        """
        super().__init__()

        self.save = save
        self.data = data

    def to_dict(self):
        return {
            'save': self.save,
            'data': None if self.data is None else self.data.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputPaymentCredentials.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.save else 0
        writer.write_int(flags)

        self.data.on_send(writer)

    @staticmethod
    def empty():
        return InputPaymentCredentials(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.save = True

        self.data = reader.tgread_object()

    def __repr__(self):
        return 'inputPaymentCredentials#3417d728 flags:# save:flags.0?true data:DataJSON = InputPaymentCredentials'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPaymentCredentialsSaved(TLObject):
    constructor_id = 0xc10eb2cf
    subclass_of_id = 0x2899a53d

    def __init__(self, id, tmp_password):
        """
        :param id: Telegram type: "string".
        :param tmp_password: Telegram type: "bytes".

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials.
        """
        super().__init__()

        self.id = id
        self.tmp_password = tmp_password

    def to_dict(self):
        return {
            'id': self.id,
            'tmp_password': self.tmp_password,
        }

    def on_send(self, writer):
        writer.write_int(InputPaymentCredentialsSaved.constructor_id, signed=False)
        writer.tgwrite_string(self.id)
        writer.tgwrite_bytes(self.tmp_password)

    @staticmethod
    def empty():
        return InputPaymentCredentialsSaved(None, None)

    def on_response(self, reader):
        self.id = reader.tgread_string()
        self.tmp_password = reader.tgread_bytes()

    def __repr__(self):
        return 'inputPaymentCredentialsSaved#c10eb2cf id:string tmp_password:bytes = InputPaymentCredentials'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPeerChannel(TLObject):
    constructor_id = 0x20adaef8
    subclass_of_id = 0xc91c90b6

    def __init__(self, channel_id, access_hash):
        """
        :param channel_id: Telegram type: "int".
        :param access_hash: Telegram type: "long".

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.channel_id = channel_id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputPeerChannel.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputPeerChannel(None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputPeerChannel#20adaef8 channel_id:int access_hash:long = InputPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPeerChat(TLObject):
    constructor_id = 0x179be863
    subclass_of_id = 0xc91c90b6

    def __init__(self, chat_id):
        """
        :param chat_id: Telegram type: "int".

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.chat_id = chat_id

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(InputPeerChat.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return InputPeerChat(None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()

    def __repr__(self):
        return 'inputPeerChat#179be863 chat_id:int = InputPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPeerEmpty(TLObject):
    constructor_id = 0x7f3b18ea
    subclass_of_id = 0xc91c90b6

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPeerEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPeerEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPeerEmpty#7f3b18ea = InputPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPeerNotifyEventsAll(TLObject):
    constructor_id = 0xe86a2c74
    subclass_of_id = 0x8f66c45c

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPeerNotifyEventsAll.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPeerNotifyEventsAll()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPeerNotifyEventsAll#e86a2c74 = InputPeerNotifyEvents'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPeerNotifyEventsEmpty(TLObject):
    constructor_id = 0xf03064d8
    subclass_of_id = 0x8f66c45c

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPeerNotifyEventsEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPeerNotifyEventsEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPeerNotifyEventsEmpty#f03064d8 = InputPeerNotifyEvents'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPeerNotifySettings(TLObject):
    constructor_id = 0x38935eb2
    subclass_of_id = 0x90db0b0d

    def __init__(self, mute_until, sound, show_previews=None, silent=None):
        """
        :param show_previews: Telegram type: "true".
        :param silent: Telegram type: "true".
        :param mute_until: Telegram type: "int".
        :param sound: Telegram type: "string".

        Constructor for InputPeerNotifySettings: Instance of InputPeerNotifySettings.
        """
        super().__init__()

        self.show_previews = show_previews
        self.silent = silent
        self.mute_until = mute_until
        self.sound = sound

    def to_dict(self):
        return {
            'show_previews': self.show_previews,
            'silent': self.silent,
            'mute_until': self.mute_until,
            'sound': self.sound,
        }

    def on_send(self, writer):
        writer.write_int(InputPeerNotifySettings.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.show_previews else 0
        flags |= (1 << 1) if self.silent else 0
        writer.write_int(flags)

        writer.write_int(self.mute_until)
        writer.tgwrite_string(self.sound)

    @staticmethod
    def empty():
        return InputPeerNotifySettings(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.show_previews = True

        if (flags & (1 << 1)) != 0:
            self.silent = True

        self.mute_until = reader.read_int()
        self.sound = reader.tgread_string()

    def __repr__(self):
        return 'inputPeerNotifySettings#38935eb2 flags:# show_previews:flags.0?true silent:flags.1?true mute_until:int sound:string = InputPeerNotifySettings'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPeerSelf(TLObject):
    constructor_id = 0x7da07ec9
    subclass_of_id = 0xc91c90b6

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPeerSelf.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPeerSelf()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPeerSelf#7da07ec9 = InputPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPeerUser(TLObject):
    constructor_id = 0x7b8e7de6
    subclass_of_id = 0xc91c90b6

    def __init__(self, user_id, access_hash):
        """
        :param user_id: Telegram type: "int".
        :param access_hash: Telegram type: "long".

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.user_id = user_id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputPeerUser.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputPeerUser(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputPeerUser#7b8e7de6 user_id:int access_hash:long = InputPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPhoneCall(TLObject):
    constructor_id = 0x1e36fded
    subclass_of_id = 0xbcaaf240

    def __init__(self, id, access_hash):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".

        Constructor for InputPhoneCall: Instance of InputPhoneCall.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputPhoneCall.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputPhoneCall(None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputPhoneCall#1e36fded id:long access_hash:long = InputPhoneCall'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPhoneContact(TLObject):
    constructor_id = 0xf392b7f4
    subclass_of_id = 0xae696a82

    def __init__(self, client_id, phone, first_name, last_name):
        """
        :param client_id: Telegram type: "long".
        :param phone: Telegram type: "string".
        :param first_name: Telegram type: "string".
        :param last_name: Telegram type: "string".

        Constructor for InputContact: Instance of InputPhoneContact.
        """
        super().__init__()

        self.client_id = client_id
        self.phone = phone
        self.first_name = first_name
        self.last_name = last_name

    def to_dict(self):
        return {
            'client_id': self.client_id,
            'phone': self.phone,
            'first_name': self.first_name,
            'last_name': self.last_name,
        }

    def on_send(self, writer):
        writer.write_int(InputPhoneContact.constructor_id, signed=False)
        writer.write_long(self.client_id)
        writer.tgwrite_string(self.phone)
        writer.tgwrite_string(self.first_name)
        writer.tgwrite_string(self.last_name)

    @staticmethod
    def empty():
        return InputPhoneContact(None, None, None, None)

    def on_response(self, reader):
        self.client_id = reader.read_long()
        self.phone = reader.tgread_string()
        self.first_name = reader.tgread_string()
        self.last_name = reader.tgread_string()

    def __repr__(self):
        return 'inputPhoneContact#f392b7f4 client_id:long phone:string first_name:string last_name:string = InputContact'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPhoto(TLObject):
    constructor_id = 0xfb95c6c4
    subclass_of_id = 0x846363e0

    def __init__(self, id, access_hash):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".

        Constructor for InputPhoto: Instance of either InputPhotoEmpty, InputPhoto.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputPhoto.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputPhoto(None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputPhoto#fb95c6c4 id:long access_hash:long = InputPhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPhotoEmpty(TLObject):
    constructor_id = 0x1cd7bf0d
    subclass_of_id = 0x846363e0

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPhotoEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPhotoEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPhotoEmpty#1cd7bf0d = InputPhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyKeyChatInvite(TLObject):
    constructor_id = 0xbdfb0426
    subclass_of_id = 0x53627f8

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPrivacyKeyChatInvite.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPrivacyKeyChatInvite()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPrivacyKeyChatInvite#bdfb0426 = InputPrivacyKey'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyKeyPhoneCall(TLObject):
    constructor_id = 0xfabadc5f
    subclass_of_id = 0x53627f8

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPrivacyKeyPhoneCall.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPrivacyKeyPhoneCall()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPrivacyKeyPhoneCall#fabadc5f = InputPrivacyKey'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyKeyStatusTimestamp(TLObject):
    constructor_id = 0x4f96cb18
    subclass_of_id = 0x53627f8

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPrivacyKeyStatusTimestamp.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPrivacyKeyStatusTimestamp()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPrivacyKeyStatusTimestamp#4f96cb18 = InputPrivacyKey'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyValueAllowAll(TLObject):
    constructor_id = 0x184b35ce
    subclass_of_id = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPrivacyValueAllowAll.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPrivacyValueAllowAll()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPrivacyValueAllowAll#184b35ce = InputPrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyValueAllowContacts(TLObject):
    constructor_id = 0xd09e07b
    subclass_of_id = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPrivacyValueAllowContacts.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPrivacyValueAllowContacts()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPrivacyValueAllowContacts#0d09e07b = InputPrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyValueAllowUsers(TLObject):
    constructor_id = 0x131cc67f
    subclass_of_id = 0x5a3b6b22

    def __init__(self, users):
        """
        :param users: Telegram type: "InputUser". Must be a list.

        Constructor for InputPrivacyRule: Instance of either InputPrivacyValueAllowContacts, InputPrivacyValueAllowAll, InputPrivacyValueAllowUsers, InputPrivacyValueDisallowContacts, InputPrivacyValueDisallowAll, InputPrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users

    def to_dict(self):
        return {
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(InputPrivacyValueAllowUsers.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return InputPrivacyValueAllowUsers(None)

    def on_response(self, reader):
        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'inputPrivacyValueAllowUsers#131cc67f users:Vector<InputUser> = InputPrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyValueDisallowAll(TLObject):
    constructor_id = 0xd66b66c9
    subclass_of_id = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPrivacyValueDisallowAll.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPrivacyValueDisallowAll()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPrivacyValueDisallowAll#d66b66c9 = InputPrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyValueDisallowContacts(TLObject):
    constructor_id = 0xba52007
    subclass_of_id = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputPrivacyValueDisallowContacts.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputPrivacyValueDisallowContacts()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputPrivacyValueDisallowContacts#0ba52007 = InputPrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputPrivacyValueDisallowUsers(TLObject):
    constructor_id = 0x90110467
    subclass_of_id = 0x5a3b6b22

    def __init__(self, users):
        """
        :param users: Telegram type: "InputUser". Must be a list.

        Constructor for InputPrivacyRule: Instance of either InputPrivacyValueAllowContacts, InputPrivacyValueAllowAll, InputPrivacyValueAllowUsers, InputPrivacyValueDisallowContacts, InputPrivacyValueDisallowAll, InputPrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users

    def to_dict(self):
        return {
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
        }

    def on_send(self, writer):
        writer.write_int(InputPrivacyValueDisallowUsers.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return InputPrivacyValueDisallowUsers(None)

    def on_response(self, reader):
        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

    def __repr__(self):
        return 'inputPrivacyValueDisallowUsers#90110467 users:Vector<InputUser> = InputPrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputReportReasonOther(TLObject):
    constructor_id = 0xe1746d0a
    subclass_of_id = 0x8401bd27

    def __init__(self, text):
        """
        :param text: Telegram type: "string".

        Constructor for ReportReason: Instance of either InputReportReasonSpam, InputReportReasonViolence, InputReportReasonPornography, InputReportReasonOther.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': self.text,
        }

    def on_send(self, writer):
        writer.write_int(InputReportReasonOther.constructor_id, signed=False)
        writer.tgwrite_string(self.text)

    @staticmethod
    def empty():
        return InputReportReasonOther(None)

    def on_response(self, reader):
        self.text = reader.tgread_string()

    def __repr__(self):
        return 'inputReportReasonOther#e1746d0a text:string = ReportReason'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputReportReasonPornography(TLObject):
    constructor_id = 0x2e59d922
    subclass_of_id = 0x8401bd27

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputReportReasonPornography.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputReportReasonPornography()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputReportReasonPornography#2e59d922 = ReportReason'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputReportReasonSpam(TLObject):
    constructor_id = 0x58dbcab8
    subclass_of_id = 0x8401bd27

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputReportReasonSpam.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputReportReasonSpam()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputReportReasonSpam#58dbcab8 = ReportReason'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputReportReasonViolence(TLObject):
    constructor_id = 0x1e22c78d
    subclass_of_id = 0x8401bd27

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputReportReasonViolence.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputReportReasonViolence()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputReportReasonViolence#1e22c78d = ReportReason'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputStickerSetEmpty(TLObject):
    constructor_id = 0xffb62b95
    subclass_of_id = 0x3da389aa

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputStickerSetEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputStickerSetEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputStickerSetEmpty#ffb62b95 = InputStickerSet'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputStickerSetID(TLObject):
    constructor_id = 0x9de7a269
    subclass_of_id = 0x3da389aa

    def __init__(self, id, access_hash):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".

        Constructor for InputStickerSet: Instance of either InputStickerSetEmpty, InputStickerSetID, InputStickerSetShortName.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputStickerSetID.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputStickerSetID(None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputStickerSetID#9de7a269 id:long access_hash:long = InputStickerSet'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputStickerSetItem(TLObject):
    constructor_id = 0xffa0a496
    subclass_of_id = 0xae59f075

    def __init__(self, document, emoji, mask_coords=None):
        """
        :param document: Telegram type: "InputDocument".
        :param emoji: Telegram type: "string".
        :param mask_coords: Telegram type: "MaskCoords".

        Constructor for InputStickerSetItem: Instance of InputStickerSetItem.
        """
        super().__init__()

        self.document = document
        self.emoji = emoji
        self.mask_coords = mask_coords

    def to_dict(self):
        return {
            'document': None if self.document is None else self.document.to_dict(),
            'emoji': self.emoji,
            'mask_coords': None if self.mask_coords is None else self.mask_coords.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputStickerSetItem.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.mask_coords else 0
        writer.write_int(flags)

        self.document.on_send(writer)
        writer.tgwrite_string(self.emoji)
        if self.mask_coords:
            self.mask_coords.on_send(writer)

    @staticmethod
    def empty():
        return InputStickerSetItem(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.document = reader.tgread_object()
        self.emoji = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.mask_coords = reader.tgread_object()

    def __repr__(self):
        return 'inputStickerSetItem#ffa0a496 flags:# document:InputDocument emoji:string mask_coords:flags.0?MaskCoords = InputStickerSetItem'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputStickerSetShortName(TLObject):
    constructor_id = 0x861cc8a0
    subclass_of_id = 0x3da389aa

    def __init__(self, short_name):
        """
        :param short_name: Telegram type: "string".

        Constructor for InputStickerSet: Instance of either InputStickerSetEmpty, InputStickerSetID, InputStickerSetShortName.
        """
        super().__init__()

        self.short_name = short_name

    def to_dict(self):
        return {
            'short_name': self.short_name,
        }

    def on_send(self, writer):
        writer.write_int(InputStickerSetShortName.constructor_id, signed=False)
        writer.tgwrite_string(self.short_name)

    @staticmethod
    def empty():
        return InputStickerSetShortName(None)

    def on_response(self, reader):
        self.short_name = reader.tgread_string()

    def __repr__(self):
        return 'inputStickerSetShortName#861cc8a0 short_name:string = InputStickerSet'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputStickeredMediaDocument(TLObject):
    constructor_id = 0x438865b
    subclass_of_id = 0x5146d99e

    def __init__(self, id):
        """
        :param id: Telegram type: "InputDocument".

        Constructor for InputStickeredMedia: Instance of either InputStickeredMediaPhoto, InputStickeredMediaDocument.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputStickeredMediaDocument.constructor_id, signed=False)
        self.id.on_send(writer)

    @staticmethod
    def empty():
        return InputStickeredMediaDocument(None)

    def on_response(self, reader):
        self.id = reader.tgread_object()

    def __repr__(self):
        return 'inputStickeredMediaDocument#0438865b id:InputDocument = InputStickeredMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputStickeredMediaPhoto(TLObject):
    constructor_id = 0x4a992157
    subclass_of_id = 0x5146d99e

    def __init__(self, id):
        """
        :param id: Telegram type: "InputPhoto".

        Constructor for InputStickeredMedia: Instance of either InputStickeredMediaPhoto, InputStickeredMediaDocument.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': None if self.id is None else self.id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(InputStickeredMediaPhoto.constructor_id, signed=False)
        self.id.on_send(writer)

    @staticmethod
    def empty():
        return InputStickeredMediaPhoto(None)

    def on_response(self, reader):
        self.id = reader.tgread_object()

    def __repr__(self):
        return 'inputStickeredMediaPhoto#4a992157 id:InputPhoto = InputStickeredMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputUser(TLObject):
    constructor_id = 0xd8292816
    subclass_of_id = 0xe669bf46

    def __init__(self, user_id, access_hash):
        """
        :param user_id: Telegram type: "int".
        :param access_hash: Telegram type: "long".

        Constructor for InputUser: Instance of either InputUserEmpty, InputUserSelf, InputUser.
        """
        super().__init__()

        self.user_id = user_id
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputUser.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputUser(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputUser#d8292816 user_id:int access_hash:long = InputUser'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputUserEmpty(TLObject):
    constructor_id = 0xb98886cf
    subclass_of_id = 0xe669bf46

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputUserEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputUserEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputUserEmpty#b98886cf = InputUser'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputUserSelf(TLObject):
    constructor_id = 0xf7c1b13f
    subclass_of_id = 0xe669bf46

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(InputUserSelf.constructor_id, signed=False)

    @staticmethod
    def empty():
        return InputUserSelf()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'inputUserSelf#f7c1b13f = InputUser'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputWebDocument(TLObject):
    constructor_id = 0x9bed434d
    subclass_of_id = 0x8ae8b146

    def __init__(self, url, size, mime_type, attributes):
        """
        :param url: Telegram type: "string".
        :param size: Telegram type: "int".
        :param mime_type: Telegram type: "string".
        :param attributes: Telegram type: "DocumentAttribute". Must be a list.

        Constructor for InputWebDocument: Instance of InputWebDocument.
        """
        super().__init__()

        self.url = url
        self.size = size
        self.mime_type = mime_type
        self.attributes = attributes

    def to_dict(self):
        return {
            'url': self.url,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes],
        }

    def on_send(self, writer):
        writer.write_int(InputWebDocument.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        writer.write_int(self.size)
        writer.tgwrite_string(self.mime_type)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.attributes))
        for _x in self.attributes:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return InputWebDocument(None, None, None, None)

    def on_response(self, reader):
        self.url = reader.tgread_string()
        self.size = reader.read_int()
        self.mime_type = reader.tgread_string()
        reader.read_int()
        self.attributes = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.attributes.append(_x)

    def __repr__(self):
        return 'inputWebDocument#9bed434d url:string size:int mime_type:string attributes:Vector<DocumentAttribute> = InputWebDocument'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class InputWebFileLocation(TLObject):
    constructor_id = 0xc239d686
    subclass_of_id = 0xf72ed8d9

    def __init__(self, url, access_hash):
        """
        :param url: Telegram type: "string".
        :param access_hash: Telegram type: "long".

        Constructor for InputWebFileLocation: Instance of InputWebFileLocation.
        """
        super().__init__()

        self.url = url
        self.access_hash = access_hash

    def to_dict(self):
        return {
            'url': self.url,
            'access_hash': self.access_hash,
        }

    def on_send(self, writer):
        writer.write_int(InputWebFileLocation.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        writer.write_long(self.access_hash)

    @staticmethod
    def empty():
        return InputWebFileLocation(None, None)

    def on_response(self, reader):
        self.url = reader.tgread_string()
        self.access_hash = reader.read_long()

    def __repr__(self):
        return 'inputWebFileLocation#c239d686 url:string access_hash:long = InputWebFileLocation'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Invoice(TLObject):
    constructor_id = 0xc30aa358
    subclass_of_id = 0x5fd82ed8

    def __init__(self, currency, prices, test=None, name_requested=None, phone_requested=None, email_requested=None, shipping_address_requested=None, flexible=None):
        """
        :param test: Telegram type: "true".
        :param name_requested: Telegram type: "true".
        :param phone_requested: Telegram type: "true".
        :param email_requested: Telegram type: "true".
        :param shipping_address_requested: Telegram type: "true".
        :param flexible: Telegram type: "true".
        :param currency: Telegram type: "string".
        :param prices: Telegram type: "LabeledPrice". Must be a list.

        Constructor for Invoice: Instance of Invoice.
        """
        super().__init__()

        self.test = test
        self.name_requested = name_requested
        self.phone_requested = phone_requested
        self.email_requested = email_requested
        self.shipping_address_requested = shipping_address_requested
        self.flexible = flexible
        self.currency = currency
        self.prices = prices

    def to_dict(self):
        return {
            'test': self.test,
            'name_requested': self.name_requested,
            'phone_requested': self.phone_requested,
            'email_requested': self.email_requested,
            'shipping_address_requested': self.shipping_address_requested,
            'flexible': self.flexible,
            'currency': self.currency,
            'prices': [] if self.prices is None else [None if x is None else x.to_dict() for x in self.prices],
        }

    def on_send(self, writer):
        writer.write_int(Invoice.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.test else 0
        flags |= (1 << 1) if self.name_requested else 0
        flags |= (1 << 2) if self.phone_requested else 0
        flags |= (1 << 3) if self.email_requested else 0
        flags |= (1 << 4) if self.shipping_address_requested else 0
        flags |= (1 << 5) if self.flexible else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.currency)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.prices))
        for _x in self.prices:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Invoice(None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.test = True

        if (flags & (1 << 1)) != 0:
            self.name_requested = True

        if (flags & (1 << 2)) != 0:
            self.phone_requested = True

        if (flags & (1 << 3)) != 0:
            self.email_requested = True

        if (flags & (1 << 4)) != 0:
            self.shipping_address_requested = True

        if (flags & (1 << 5)) != 0:
            self.flexible = True

        self.currency = reader.tgread_string()
        reader.read_int()
        self.prices = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.prices.append(_x)

    def __repr__(self):
        return 'invoice#c30aa358 flags:# test:flags.0?true name_requested:flags.1?true phone_requested:flags.2?true email_requested:flags.3?true shipping_address_requested:flags.4?true flexible:flags.5?true currency:string prices:Vector<LabeledPrice> = Invoice'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class IpPort(TLObject):
    constructor_id = 0xd433ad73
    subclass_of_id = 0xa2a03726

    def __init__(self, ipv4, port):
        """
        :param ipv4: Telegram type: "int".
        :param port: Telegram type: "int".

        Constructor for IpPort: Instance of IpPort.
        """
        super().__init__()

        self.ipv4 = ipv4
        self.port = port

    def to_dict(self):
        return {
            'ipv4': self.ipv4,
            'port': self.port,
        }

    def on_send(self, writer):
        writer.write_int(IpPort.constructor_id, signed=False)
        writer.write_int(self.ipv4)
        writer.write_int(self.port)

    @staticmethod
    def empty():
        return IpPort(None, None)

    def on_response(self, reader):
        self.ipv4 = reader.read_int()
        self.port = reader.read_int()

    def __repr__(self):
        return 'ipPort#d433ad73 ipv4:int port:int = IpPort'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButton(TLObject):
    constructor_id = 0xa2fa4880
    subclass_of_id = 0xbad74a3

    def __init__(self, text):
        """
        :param text: Telegram type: "string".

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': self.text,
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButton.constructor_id, signed=False)
        writer.tgwrite_string(self.text)

    @staticmethod
    def empty():
        return KeyboardButton(None)

    def on_response(self, reader):
        self.text = reader.tgread_string()

    def __repr__(self):
        return 'keyboardButton#a2fa4880 text:string = KeyboardButton'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButtonBuy(TLObject):
    constructor_id = 0xafd93fbb
    subclass_of_id = 0xbad74a3

    def __init__(self, text):
        """
        :param text: Telegram type: "string".

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': self.text,
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButtonBuy.constructor_id, signed=False)
        writer.tgwrite_string(self.text)

    @staticmethod
    def empty():
        return KeyboardButtonBuy(None)

    def on_response(self, reader):
        self.text = reader.tgread_string()

    def __repr__(self):
        return 'keyboardButtonBuy#afd93fbb text:string = KeyboardButton'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButtonCallback(TLObject):
    constructor_id = 0x683a5e46
    subclass_of_id = 0xbad74a3

    def __init__(self, text, data):
        """
        :param text: Telegram type: "string".
        :param data: Telegram type: "bytes".

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text
        self.data = data

    def to_dict(self):
        return {
            'text': self.text,
            'data': self.data,
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButtonCallback.constructor_id, signed=False)
        writer.tgwrite_string(self.text)
        writer.tgwrite_bytes(self.data)

    @staticmethod
    def empty():
        return KeyboardButtonCallback(None, None)

    def on_response(self, reader):
        self.text = reader.tgread_string()
        self.data = reader.tgread_bytes()

    def __repr__(self):
        return 'keyboardButtonCallback#683a5e46 text:string data:bytes = KeyboardButton'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButtonGame(TLObject):
    constructor_id = 0x50f41ccf
    subclass_of_id = 0xbad74a3

    def __init__(self, text):
        """
        :param text: Telegram type: "string".

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': self.text,
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButtonGame.constructor_id, signed=False)
        writer.tgwrite_string(self.text)

    @staticmethod
    def empty():
        return KeyboardButtonGame(None)

    def on_response(self, reader):
        self.text = reader.tgread_string()

    def __repr__(self):
        return 'keyboardButtonGame#50f41ccf text:string = KeyboardButton'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButtonRequestGeoLocation(TLObject):
    constructor_id = 0xfc796b3f
    subclass_of_id = 0xbad74a3

    def __init__(self, text):
        """
        :param text: Telegram type: "string".

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': self.text,
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButtonRequestGeoLocation.constructor_id, signed=False)
        writer.tgwrite_string(self.text)

    @staticmethod
    def empty():
        return KeyboardButtonRequestGeoLocation(None)

    def on_response(self, reader):
        self.text = reader.tgread_string()

    def __repr__(self):
        return 'keyboardButtonRequestGeoLocation#fc796b3f text:string = KeyboardButton'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButtonRequestPhone(TLObject):
    constructor_id = 0xb16a6c29
    subclass_of_id = 0xbad74a3

    def __init__(self, text):
        """
        :param text: Telegram type: "string".

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': self.text,
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButtonRequestPhone.constructor_id, signed=False)
        writer.tgwrite_string(self.text)

    @staticmethod
    def empty():
        return KeyboardButtonRequestPhone(None)

    def on_response(self, reader):
        self.text = reader.tgread_string()

    def __repr__(self):
        return 'keyboardButtonRequestPhone#b16a6c29 text:string = KeyboardButton'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButtonRow(TLObject):
    constructor_id = 0x77608b83
    subclass_of_id = 0x847730ae

    def __init__(self, buttons):
        """
        :param buttons: Telegram type: "KeyboardButton". Must be a list.

        Constructor for KeyboardButtonRow: Instance of KeyboardButtonRow.
        """
        super().__init__()

        self.buttons = buttons

    def to_dict(self):
        return {
            'buttons': [] if self.buttons is None else [None if x is None else x.to_dict() for x in self.buttons],
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButtonRow.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.buttons))
        for _x in self.buttons:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return KeyboardButtonRow(None)

    def on_response(self, reader):
        reader.read_int()
        self.buttons = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.buttons.append(_x)

    def __repr__(self):
        return 'keyboardButtonRow#77608b83 buttons:Vector<KeyboardButton> = KeyboardButtonRow'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButtonSwitchInline(TLObject):
    constructor_id = 0x568a748
    subclass_of_id = 0xbad74a3

    def __init__(self, text, query, same_peer=None):
        """
        :param same_peer: Telegram type: "true".
        :param text: Telegram type: "string".
        :param query: Telegram type: "string".

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.same_peer = same_peer
        self.text = text
        self.query = query

    def to_dict(self):
        return {
            'same_peer': self.same_peer,
            'text': self.text,
            'query': self.query,
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButtonSwitchInline.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.same_peer else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.text)
        writer.tgwrite_string(self.query)

    @staticmethod
    def empty():
        return KeyboardButtonSwitchInline(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.same_peer = True

        self.text = reader.tgread_string()
        self.query = reader.tgread_string()

    def __repr__(self):
        return 'keyboardButtonSwitchInline#0568a748 flags:# same_peer:flags.0?true text:string query:string = KeyboardButton'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class KeyboardButtonUrl(TLObject):
    constructor_id = 0x258aff05
    subclass_of_id = 0xbad74a3

    def __init__(self, text, url):
        """
        :param text: Telegram type: "string".
        :param url: Telegram type: "string".

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text
        self.url = url

    def to_dict(self):
        return {
            'text': self.text,
            'url': self.url,
        }

    def on_send(self, writer):
        writer.write_int(KeyboardButtonUrl.constructor_id, signed=False)
        writer.tgwrite_string(self.text)
        writer.tgwrite_string(self.url)

    @staticmethod
    def empty():
        return KeyboardButtonUrl(None, None)

    def on_response(self, reader):
        self.text = reader.tgread_string()
        self.url = reader.tgread_string()

    def __repr__(self):
        return 'keyboardButtonUrl#258aff05 text:string url:string = KeyboardButton'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class LabeledPrice(TLObject):
    constructor_id = 0xcb296bf8
    subclass_of_id = 0x1c84047a

    def __init__(self, label, amount):
        """
        :param label: Telegram type: "string".
        :param amount: Telegram type: "long".

        Constructor for LabeledPrice: Instance of LabeledPrice.
        """
        super().__init__()

        self.label = label
        self.amount = amount

    def to_dict(self):
        return {
            'label': self.label,
            'amount': self.amount,
        }

    def on_send(self, writer):
        writer.write_int(LabeledPrice.constructor_id, signed=False)
        writer.tgwrite_string(self.label)
        writer.write_long(self.amount)

    @staticmethod
    def empty():
        return LabeledPrice(None, None)

    def on_response(self, reader):
        self.label = reader.tgread_string()
        self.amount = reader.read_long()

    def __repr__(self):
        return 'labeledPrice#cb296bf8 label:string amount:long = LabeledPrice'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class LangPackDifference(TLObject):
    constructor_id = 0xf385c1f6
    subclass_of_id = 0x52662d55

    def __init__(self, lang_code, from_version, version, strings):
        """
        :param lang_code: Telegram type: "string".
        :param from_version: Telegram type: "int".
        :param version: Telegram type: "int".
        :param strings: Telegram type: "LangPackString". Must be a list.

        Constructor for LangPackDifference: Instance of LangPackDifference.
        """
        super().__init__()

        self.lang_code = lang_code
        self.from_version = from_version
        self.version = version
        self.strings = strings

    def to_dict(self):
        return {
            'lang_code': self.lang_code,
            'from_version': self.from_version,
            'version': self.version,
            'strings': [] if self.strings is None else [None if x is None else x.to_dict() for x in self.strings],
        }

    def on_send(self, writer):
        writer.write_int(LangPackDifference.constructor_id, signed=False)
        writer.tgwrite_string(self.lang_code)
        writer.write_int(self.from_version)
        writer.write_int(self.version)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.strings))
        for _x in self.strings:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return LangPackDifference(None, None, None, None)

    def on_response(self, reader):
        self.lang_code = reader.tgread_string()
        self.from_version = reader.read_int()
        self.version = reader.read_int()
        reader.read_int()
        self.strings = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.strings.append(_x)

    def __repr__(self):
        return 'langPackDifference#f385c1f6 lang_code:string from_version:int version:int strings:Vector<LangPackString> = LangPackDifference'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class LangPackLanguage(TLObject):
    constructor_id = 0x117698f1
    subclass_of_id = 0xabac89b7

    def __init__(self, name, native_name, lang_code):
        """
        :param name: Telegram type: "string".
        :param native_name: Telegram type: "string".
        :param lang_code: Telegram type: "string".

        Constructor for LangPackLanguage: Instance of LangPackLanguage.
        """
        super().__init__()

        self.name = name
        self.native_name = native_name
        self.lang_code = lang_code

    def to_dict(self):
        return {
            'name': self.name,
            'native_name': self.native_name,
            'lang_code': self.lang_code,
        }

    def on_send(self, writer):
        writer.write_int(LangPackLanguage.constructor_id, signed=False)
        writer.tgwrite_string(self.name)
        writer.tgwrite_string(self.native_name)
        writer.tgwrite_string(self.lang_code)

    @staticmethod
    def empty():
        return LangPackLanguage(None, None, None)

    def on_response(self, reader):
        self.name = reader.tgread_string()
        self.native_name = reader.tgread_string()
        self.lang_code = reader.tgread_string()

    def __repr__(self):
        return 'langPackLanguage#117698f1 name:string native_name:string lang_code:string = LangPackLanguage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class LangPackString(TLObject):
    constructor_id = 0xcad181f6
    subclass_of_id = 0xdc179ab9

    def __init__(self, key, value):
        """
        :param key: Telegram type: "string".
        :param value: Telegram type: "string".

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key
        self.value = value

    def to_dict(self):
        return {
            'key': self.key,
            'value': self.value,
        }

    def on_send(self, writer):
        writer.write_int(LangPackString.constructor_id, signed=False)
        writer.tgwrite_string(self.key)
        writer.tgwrite_string(self.value)

    @staticmethod
    def empty():
        return LangPackString(None, None)

    def on_response(self, reader):
        self.key = reader.tgread_string()
        self.value = reader.tgread_string()

    def __repr__(self):
        return 'langPackString#cad181f6 key:string value:string = LangPackString'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class LangPackStringDeleted(TLObject):
    constructor_id = 0x2979eeb2
    subclass_of_id = 0xdc179ab9

    def __init__(self, key):
        """
        :param key: Telegram type: "string".

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key

    def to_dict(self):
        return {
            'key': self.key,
        }

    def on_send(self, writer):
        writer.write_int(LangPackStringDeleted.constructor_id, signed=False)
        writer.tgwrite_string(self.key)

    @staticmethod
    def empty():
        return LangPackStringDeleted(None)

    def on_response(self, reader):
        self.key = reader.tgread_string()

    def __repr__(self):
        return 'langPackStringDeleted#2979eeb2 key:string = LangPackString'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class LangPackStringPluralized(TLObject):
    constructor_id = 0x6c47ac9f
    subclass_of_id = 0xdc179ab9

    def __init__(self, key, other_value, zero_value=None, one_value=None, two_value=None, few_value=None, many_value=None):
        """
        :param key: Telegram type: "string".
        :param zero_value: Telegram type: "string".
        :param one_value: Telegram type: "string".
        :param two_value: Telegram type: "string".
        :param few_value: Telegram type: "string".
        :param many_value: Telegram type: "string".
        :param other_value: Telegram type: "string".

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key
        self.zero_value = zero_value
        self.one_value = one_value
        self.two_value = two_value
        self.few_value = few_value
        self.many_value = many_value
        self.other_value = other_value

    def to_dict(self):
        return {
            'key': self.key,
            'zero_value': self.zero_value,
            'one_value': self.one_value,
            'two_value': self.two_value,
            'few_value': self.few_value,
            'many_value': self.many_value,
            'other_value': self.other_value,
        }

    def on_send(self, writer):
        writer.write_int(LangPackStringPluralized.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.zero_value else 0
        flags |= (1 << 1) if self.one_value else 0
        flags |= (1 << 2) if self.two_value else 0
        flags |= (1 << 3) if self.few_value else 0
        flags |= (1 << 4) if self.many_value else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.key)
        if self.zero_value:
            writer.tgwrite_string(self.zero_value)

        if self.one_value:
            writer.tgwrite_string(self.one_value)

        if self.two_value:
            writer.tgwrite_string(self.two_value)

        if self.few_value:
            writer.tgwrite_string(self.few_value)

        if self.many_value:
            writer.tgwrite_string(self.many_value)

        writer.tgwrite_string(self.other_value)

    @staticmethod
    def empty():
        return LangPackStringPluralized(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.key = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.zero_value = reader.tgread_string()

        if (flags & (1 << 1)) != 0:
            self.one_value = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.two_value = reader.tgread_string()

        if (flags & (1 << 3)) != 0:
            self.few_value = reader.tgread_string()

        if (flags & (1 << 4)) != 0:
            self.many_value = reader.tgread_string()

        self.other_value = reader.tgread_string()

    def __repr__(self):
        return 'langPackStringPluralized#6c47ac9f flags:# key:string zero_value:flags.0?string one_value:flags.1?string two_value:flags.2?string few_value:flags.3?string many_value:flags.4?string other_value:string = LangPackString'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MaskCoords(TLObject):
    constructor_id = 0xaed6dbb2
    subclass_of_id = 0x6bbb2fd

    def __init__(self, n, x, y, zoom):
        """
        :param n: Telegram type: "int".
        :param x: Telegram type: "double".
        :param y: Telegram type: "double".
        :param zoom: Telegram type: "double".

        Constructor for MaskCoords: Instance of MaskCoords.
        """
        super().__init__()

        self.n = n
        self.x = x
        self.y = y
        self.zoom = zoom

    def to_dict(self):
        return {
            'n': self.n,
            'x': self.x,
            'y': self.y,
            'zoom': self.zoom,
        }

    def on_send(self, writer):
        writer.write_int(MaskCoords.constructor_id, signed=False)
        writer.write_int(self.n)
        writer.write_double(self.x)
        writer.write_double(self.y)
        writer.write_double(self.zoom)

    @staticmethod
    def empty():
        return MaskCoords(None, None, None, None)

    def on_response(self, reader):
        self.n = reader.read_int()
        self.x = reader.read_double()
        self.y = reader.read_double()
        self.zoom = reader.read_double()

    def __repr__(self):
        return 'maskCoords#aed6dbb2 n:int x:double y:double zoom:double = MaskCoords'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Message(TLObject):
    constructor_id = 0x90dddc11
    subclass_of_id = 0x790009e3

    def __init__(self, id, to_id, date, message, out=None, mentioned=None, media_unread=None, silent=None, post=None, from_id=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, media=None, reply_markup=None, entities=None, views=None, edit_date=None, post_author=None):
        """
        :param out: Telegram type: "true".
        :param mentioned: Telegram type: "true".
        :param media_unread: Telegram type: "true".
        :param silent: Telegram type: "true".
        :param post: Telegram type: "true".
        :param id: Telegram type: "int".
        :param from_id: Telegram type: "int".
        :param to_id: Telegram type: "Peer".
        :param fwd_from: Telegram type: "MessageFwdHeader".
        :param via_bot_id: Telegram type: "int".
        :param reply_to_msg_id: Telegram type: "int".
        :param date: Telegram type: "date".
        :param message: Telegram type: "string".
        :param media: Telegram type: "MessageMedia".
        :param reply_markup: Telegram type: "ReplyMarkup".
        :param entities: Telegram type: "MessageEntity". Must be a list.
        :param views: Telegram type: "int".
        :param edit_date: Telegram type: "date".
        :param post_author: Telegram type: "string".

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.post = post
        self.id = id
        self.from_id = from_id
        self.to_id = to_id
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to_msg_id = reply_to_msg_id
        self.date = date
        self.message = message
        self.media = media
        self.reply_markup = reply_markup
        self.entities = entities
        self.views = views
        self.edit_date = edit_date
        self.post_author = post_author

    def to_dict(self):
        return {
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'post': self.post,
            'id': self.id,
            'from_id': self.from_id,
            'to_id': None if self.to_id is None else self.to_id.to_dict(),
            'fwd_from': None if self.fwd_from is None else self.fwd_from.to_dict(),
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'date': self.date,
            'message': self.message,
            'media': None if self.media is None else self.media.to_dict(),
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'views': self.views,
            'edit_date': self.edit_date,
            'post_author': self.post_author,
        }

    def on_send(self, writer):
        writer.write_int(Message.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.out else 0
        flags |= (1 << 4) if self.mentioned else 0
        flags |= (1 << 5) if self.media_unread else 0
        flags |= (1 << 13) if self.silent else 0
        flags |= (1 << 14) if self.post else 0
        flags |= (1 << 8) if self.from_id else 0
        flags |= (1 << 2) if self.fwd_from else 0
        flags |= (1 << 11) if self.via_bot_id else 0
        flags |= (1 << 3) if self.reply_to_msg_id else 0
        flags |= (1 << 9) if self.media else 0
        flags |= (1 << 6) if self.reply_markup else 0
        flags |= (1 << 7) if self.entities else 0
        flags |= (1 << 10) if self.views else 0
        flags |= (1 << 15) if self.edit_date else 0
        flags |= (1 << 16) if self.post_author else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        if self.from_id:
            writer.write_int(self.from_id)

        self.to_id.on_send(writer)
        if self.fwd_from:
            self.fwd_from.on_send(writer)

        if self.via_bot_id:
            writer.write_int(self.via_bot_id)

        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        writer.tgwrite_date(self.date)
        writer.tgwrite_string(self.message)
        if self.media:
            self.media.on_send(writer)

        if self.reply_markup:
            self.reply_markup.on_send(writer)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

        if self.views:
            writer.write_int(self.views)

        if self.edit_date:
            writer.tgwrite_date(self.edit_date)

        if self.post_author:
            writer.tgwrite_string(self.post_author)

    @staticmethod
    def empty():
        return Message(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.out = True

        if (flags & (1 << 4)) != 0:
            self.mentioned = True

        if (flags & (1 << 5)) != 0:
            self.media_unread = True

        if (flags & (1 << 13)) != 0:
            self.silent = True

        if (flags & (1 << 14)) != 0:
            self.post = True

        self.id = reader.read_int()
        if (flags & (1 << 8)) != 0:
            self.from_id = reader.read_int()

        self.to_id = reader.tgread_object()
        if (flags & (1 << 2)) != 0:
            self.fwd_from = reader.tgread_object()

        if (flags & (1 << 11)) != 0:
            self.via_bot_id = reader.read_int()

        if (flags & (1 << 3)) != 0:
            self.reply_to_msg_id = reader.read_int()

        self.date = reader.tgread_date()
        self.message = reader.tgread_string()
        if (flags & (1 << 9)) != 0:
            self.media = reader.tgread_object()

        if (flags & (1 << 6)) != 0:
            self.reply_markup = reader.tgread_object()

        if (flags & (1 << 7)) != 0:
            reader.read_int()
            self.entities = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.entities.append(_x)

        if (flags & (1 << 10)) != 0:
            self.views = reader.read_int()

        if (flags & (1 << 15)) != 0:
            self.edit_date = reader.tgread_date()

        if (flags & (1 << 16)) != 0:
            self.post_author = reader.tgread_string()

    def __repr__(self):
        return 'message#90dddc11 flags:# out:flags.1?true mentioned:flags.4?true media_unread:flags.5?true silent:flags.13?true post:flags.14?true id:int from_id:flags.8?int to_id:Peer fwd_from:flags.2?MessageFwdHeader via_bot_id:flags.11?int reply_to_msg_id:flags.3?int date:int message:string media:flags.9?MessageMedia reply_markup:flags.6?ReplyMarkup entities:flags.7?Vector<MessageEntity> views:flags.10?int edit_date:flags.15?int post_author:flags.16?string = Message'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChannelCreate(TLObject):
    constructor_id = 0x95d2ac92
    subclass_of_id = 0x8680d126

    def __init__(self, title):
        """
        :param title: Telegram type: "string".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.title = title

    def to_dict(self):
        return {
            'title': self.title,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChannelCreate.constructor_id, signed=False)
        writer.tgwrite_string(self.title)

    @staticmethod
    def empty():
        return MessageActionChannelCreate(None)

    def on_response(self, reader):
        self.title = reader.tgread_string()

    def __repr__(self):
        return 'messageActionChannelCreate#95d2ac92 title:string = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChannelMigrateFrom(TLObject):
    constructor_id = 0xb055eaee
    subclass_of_id = 0x8680d126

    def __init__(self, title, chat_id):
        """
        :param title: Telegram type: "string".
        :param chat_id: Telegram type: "int".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.title = title
        self.chat_id = chat_id

    def to_dict(self):
        return {
            'title': self.title,
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChannelMigrateFrom.constructor_id, signed=False)
        writer.tgwrite_string(self.title)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return MessageActionChannelMigrateFrom(None, None)

    def on_response(self, reader):
        self.title = reader.tgread_string()
        self.chat_id = reader.read_int()

    def __repr__(self):
        return 'messageActionChannelMigrateFrom#b055eaee title:string chat_id:int = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChatAddUser(TLObject):
    constructor_id = 0x488a7337
    subclass_of_id = 0x8680d126

    def __init__(self, users):
        """
        :param users: Telegram type: "int". Must be a list.

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.users = users

    def to_dict(self):
        return {
            'users': [] if self.users is None else self.users[:],
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChatAddUser.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return MessageActionChatAddUser(None)

    def on_response(self, reader):
        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_int()
            self.users.append(_x)

    def __repr__(self):
        return 'messageActionChatAddUser#488a7337 users:Vector<int> = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChatCreate(TLObject):
    constructor_id = 0xa6638b9a
    subclass_of_id = 0x8680d126

    def __init__(self, title, users):
        """
        :param title: Telegram type: "string".
        :param users: Telegram type: "int". Must be a list.

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.title = title
        self.users = users

    def to_dict(self):
        return {
            'title': self.title,
            'users': [] if self.users is None else self.users[:],
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChatCreate.constructor_id, signed=False)
        writer.tgwrite_string(self.title)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return MessageActionChatCreate(None, None)

    def on_response(self, reader):
        self.title = reader.tgread_string()
        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_int()
            self.users.append(_x)

    def __repr__(self):
        return 'messageActionChatCreate#a6638b9a title:string users:Vector<int> = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChatDeletePhoto(TLObject):
    constructor_id = 0x95e3fbef
    subclass_of_id = 0x8680d126

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(MessageActionChatDeletePhoto.constructor_id, signed=False)

    @staticmethod
    def empty():
        return MessageActionChatDeletePhoto()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messageActionChatDeletePhoto#95e3fbef = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChatDeleteUser(TLObject):
    constructor_id = 0xb2ae9b0c
    subclass_of_id = 0x8680d126

    def __init__(self, user_id):
        """
        :param user_id: Telegram type: "int".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.user_id = user_id

    def to_dict(self):
        return {
            'user_id': self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChatDeleteUser.constructor_id, signed=False)
        writer.write_int(self.user_id)

    @staticmethod
    def empty():
        return MessageActionChatDeleteUser(None)

    def on_response(self, reader):
        self.user_id = reader.read_int()

    def __repr__(self):
        return 'messageActionChatDeleteUser#b2ae9b0c user_id:int = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChatEditPhoto(TLObject):
    constructor_id = 0x7fcb13a8
    subclass_of_id = 0x8680d126

    def __init__(self, photo):
        """
        :param photo: Telegram type: "Photo".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.photo = photo

    def to_dict(self):
        return {
            'photo': None if self.photo is None else self.photo.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChatEditPhoto.constructor_id, signed=False)
        self.photo.on_send(writer)

    @staticmethod
    def empty():
        return MessageActionChatEditPhoto(None)

    def on_response(self, reader):
        self.photo = reader.tgread_object()

    def __repr__(self):
        return 'messageActionChatEditPhoto#7fcb13a8 photo:Photo = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChatEditTitle(TLObject):
    constructor_id = 0xb5a1ce5a
    subclass_of_id = 0x8680d126

    def __init__(self, title):
        """
        :param title: Telegram type: "string".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.title = title

    def to_dict(self):
        return {
            'title': self.title,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChatEditTitle.constructor_id, signed=False)
        writer.tgwrite_string(self.title)

    @staticmethod
    def empty():
        return MessageActionChatEditTitle(None)

    def on_response(self, reader):
        self.title = reader.tgread_string()

    def __repr__(self):
        return 'messageActionChatEditTitle#b5a1ce5a title:string = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChatJoinedByLink(TLObject):
    constructor_id = 0xf89cf5e8
    subclass_of_id = 0x8680d126

    def __init__(self, inviter_id):
        """
        :param inviter_id: Telegram type: "int".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.inviter_id = inviter_id

    def to_dict(self):
        return {
            'inviter_id': self.inviter_id,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChatJoinedByLink.constructor_id, signed=False)
        writer.write_int(self.inviter_id)

    @staticmethod
    def empty():
        return MessageActionChatJoinedByLink(None)

    def on_response(self, reader):
        self.inviter_id = reader.read_int()

    def __repr__(self):
        return 'messageActionChatJoinedByLink#f89cf5e8 inviter_id:int = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionChatMigrateTo(TLObject):
    constructor_id = 0x51bdb021
    subclass_of_id = 0x8680d126

    def __init__(self, channel_id):
        """
        :param channel_id: Telegram type: "int".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.channel_id = channel_id

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionChatMigrateTo.constructor_id, signed=False)
        writer.write_int(self.channel_id)

    @staticmethod
    def empty():
        return MessageActionChatMigrateTo(None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()

    def __repr__(self):
        return 'messageActionChatMigrateTo#51bdb021 channel_id:int = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionEmpty(TLObject):
    constructor_id = 0xb6aef7b0
    subclass_of_id = 0x8680d126

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(MessageActionEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return MessageActionEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messageActionEmpty#b6aef7b0 = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionGameScore(TLObject):
    constructor_id = 0x92a72876
    subclass_of_id = 0x8680d126

    def __init__(self, game_id, score):
        """
        :param game_id: Telegram type: "long".
        :param score: Telegram type: "int".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.game_id = game_id
        self.score = score

    def to_dict(self):
        return {
            'game_id': self.game_id,
            'score': self.score,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionGameScore.constructor_id, signed=False)
        writer.write_long(self.game_id)
        writer.write_int(self.score)

    @staticmethod
    def empty():
        return MessageActionGameScore(None, None)

    def on_response(self, reader):
        self.game_id = reader.read_long()
        self.score = reader.read_int()

    def __repr__(self):
        return 'messageActionGameScore#92a72876 game_id:long score:int = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionHistoryClear(TLObject):
    constructor_id = 0x9fbab604
    subclass_of_id = 0x8680d126

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(MessageActionHistoryClear.constructor_id, signed=False)

    @staticmethod
    def empty():
        return MessageActionHistoryClear()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messageActionHistoryClear#9fbab604 = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionPaymentSent(TLObject):
    constructor_id = 0x40699cd0
    subclass_of_id = 0x8680d126

    def __init__(self, currency, total_amount):
        """
        :param currency: Telegram type: "string".
        :param total_amount: Telegram type: "long".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.currency = currency
        self.total_amount = total_amount

    def to_dict(self):
        return {
            'currency': self.currency,
            'total_amount': self.total_amount,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionPaymentSent.constructor_id, signed=False)
        writer.tgwrite_string(self.currency)
        writer.write_long(self.total_amount)

    @staticmethod
    def empty():
        return MessageActionPaymentSent(None, None)

    def on_response(self, reader):
        self.currency = reader.tgread_string()
        self.total_amount = reader.read_long()

    def __repr__(self):
        return 'messageActionPaymentSent#40699cd0 currency:string total_amount:long = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionPaymentSentMe(TLObject):
    constructor_id = 0x8f31b327
    subclass_of_id = 0x8680d126

    def __init__(self, currency, total_amount, payload, charge, info=None, shipping_option_id=None):
        """
        :param currency: Telegram type: "string".
        :param total_amount: Telegram type: "long".
        :param payload: Telegram type: "bytes".
        :param info: Telegram type: "PaymentRequestedInfo".
        :param shipping_option_id: Telegram type: "string".
        :param charge: Telegram type: "PaymentCharge".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.currency = currency
        self.total_amount = total_amount
        self.payload = payload
        self.info = info
        self.shipping_option_id = shipping_option_id
        self.charge = charge

    def to_dict(self):
        return {
            'currency': self.currency,
            'total_amount': self.total_amount,
            'payload': self.payload,
            'info': None if self.info is None else self.info.to_dict(),
            'shipping_option_id': self.shipping_option_id,
            'charge': None if self.charge is None else self.charge.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(MessageActionPaymentSentMe.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.info else 0
        flags |= (1 << 1) if self.shipping_option_id else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.currency)
        writer.write_long(self.total_amount)
        writer.tgwrite_bytes(self.payload)
        if self.info:
            self.info.on_send(writer)

        if self.shipping_option_id:
            writer.tgwrite_string(self.shipping_option_id)

        self.charge.on_send(writer)

    @staticmethod
    def empty():
        return MessageActionPaymentSentMe(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.currency = reader.tgread_string()
        self.total_amount = reader.read_long()
        self.payload = reader.tgread_bytes()
        if (flags & (1 << 0)) != 0:
            self.info = reader.tgread_object()

        if (flags & (1 << 1)) != 0:
            self.shipping_option_id = reader.tgread_string()

        self.charge = reader.tgread_object()

    def __repr__(self):
        return 'messageActionPaymentSentMe#8f31b327 flags:# currency:string total_amount:long payload:bytes info:flags.0?PaymentRequestedInfo shipping_option_id:flags.1?string charge:PaymentCharge = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionPhoneCall(TLObject):
    constructor_id = 0x80e11a7f
    subclass_of_id = 0x8680d126

    def __init__(self, call_id, reason=None, duration=None):
        """
        :param call_id: Telegram type: "long".
        :param reason: Telegram type: "PhoneCallDiscardReason".
        :param duration: Telegram type: "int".

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.call_id = call_id
        self.reason = reason
        self.duration = duration

    def to_dict(self):
        return {
            'call_id': self.call_id,
            'reason': None if self.reason is None else self.reason.to_dict(),
            'duration': self.duration,
        }

    def on_send(self, writer):
        writer.write_int(MessageActionPhoneCall.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.reason else 0
        flags |= (1 << 1) if self.duration else 0
        writer.write_int(flags)

        writer.write_long(self.call_id)
        if self.reason:
            self.reason.on_send(writer)

        if self.duration:
            writer.write_int(self.duration)

    @staticmethod
    def empty():
        return MessageActionPhoneCall(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.call_id = reader.read_long()
        if (flags & (1 << 0)) != 0:
            self.reason = reader.tgread_object()

        if (flags & (1 << 1)) != 0:
            self.duration = reader.read_int()

    def __repr__(self):
        return 'messageActionPhoneCall#80e11a7f flags:# call_id:long reason:flags.0?PhoneCallDiscardReason duration:flags.1?int = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionPinMessage(TLObject):
    constructor_id = 0x94bd38ed
    subclass_of_id = 0x8680d126

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(MessageActionPinMessage.constructor_id, signed=False)

    @staticmethod
    def empty():
        return MessageActionPinMessage()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messageActionPinMessage#94bd38ed = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageActionScreenshotTaken(TLObject):
    constructor_id = 0x4792929b
    subclass_of_id = 0x8680d126

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(MessageActionScreenshotTaken.constructor_id, signed=False)

    @staticmethod
    def empty():
        return MessageActionScreenshotTaken()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messageActionScreenshotTaken#4792929b = MessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEmpty(TLObject):
    constructor_id = 0x83e5de54
    subclass_of_id = 0x790009e3

    def __init__(self, id):
        """
        :param id: Telegram type: "int".

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(MessageEmpty.constructor_id, signed=False)
        writer.write_int(self.id)

    @staticmethod
    def empty():
        return MessageEmpty(None)

    def on_response(self, reader):
        self.id = reader.read_int()

    def __repr__(self):
        return 'messageEmpty#83e5de54 id:int = Message'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityBold(TLObject):
    constructor_id = 0xbd610bc9
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityBold.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityBold(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityBold#bd610bc9 offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityBotCommand(TLObject):
    constructor_id = 0x6cef8ac7
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityBotCommand.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityBotCommand(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityBotCommand#6cef8ac7 offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityCode(TLObject):
    constructor_id = 0x28a20571
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityCode.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityCode(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityCode#28a20571 offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityEmail(TLObject):
    constructor_id = 0x64e475c2
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityEmail.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityEmail(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityEmail#64e475c2 offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityHashtag(TLObject):
    constructor_id = 0x6f635b0d
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityHashtag.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityHashtag(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityHashtag#6f635b0d offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityItalic(TLObject):
    constructor_id = 0x826f8b60
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityItalic.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityItalic(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityItalic#826f8b60 offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityMention(TLObject):
    constructor_id = 0xfa04579d
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityMention.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityMention(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityMention#fa04579d offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityMentionName(TLObject):
    constructor_id = 0x352dca58
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length, user_id):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".
        :param user_id: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length
        self.user_id = user_id

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
            'user_id': self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityMentionName.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)
        writer.write_int(self.user_id)

    @staticmethod
    def empty():
        return MessageEntityMentionName(None, None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()
        self.user_id = reader.read_int()

    def __repr__(self):
        return 'messageEntityMentionName#352dca58 offset:int length:int user_id:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityPre(TLObject):
    constructor_id = 0x73924be0
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length, language):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".
        :param language: Telegram type: "string".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length
        self.language = language

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
            'language': self.language,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityPre.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)
        writer.tgwrite_string(self.language)

    @staticmethod
    def empty():
        return MessageEntityPre(None, None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()
        self.language = reader.tgread_string()

    def __repr__(self):
        return 'messageEntityPre#73924be0 offset:int length:int language:string = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityTextUrl(TLObject):
    constructor_id = 0x76a6d327
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length, url):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".
        :param url: Telegram type: "string".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length
        self.url = url

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
            'url': self.url,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityTextUrl.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)
        writer.tgwrite_string(self.url)

    @staticmethod
    def empty():
        return MessageEntityTextUrl(None, None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()
        self.url = reader.tgread_string()

    def __repr__(self):
        return 'messageEntityTextUrl#76a6d327 offset:int length:int url:string = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityUnknown(TLObject):
    constructor_id = 0xbb92ba95
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityUnknown.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityUnknown(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityUnknown#bb92ba95 offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageEntityUrl(TLObject):
    constructor_id = 0x6ed02538
    subclass_of_id = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param offset: Telegram type: "int".
        :param length: Telegram type: "int".

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def on_send(self, writer):
        writer.write_int(MessageEntityUrl.constructor_id, signed=False)
        writer.write_int(self.offset)
        writer.write_int(self.length)

    @staticmethod
    def empty():
        return MessageEntityUrl(None, None)

    def on_response(self, reader):
        self.offset = reader.read_int()
        self.length = reader.read_int()

    def __repr__(self):
        return 'messageEntityUrl#6ed02538 offset:int length:int = MessageEntity'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageFwdHeader(TLObject):
    constructor_id = 0xfadff4ac
    subclass_of_id = 0x7a286804

    def __init__(self, date, from_id=None, channel_id=None, channel_post=None, post_author=None):
        """
        :param from_id: Telegram type: "int".
        :param date: Telegram type: "date".
        :param channel_id: Telegram type: "int".
        :param channel_post: Telegram type: "int".
        :param post_author: Telegram type: "string".

        Constructor for MessageFwdHeader: Instance of MessageFwdHeader.
        """
        super().__init__()

        self.from_id = from_id
        self.date = date
        self.channel_id = channel_id
        self.channel_post = channel_post
        self.post_author = post_author

    def to_dict(self):
        return {
            'from_id': self.from_id,
            'date': self.date,
            'channel_id': self.channel_id,
            'channel_post': self.channel_post,
            'post_author': self.post_author,
        }

    def on_send(self, writer):
        writer.write_int(MessageFwdHeader.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.from_id else 0
        flags |= (1 << 1) if self.channel_id else 0
        flags |= (1 << 2) if self.channel_post else 0
        flags |= (1 << 3) if self.post_author else 0
        writer.write_int(flags)

        if self.from_id:
            writer.write_int(self.from_id)

        writer.tgwrite_date(self.date)
        if self.channel_id:
            writer.write_int(self.channel_id)

        if self.channel_post:
            writer.write_int(self.channel_post)

        if self.post_author:
            writer.tgwrite_string(self.post_author)

    @staticmethod
    def empty():
        return MessageFwdHeader(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.from_id = reader.read_int()

        self.date = reader.tgread_date()
        if (flags & (1 << 1)) != 0:
            self.channel_id = reader.read_int()

        if (flags & (1 << 2)) != 0:
            self.channel_post = reader.read_int()

        if (flags & (1 << 3)) != 0:
            self.post_author = reader.tgread_string()

    def __repr__(self):
        return 'messageFwdHeader#fadff4ac flags:# from_id:flags.0?int date:int channel_id:flags.1?int channel_post:flags.2?int post_author:flags.3?string = MessageFwdHeader'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaContact(TLObject):
    constructor_id = 0x5e7d2f39
    subclass_of_id = 0x476cbe32

    def __init__(self, phone_number, first_name, last_name, user_id):
        """
        :param phone_number: Telegram type: "string".
        :param first_name: Telegram type: "string".
        :param last_name: Telegram type: "string".
        :param user_id: Telegram type: "int".

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.user_id = user_id

    def to_dict(self):
        return {
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'user_id': self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(MessageMediaContact.constructor_id, signed=False)
        writer.tgwrite_string(self.phone_number)
        writer.tgwrite_string(self.first_name)
        writer.tgwrite_string(self.last_name)
        writer.write_int(self.user_id)

    @staticmethod
    def empty():
        return MessageMediaContact(None, None, None, None)

    def on_response(self, reader):
        self.phone_number = reader.tgread_string()
        self.first_name = reader.tgread_string()
        self.last_name = reader.tgread_string()
        self.user_id = reader.read_int()

    def __repr__(self):
        return 'messageMediaContact#5e7d2f39 phone_number:string first_name:string last_name:string user_id:int = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaDocument(TLObject):
    constructor_id = 0x7c4414d3
    subclass_of_id = 0x476cbe32

    def __init__(self, document=None, caption=None, ttl_seconds=None):
        """
        :param document: Telegram type: "Document".
        :param caption: Telegram type: "string".
        :param ttl_seconds: Telegram type: "int".

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.document = document
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self):
        return {
            'document': None if self.document is None else self.document.to_dict(),
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def on_send(self, writer):
        writer.write_int(MessageMediaDocument.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.document else 0
        flags |= (1 << 1) if self.caption else 0
        flags |= (1 << 2) if self.ttl_seconds else 0
        writer.write_int(flags)

        if self.document:
            self.document.on_send(writer)

        if self.caption:
            writer.tgwrite_string(self.caption)

        if self.ttl_seconds:
            writer.write_int(self.ttl_seconds)

    @staticmethod
    def empty():
        return MessageMediaDocument(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.document = reader.tgread_object()

        if (flags & (1 << 1)) != 0:
            self.caption = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.ttl_seconds = reader.read_int()

    def __repr__(self):
        return 'messageMediaDocument#7c4414d3 flags:# document:flags.0?Document caption:flags.1?string ttl_seconds:flags.2?int = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaEmpty(TLObject):
    constructor_id = 0x3ded6320
    subclass_of_id = 0x476cbe32

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(MessageMediaEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return MessageMediaEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messageMediaEmpty#3ded6320 = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaGame(TLObject):
    constructor_id = 0xfdb19008
    subclass_of_id = 0x476cbe32

    def __init__(self, game):
        """
        :param game: Telegram type: "Game".

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.game = game

    def to_dict(self):
        return {
            'game': None if self.game is None else self.game.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(MessageMediaGame.constructor_id, signed=False)
        self.game.on_send(writer)

    @staticmethod
    def empty():
        return MessageMediaGame(None)

    def on_response(self, reader):
        self.game = reader.tgread_object()

    def __repr__(self):
        return 'messageMediaGame#fdb19008 game:Game = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaGeo(TLObject):
    constructor_id = 0x56e0d474
    subclass_of_id = 0x476cbe32

    def __init__(self, geo):
        """
        :param geo: Telegram type: "GeoPoint".

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.geo = geo

    def to_dict(self):
        return {
            'geo': None if self.geo is None else self.geo.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(MessageMediaGeo.constructor_id, signed=False)
        self.geo.on_send(writer)

    @staticmethod
    def empty():
        return MessageMediaGeo(None)

    def on_response(self, reader):
        self.geo = reader.tgread_object()

    def __repr__(self):
        return 'messageMediaGeo#56e0d474 geo:GeoPoint = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaInvoice(TLObject):
    constructor_id = 0x84551347
    subclass_of_id = 0x476cbe32

    def __init__(self, title, description, currency, total_amount, start_param, shipping_address_requested=None, test=None, photo=None, receipt_msg_id=None):
        """
        :param shipping_address_requested: Telegram type: "true".
        :param test: Telegram type: "true".
        :param title: Telegram type: "string".
        :param description: Telegram type: "string".
        :param photo: Telegram type: "WebDocument".
        :param receipt_msg_id: Telegram type: "int".
        :param currency: Telegram type: "string".
        :param total_amount: Telegram type: "long".
        :param start_param: Telegram type: "string".

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.shipping_address_requested = shipping_address_requested
        self.test = test
        self.title = title
        self.description = description
        self.photo = photo
        self.receipt_msg_id = receipt_msg_id
        self.currency = currency
        self.total_amount = total_amount
        self.start_param = start_param

    def to_dict(self):
        return {
            'shipping_address_requested': self.shipping_address_requested,
            'test': self.test,
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'receipt_msg_id': self.receipt_msg_id,
            'currency': self.currency,
            'total_amount': self.total_amount,
            'start_param': self.start_param,
        }

    def on_send(self, writer):
        writer.write_int(MessageMediaInvoice.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.shipping_address_requested else 0
        flags |= (1 << 3) if self.test else 0
        flags |= (1 << 0) if self.photo else 0
        flags |= (1 << 2) if self.receipt_msg_id else 0
        writer.write_int(flags)

        writer.tgwrite_string(self.title)
        writer.tgwrite_string(self.description)
        if self.photo:
            self.photo.on_send(writer)

        if self.receipt_msg_id:
            writer.write_int(self.receipt_msg_id)

        writer.tgwrite_string(self.currency)
        writer.write_long(self.total_amount)
        writer.tgwrite_string(self.start_param)

    @staticmethod
    def empty():
        return MessageMediaInvoice(None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.shipping_address_requested = True

        if (flags & (1 << 3)) != 0:
            self.test = True

        self.title = reader.tgread_string()
        self.description = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.photo = reader.tgread_object()

        if (flags & (1 << 2)) != 0:
            self.receipt_msg_id = reader.read_int()

        self.currency = reader.tgread_string()
        self.total_amount = reader.read_long()
        self.start_param = reader.tgread_string()

    def __repr__(self):
        return 'messageMediaInvoice#84551347 flags:# shipping_address_requested:flags.1?true test:flags.3?true title:string description:string photo:flags.0?WebDocument receipt_msg_id:flags.2?int currency:string total_amount:long start_param:string = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaPhoto(TLObject):
    constructor_id = 0xb5223b0f
    subclass_of_id = 0x476cbe32

    def __init__(self, photo=None, caption=None, ttl_seconds=None):
        """
        :param photo: Telegram type: "Photo".
        :param caption: Telegram type: "string".
        :param ttl_seconds: Telegram type: "int".

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.photo = photo
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self):
        return {
            'photo': None if self.photo is None else self.photo.to_dict(),
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def on_send(self, writer):
        writer.write_int(MessageMediaPhoto.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.photo else 0
        flags |= (1 << 1) if self.caption else 0
        flags |= (1 << 2) if self.ttl_seconds else 0
        writer.write_int(flags)

        if self.photo:
            self.photo.on_send(writer)

        if self.caption:
            writer.tgwrite_string(self.caption)

        if self.ttl_seconds:
            writer.write_int(self.ttl_seconds)

    @staticmethod
    def empty():
        return MessageMediaPhoto(None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.photo = reader.tgread_object()

        if (flags & (1 << 1)) != 0:
            self.caption = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.ttl_seconds = reader.read_int()

    def __repr__(self):
        return 'messageMediaPhoto#b5223b0f flags:# photo:flags.0?Photo caption:flags.1?string ttl_seconds:flags.2?int = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaUnsupported(TLObject):
    constructor_id = 0x9f84f49e
    subclass_of_id = 0x476cbe32

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(MessageMediaUnsupported.constructor_id, signed=False)

    @staticmethod
    def empty():
        return MessageMediaUnsupported()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'messageMediaUnsupported#9f84f49e = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaVenue(TLObject):
    constructor_id = 0x7912b71f
    subclass_of_id = 0x476cbe32

    def __init__(self, geo, title, address, provider, venue_id):
        """
        :param geo: Telegram type: "GeoPoint".
        :param title: Telegram type: "string".
        :param address: Telegram type: "string".
        :param provider: Telegram type: "string".
        :param venue_id: Telegram type: "string".

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.geo = geo
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id

    def to_dict(self):
        return {
            'geo': None if self.geo is None else self.geo.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
        }

    def on_send(self, writer):
        writer.write_int(MessageMediaVenue.constructor_id, signed=False)
        self.geo.on_send(writer)
        writer.tgwrite_string(self.title)
        writer.tgwrite_string(self.address)
        writer.tgwrite_string(self.provider)
        writer.tgwrite_string(self.venue_id)

    @staticmethod
    def empty():
        return MessageMediaVenue(None, None, None, None, None)

    def on_response(self, reader):
        self.geo = reader.tgread_object()
        self.title = reader.tgread_string()
        self.address = reader.tgread_string()
        self.provider = reader.tgread_string()
        self.venue_id = reader.tgread_string()

    def __repr__(self):
        return 'messageMediaVenue#7912b71f geo:GeoPoint title:string address:string provider:string venue_id:string = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageMediaWebPage(TLObject):
    constructor_id = 0xa32dd600
    subclass_of_id = 0x476cbe32

    def __init__(self, webpage):
        """
        :param webpage: Telegram type: "WebPage".

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.webpage = webpage

    def to_dict(self):
        return {
            'webpage': None if self.webpage is None else self.webpage.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(MessageMediaWebPage.constructor_id, signed=False)
        self.webpage.on_send(writer)

    @staticmethod
    def empty():
        return MessageMediaWebPage(None)

    def on_response(self, reader):
        self.webpage = reader.tgread_object()

    def __repr__(self):
        return 'messageMediaWebPage#a32dd600 webpage:WebPage = MessageMedia'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageRange(TLObject):
    constructor_id = 0xae30253
    subclass_of_id = 0xbec74577

    def __init__(self, min_id, max_id):
        """
        :param min_id: Telegram type: "int".
        :param max_id: Telegram type: "int".

        Constructor for MessageRange: Instance of MessageRange.
        """
        super().__init__()

        self.min_id = min_id
        self.max_id = max_id

    def to_dict(self):
        return {
            'min_id': self.min_id,
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(MessageRange.constructor_id, signed=False)
        writer.write_int(self.min_id)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return MessageRange(None, None)

    def on_response(self, reader):
        self.min_id = reader.read_int()
        self.max_id = reader.read_int()

    def __repr__(self):
        return 'messageRange#0ae30253 min_id:int max_id:int = MessageRange'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MessageService(TLObject):
    constructor_id = 0x9e19a1f6
    subclass_of_id = 0x790009e3

    def __init__(self, id, to_id, date, action, out=None, mentioned=None, media_unread=None, silent=None, post=None, from_id=None, reply_to_msg_id=None):
        """
        :param out: Telegram type: "true".
        :param mentioned: Telegram type: "true".
        :param media_unread: Telegram type: "true".
        :param silent: Telegram type: "true".
        :param post: Telegram type: "true".
        :param id: Telegram type: "int".
        :param from_id: Telegram type: "int".
        :param to_id: Telegram type: "Peer".
        :param reply_to_msg_id: Telegram type: "int".
        :param date: Telegram type: "date".
        :param action: Telegram type: "MessageAction".

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.post = post
        self.id = id
        self.from_id = from_id
        self.to_id = to_id
        self.reply_to_msg_id = reply_to_msg_id
        self.date = date
        self.action = action

    def to_dict(self):
        return {
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'post': self.post,
            'id': self.id,
            'from_id': self.from_id,
            'to_id': None if self.to_id is None else self.to_id.to_dict(),
            'reply_to_msg_id': self.reply_to_msg_id,
            'date': self.date,
            'action': None if self.action is None else self.action.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(MessageService.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.out else 0
        flags |= (1 << 4) if self.mentioned else 0
        flags |= (1 << 5) if self.media_unread else 0
        flags |= (1 << 13) if self.silent else 0
        flags |= (1 << 14) if self.post else 0
        flags |= (1 << 8) if self.from_id else 0
        flags |= (1 << 3) if self.reply_to_msg_id else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        if self.from_id:
            writer.write_int(self.from_id)

        self.to_id.on_send(writer)
        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        writer.tgwrite_date(self.date)
        self.action.on_send(writer)

    @staticmethod
    def empty():
        return MessageService(None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.out = True

        if (flags & (1 << 4)) != 0:
            self.mentioned = True

        if (flags & (1 << 5)) != 0:
            self.media_unread = True

        if (flags & (1 << 13)) != 0:
            self.silent = True

        if (flags & (1 << 14)) != 0:
            self.post = True

        self.id = reader.read_int()
        if (flags & (1 << 8)) != 0:
            self.from_id = reader.read_int()

        self.to_id = reader.tgread_object()
        if (flags & (1 << 3)) != 0:
            self.reply_to_msg_id = reader.read_int()

        self.date = reader.tgread_date()
        self.action = reader.tgread_object()

    def __repr__(self):
        return 'messageService#9e19a1f6 flags:# out:flags.1?true mentioned:flags.4?true media_unread:flags.5?true silent:flags.13?true post:flags.14?true id:int from_id:flags.8?int to_id:Peer reply_to_msg_id:flags.3?int date:int action:MessageAction = Message'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MsgDetailedInfo(TLObject):
    constructor_id = 0x276d3ec6
    subclass_of_id = 0x5f32d5ee

    def __init__(self, msg_id, answer_msg_id, bytes, status):
        """
        :param msg_id: Telegram type: "long".
        :param answer_msg_id: Telegram type: "long".
        :param bytes: Telegram type: "int".
        :param status: Telegram type: "int".

        Constructor for MsgDetailedInfo: Instance of either MsgDetailedInfo, MsgNewDetailedInfo.
        """
        super().__init__()

        self.msg_id = msg_id
        self.answer_msg_id = answer_msg_id
        self.bytes = bytes
        self.status = status

    def to_dict(self):
        return {
            'msg_id': self.msg_id,
            'answer_msg_id': self.answer_msg_id,
            'bytes': self.bytes,
            'status': self.status,
        }

    def on_send(self, writer):
        writer.write_int(MsgDetailedInfo.constructor_id, signed=False)
        writer.write_long(self.msg_id)
        writer.write_long(self.answer_msg_id)
        writer.write_int(self.bytes)
        writer.write_int(self.status)

    @staticmethod
    def empty():
        return MsgDetailedInfo(None, None, None, None)

    def on_response(self, reader):
        self.msg_id = reader.read_long()
        self.answer_msg_id = reader.read_long()
        self.bytes = reader.read_int()
        self.status = reader.read_int()

    def __repr__(self):
        return 'msg_detailed_info#276d3ec6 msg_id:long answer_msg_id:long bytes:int status:int = MsgDetailedInfo'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MsgNewDetailedInfo(TLObject):
    constructor_id = 0x809db6df
    subclass_of_id = 0x5f32d5ee

    def __init__(self, answer_msg_id, bytes, status):
        """
        :param answer_msg_id: Telegram type: "long".
        :param bytes: Telegram type: "int".
        :param status: Telegram type: "int".

        Constructor for MsgDetailedInfo: Instance of either MsgDetailedInfo, MsgNewDetailedInfo.
        """
        super().__init__()

        self.answer_msg_id = answer_msg_id
        self.bytes = bytes
        self.status = status

    def to_dict(self):
        return {
            'answer_msg_id': self.answer_msg_id,
            'bytes': self.bytes,
            'status': self.status,
        }

    def on_send(self, writer):
        writer.write_int(MsgNewDetailedInfo.constructor_id, signed=False)
        writer.write_long(self.answer_msg_id)
        writer.write_int(self.bytes)
        writer.write_int(self.status)

    @staticmethod
    def empty():
        return MsgNewDetailedInfo(None, None, None)

    def on_response(self, reader):
        self.answer_msg_id = reader.read_long()
        self.bytes = reader.read_int()
        self.status = reader.read_int()

    def __repr__(self):
        return 'msg_new_detailed_info#809db6df answer_msg_id:long bytes:int status:int = MsgDetailedInfo'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MsgResendReq(TLObject):
    constructor_id = 0x7d861a08
    subclass_of_id = 0x2024514

    def __init__(self, msg_ids):
        """
        :param msg_ids: Telegram type: "long". Must be a list.

        Constructor for MsgResendReq: Instance of MsgResendReq.
        """
        super().__init__()

        self.msg_ids = msg_ids

    def to_dict(self):
        return {
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
        }

    def on_send(self, writer):
        writer.write_int(MsgResendReq.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.msg_ids))
        for _x in self.msg_ids:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return MsgResendReq(None)

    def on_response(self, reader):
        reader.read_int()
        self.msg_ids = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.msg_ids.append(_x)

    def __repr__(self):
        return 'msg_resend_req#7d861a08 msg_ids:Vector<long> = MsgResendReq'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MsgsAck(TLObject):
    constructor_id = 0x62d6b459
    subclass_of_id = 0x827677c4

    def __init__(self, msg_ids):
        """
        :param msg_ids: Telegram type: "long". Must be a list.

        Constructor for MsgsAck: Instance of MsgsAck.
        """
        super().__init__()

        self.msg_ids = msg_ids

    def to_dict(self):
        return {
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
        }

    def on_send(self, writer):
        writer.write_int(MsgsAck.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.msg_ids))
        for _x in self.msg_ids:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return MsgsAck(None)

    def on_response(self, reader):
        reader.read_int()
        self.msg_ids = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.msg_ids.append(_x)

    def __repr__(self):
        return 'msgs_ack#62d6b459 msg_ids:Vector<long> = MsgsAck'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MsgsAllInfo(TLObject):
    constructor_id = 0x8cc0d131
    subclass_of_id = 0xfa8fcb54

    def __init__(self, msg_ids, info):
        """
        :param msg_ids: Telegram type: "long". Must be a list.
        :param info: Telegram type: "string".

        Constructor for MsgsAllInfo: Instance of MsgsAllInfo.
        """
        super().__init__()

        self.msg_ids = msg_ids
        self.info = info

    def to_dict(self):
        return {
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
            'info': self.info,
        }

    def on_send(self, writer):
        writer.write_int(MsgsAllInfo.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.msg_ids))
        for _x in self.msg_ids:
            writer.write_long(_x)

        writer.tgwrite_string(self.info)

    @staticmethod
    def empty():
        return MsgsAllInfo(None, None)

    def on_response(self, reader):
        reader.read_int()
        self.msg_ids = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.msg_ids.append(_x)

        self.info = reader.tgread_string()

    def __repr__(self):
        return 'msgs_all_info#8cc0d131 msg_ids:Vector<long> info:string = MsgsAllInfo'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MsgsStateInfo(TLObject):
    constructor_id = 0x4deb57d
    subclass_of_id = 0x70a0a64

    def __init__(self, req_msg_id, info):
        """
        :param req_msg_id: Telegram type: "long".
        :param info: Telegram type: "string".

        Constructor for MsgsStateInfo: Instance of MsgsStateInfo.
        """
        super().__init__()

        self.req_msg_id = req_msg_id
        self.info = info

    def to_dict(self):
        return {
            'req_msg_id': self.req_msg_id,
            'info': self.info,
        }

    def on_send(self, writer):
        writer.write_int(MsgsStateInfo.constructor_id, signed=False)
        writer.write_long(self.req_msg_id)
        writer.tgwrite_string(self.info)

    @staticmethod
    def empty():
        return MsgsStateInfo(None, None)

    def on_response(self, reader):
        self.req_msg_id = reader.read_long()
        self.info = reader.tgread_string()

    def __repr__(self):
        return 'msgs_state_info#04deb57d req_msg_id:long info:string = MsgsStateInfo'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class MsgsStateReq(TLObject):
    constructor_id = 0xda69fb52
    subclass_of_id = 0x18f01dd0

    def __init__(self, msg_ids):
        """
        :param msg_ids: Telegram type: "long". Must be a list.

        Constructor for MsgsStateReq: Instance of MsgsStateReq.
        """
        super().__init__()

        self.msg_ids = msg_ids

    def to_dict(self):
        return {
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
        }

    def on_send(self, writer):
        writer.write_int(MsgsStateReq.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.msg_ids))
        for _x in self.msg_ids:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return MsgsStateReq(None)

    def on_response(self, reader):
        reader.read_int()
        self.msg_ids = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.msg_ids.append(_x)

    def __repr__(self):
        return 'msgs_state_req#da69fb52 msg_ids:Vector<long> = MsgsStateReq'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class NearestDc(TLObject):
    constructor_id = 0x8e1a1775
    subclass_of_id = 0x3877045f

    def __init__(self, country, this_dc, nearest_dc):
        """
        :param country: Telegram type: "string".
        :param this_dc: Telegram type: "int".
        :param nearest_dc: Telegram type: "int".

        Constructor for NearestDc: Instance of NearestDc.
        """
        super().__init__()

        self.country = country
        self.this_dc = this_dc
        self.nearest_dc = nearest_dc

    def to_dict(self):
        return {
            'country': self.country,
            'this_dc': self.this_dc,
            'nearest_dc': self.nearest_dc,
        }

    def on_send(self, writer):
        writer.write_int(NearestDc.constructor_id, signed=False)
        writer.tgwrite_string(self.country)
        writer.write_int(self.this_dc)
        writer.write_int(self.nearest_dc)

    @staticmethod
    def empty():
        return NearestDc(None, None, None)

    def on_response(self, reader):
        self.country = reader.tgread_string()
        self.this_dc = reader.read_int()
        self.nearest_dc = reader.read_int()

    def __repr__(self):
        return 'nearestDc#8e1a1775 country:string this_dc:int nearest_dc:int = NearestDc'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class NewSessionCreated(TLObject):
    constructor_id = 0x9ec20908
    subclass_of_id = 0x510d3031

    def __init__(self, first_msg_id, unique_id, server_salt):
        """
        :param first_msg_id: Telegram type: "long".
        :param unique_id: Telegram type: "long".
        :param server_salt: Telegram type: "long".

        Constructor for NewSession: Instance of NewSessionCreated.
        """
        super().__init__()

        self.first_msg_id = first_msg_id
        self.unique_id = unique_id
        self.server_salt = server_salt

    def to_dict(self):
        return {
            'first_msg_id': self.first_msg_id,
            'unique_id': self.unique_id,
            'server_salt': self.server_salt,
        }

    def on_send(self, writer):
        writer.write_int(NewSessionCreated.constructor_id, signed=False)
        writer.write_long(self.first_msg_id)
        writer.write_long(self.unique_id)
        writer.write_long(self.server_salt)

    @staticmethod
    def empty():
        return NewSessionCreated(None, None, None)

    def on_response(self, reader):
        self.first_msg_id = reader.read_long()
        self.unique_id = reader.read_long()
        self.server_salt = reader.read_long()

    def __repr__(self):
        return 'new_session_created#9ec20908 first_msg_id:long unique_id:long server_salt:long = NewSession'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class NotifyAll(TLObject):
    constructor_id = 0x74d07c60
    subclass_of_id = 0xdfe8602e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(NotifyAll.constructor_id, signed=False)

    @staticmethod
    def empty():
        return NotifyAll()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'notifyAll#74d07c60 = NotifyPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class NotifyChats(TLObject):
    constructor_id = 0xc007cec3
    subclass_of_id = 0xdfe8602e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(NotifyChats.constructor_id, signed=False)

    @staticmethod
    def empty():
        return NotifyChats()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'notifyChats#c007cec3 = NotifyPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class NotifyPeer(TLObject):
    constructor_id = 0x9fd40bd8
    subclass_of_id = 0xdfe8602e

    def __init__(self, peer):
        """
        :param peer: Telegram type: "Peer".

        Constructor for NotifyPeer: Instance of either NotifyPeer, NotifyUsers, NotifyChats, NotifyAll.
        """
        super().__init__()

        self.peer = peer

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(NotifyPeer.constructor_id, signed=False)
        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return NotifyPeer(None)

    def on_response(self, reader):
        self.peer = reader.tgread_object()

    def __repr__(self):
        return 'notifyPeer#9fd40bd8 peer:Peer = NotifyPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class NotifyUsers(TLObject):
    constructor_id = 0xb4c83b4c
    subclass_of_id = 0xdfe8602e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(NotifyUsers.constructor_id, signed=False)

    @staticmethod
    def empty():
        return NotifyUsers()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'notifyUsers#b4c83b4c = NotifyPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Null(TLObject):
    constructor_id = 0x56730bcc
    subclass_of_id = 0x85f95371

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(Null.constructor_id, signed=False)

    @staticmethod
    def empty():
        return Null()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'null#56730bcc = Null'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PQInnerData(TLObject):
    constructor_id = 0x83c95aec
    subclass_of_id = 0x41701377

    def __init__(self, pq, p, q, nonce, server_nonce, new_nonce):
        """
        :param pq: Telegram type: "string".
        :param p: Telegram type: "string".
        :param q: Telegram type: "string".
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param new_nonce: Telegram type: "int256".

        Constructor for P_Q_inner_data: Instance of PQInnerData.
        """
        super().__init__()

        self.pq = pq
        self.p = p
        self.q = q
        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce = new_nonce

    def to_dict(self):
        return {
            'pq': self.pq,
            'p': self.p,
            'q': self.q,
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce': self.new_nonce,
        }

    def on_send(self, writer):
        writer.write_int(PQInnerData.constructor_id, signed=False)
        writer.tgwrite_string(self.pq)
        writer.tgwrite_string(self.p)
        writer.tgwrite_string(self.q)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.write_large_int(self.new_nonce, bits=256)

    @staticmethod
    def empty():
        return PQInnerData(None, None, None, None, None, None)

    def on_response(self, reader):
        self.pq = reader.tgread_string()
        self.p = reader.tgread_string()
        self.q = reader.tgread_string()
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.new_nonce = reader.read_large_int(bits=256)

    def __repr__(self):
        return 'p_q_inner_data#83c95aec pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 = P_Q_inner_data'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockAnchor(TLObject):
    constructor_id = 0xce0d37b0
    subclass_of_id = 0x1aca5644

    def __init__(self, name):
        """
        :param name: Telegram type: "string".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.name = name

    def to_dict(self):
        return {
            'name': self.name,
        }

    def on_send(self, writer):
        writer.write_int(PageBlockAnchor.constructor_id, signed=False)
        writer.tgwrite_string(self.name)

    @staticmethod
    def empty():
        return PageBlockAnchor(None)

    def on_response(self, reader):
        self.name = reader.tgread_string()

    def __repr__(self):
        return 'pageBlockAnchor#ce0d37b0 name:string = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockAudio(TLObject):
    constructor_id = 0x31b81a7f
    subclass_of_id = 0x1aca5644

    def __init__(self, audio_id, caption):
        """
        :param audio_id: Telegram type: "long".
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.audio_id = audio_id
        self.caption = caption

    def to_dict(self):
        return {
            'audio_id': self.audio_id,
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockAudio.constructor_id, signed=False)
        writer.write_long(self.audio_id)
        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockAudio(None, None)

    def on_response(self, reader):
        self.audio_id = reader.read_long()
        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockAudio#31b81a7f audio_id:long caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockAuthorDate(TLObject):
    constructor_id = 0xbaafe5e0
    subclass_of_id = 0x1aca5644

    def __init__(self, author, published_date):
        """
        :param author: Telegram type: "RichText".
        :param published_date: Telegram type: "date".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.author = author
        self.published_date = published_date

    def to_dict(self):
        return {
            'author': None if self.author is None else self.author.to_dict(),
            'published_date': self.published_date,
        }

    def on_send(self, writer):
        writer.write_int(PageBlockAuthorDate.constructor_id, signed=False)
        self.author.on_send(writer)
        writer.tgwrite_date(self.published_date)

    @staticmethod
    def empty():
        return PageBlockAuthorDate(None, None)

    def on_response(self, reader):
        self.author = reader.tgread_object()
        self.published_date = reader.tgread_date()

    def __repr__(self):
        return 'pageBlockAuthorDate#baafe5e0 author:RichText published_date:int = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockBlockquote(TLObject):
    constructor_id = 0x263d7c26
    subclass_of_id = 0x1aca5644

    def __init__(self, text, caption):
        """
        :param text: Telegram type: "RichText".
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text
        self.caption = caption

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockBlockquote.constructor_id, signed=False)
        self.text.on_send(writer)
        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockBlockquote(None, None)

    def on_response(self, reader):
        self.text = reader.tgread_object()
        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockBlockquote#263d7c26 text:RichText caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockChannel(TLObject):
    constructor_id = 0xef1751b5
    subclass_of_id = 0x1aca5644

    def __init__(self, channel):
        """
        :param channel: Telegram type: "Chat".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.channel = channel

    def to_dict(self):
        return {
            'channel': None if self.channel is None else self.channel.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockChannel.constructor_id, signed=False)
        self.channel.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockChannel(None)

    def on_response(self, reader):
        self.channel = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockChannel#ef1751b5 channel:Chat = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockCollage(TLObject):
    constructor_id = 0x8b31c4f
    subclass_of_id = 0x1aca5644

    def __init__(self, items, caption):
        """
        :param items: Telegram type: "PageBlock". Must be a list.
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.items = items
        self.caption = caption

    def to_dict(self):
        return {
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items],
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockCollage.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.items))
        for _x in self.items:
            _x.on_send(writer)

        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockCollage(None, None)

    def on_response(self, reader):
        reader.read_int()
        self.items = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.items.append(_x)

        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockCollage#08b31c4f items:Vector<PageBlock> caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockCover(TLObject):
    constructor_id = 0x39f23300
    subclass_of_id = 0x1aca5644

    def __init__(self, cover):
        """
        :param cover: Telegram type: "PageBlock".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.cover = cover

    def to_dict(self):
        return {
            'cover': None if self.cover is None else self.cover.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockCover.constructor_id, signed=False)
        self.cover.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockCover(None)

    def on_response(self, reader):
        self.cover = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockCover#39f23300 cover:PageBlock = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockDivider(TLObject):
    constructor_id = 0xdb20b188
    subclass_of_id = 0x1aca5644

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PageBlockDivider.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PageBlockDivider()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'pageBlockDivider#db20b188 = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockEmbed(TLObject):
    constructor_id = 0xcde200d1
    subclass_of_id = 0x1aca5644

    def __init__(self, w, h, caption, full_width=None, allow_scrolling=None, url=None, html=None, poster_photo_id=None):
        """
        :param full_width: Telegram type: "true".
        :param allow_scrolling: Telegram type: "true".
        :param url: Telegram type: "string".
        :param html: Telegram type: "string".
        :param poster_photo_id: Telegram type: "long".
        :param w: Telegram type: "int".
        :param h: Telegram type: "int".
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.full_width = full_width
        self.allow_scrolling = allow_scrolling
        self.url = url
        self.html = html
        self.poster_photo_id = poster_photo_id
        self.w = w
        self.h = h
        self.caption = caption

    def to_dict(self):
        return {
            'full_width': self.full_width,
            'allow_scrolling': self.allow_scrolling,
            'url': self.url,
            'html': self.html,
            'poster_photo_id': self.poster_photo_id,
            'w': self.w,
            'h': self.h,
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockEmbed.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.full_width else 0
        flags |= (1 << 3) if self.allow_scrolling else 0
        flags |= (1 << 1) if self.url else 0
        flags |= (1 << 2) if self.html else 0
        flags |= (1 << 4) if self.poster_photo_id else 0
        writer.write_int(flags)

        if self.url:
            writer.tgwrite_string(self.url)

        if self.html:
            writer.tgwrite_string(self.html)

        if self.poster_photo_id:
            writer.write_long(self.poster_photo_id)

        writer.write_int(self.w)
        writer.write_int(self.h)
        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockEmbed(None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.full_width = True

        if (flags & (1 << 3)) != 0:
            self.allow_scrolling = True

        if (flags & (1 << 1)) != 0:
            self.url = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.html = reader.tgread_string()

        if (flags & (1 << 4)) != 0:
            self.poster_photo_id = reader.read_long()

        self.w = reader.read_int()
        self.h = reader.read_int()
        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockEmbed#cde200d1 flags:# full_width:flags.0?true allow_scrolling:flags.3?true url:flags.1?string html:flags.2?string poster_photo_id:flags.4?long w:int h:int caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockEmbedPost(TLObject):
    constructor_id = 0x292c7be9
    subclass_of_id = 0x1aca5644

    def __init__(self, url, webpage_id, author_photo_id, author, date, blocks, caption):
        """
        :param url: Telegram type: "string".
        :param webpage_id: Telegram type: "long".
        :param author_photo_id: Telegram type: "long".
        :param author: Telegram type: "string".
        :param date: Telegram type: "date".
        :param blocks: Telegram type: "PageBlock". Must be a list.
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.url = url
        self.webpage_id = webpage_id
        self.author_photo_id = author_photo_id
        self.author = author
        self.date = date
        self.blocks = blocks
        self.caption = caption

    def to_dict(self):
        return {
            'url': self.url,
            'webpage_id': self.webpage_id,
            'author_photo_id': self.author_photo_id,
            'author': self.author,
            'date': self.date,
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockEmbedPost.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        writer.write_long(self.webpage_id)
        writer.write_long(self.author_photo_id)
        writer.tgwrite_string(self.author)
        writer.tgwrite_date(self.date)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.blocks))
        for _x in self.blocks:
            _x.on_send(writer)

        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockEmbedPost(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.url = reader.tgread_string()
        self.webpage_id = reader.read_long()
        self.author_photo_id = reader.read_long()
        self.author = reader.tgread_string()
        self.date = reader.tgread_date()
        reader.read_int()
        self.blocks = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.blocks.append(_x)

        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockEmbedPost#292c7be9 url:string webpage_id:long author_photo_id:long author:string date:int blocks:Vector<PageBlock> caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockFooter(TLObject):
    constructor_id = 0x48870999
    subclass_of_id = 0x1aca5644

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockFooter.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockFooter(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockFooter#48870999 text:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockHeader(TLObject):
    constructor_id = 0xbfd064ec
    subclass_of_id = 0x1aca5644

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockHeader.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockHeader(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockHeader#bfd064ec text:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockList(TLObject):
    constructor_id = 0x3a58c7f4
    subclass_of_id = 0x1aca5644

    def __init__(self, ordered, items):
        """
        :param ordered: Telegram type: "Bool".
        :param items: Telegram type: "RichText". Must be a list.

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.ordered = ordered
        self.items = items

    def to_dict(self):
        return {
            'ordered': self.ordered,
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items],
        }

    def on_send(self, writer):
        writer.write_int(PageBlockList.constructor_id, signed=False)
        writer.tgwrite_bool(self.ordered)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.items))
        for _x in self.items:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockList(None, None)

    def on_response(self, reader):
        self.ordered = reader.tgread_bool()
        reader.read_int()
        self.items = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.items.append(_x)

    def __repr__(self):
        return 'pageBlockList#3a58c7f4 ordered:Bool items:Vector<RichText> = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockParagraph(TLObject):
    constructor_id = 0x467a0766
    subclass_of_id = 0x1aca5644

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockParagraph.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockParagraph(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockParagraph#467a0766 text:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockPhoto(TLObject):
    constructor_id = 0xe9c69982
    subclass_of_id = 0x1aca5644

    def __init__(self, photo_id, caption):
        """
        :param photo_id: Telegram type: "long".
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.photo_id = photo_id
        self.caption = caption

    def to_dict(self):
        return {
            'photo_id': self.photo_id,
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockPhoto.constructor_id, signed=False)
        writer.write_long(self.photo_id)
        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockPhoto(None, None)

    def on_response(self, reader):
        self.photo_id = reader.read_long()
        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockPhoto#e9c69982 photo_id:long caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockPreformatted(TLObject):
    constructor_id = 0xc070d93e
    subclass_of_id = 0x1aca5644

    def __init__(self, text, language):
        """
        :param text: Telegram type: "RichText".
        :param language: Telegram type: "string".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text
        self.language = language

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
            'language': self.language,
        }

    def on_send(self, writer):
        writer.write_int(PageBlockPreformatted.constructor_id, signed=False)
        self.text.on_send(writer)
        writer.tgwrite_string(self.language)

    @staticmethod
    def empty():
        return PageBlockPreformatted(None, None)

    def on_response(self, reader):
        self.text = reader.tgread_object()
        self.language = reader.tgread_string()

    def __repr__(self):
        return 'pageBlockPreformatted#c070d93e text:RichText language:string = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockPullquote(TLObject):
    constructor_id = 0x4f4456d3
    subclass_of_id = 0x1aca5644

    def __init__(self, text, caption):
        """
        :param text: Telegram type: "RichText".
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text
        self.caption = caption

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockPullquote.constructor_id, signed=False)
        self.text.on_send(writer)
        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockPullquote(None, None)

    def on_response(self, reader):
        self.text = reader.tgread_object()
        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockPullquote#4f4456d3 text:RichText caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockSlideshow(TLObject):
    constructor_id = 0x130c8963
    subclass_of_id = 0x1aca5644

    def __init__(self, items, caption):
        """
        :param items: Telegram type: "PageBlock". Must be a list.
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.items = items
        self.caption = caption

    def to_dict(self):
        return {
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items],
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockSlideshow.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.items))
        for _x in self.items:
            _x.on_send(writer)

        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockSlideshow(None, None)

    def on_response(self, reader):
        reader.read_int()
        self.items = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.items.append(_x)

        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockSlideshow#130c8963 items:Vector<PageBlock> caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockSubheader(TLObject):
    constructor_id = 0xf12bb6e1
    subclass_of_id = 0x1aca5644

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockSubheader.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockSubheader(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockSubheader#f12bb6e1 text:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockSubtitle(TLObject):
    constructor_id = 0x8ffa9a1f
    subclass_of_id = 0x1aca5644

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockSubtitle.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockSubtitle(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockSubtitle#8ffa9a1f text:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockTitle(TLObject):
    constructor_id = 0x70abc3fd
    subclass_of_id = 0x1aca5644

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockTitle.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockTitle(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockTitle#70abc3fd text:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockUnsupported(TLObject):
    constructor_id = 0x13567e8a
    subclass_of_id = 0x1aca5644

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PageBlockUnsupported.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PageBlockUnsupported()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'pageBlockUnsupported#13567e8a = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageBlockVideo(TLObject):
    constructor_id = 0xd9d71866
    subclass_of_id = 0x1aca5644

    def __init__(self, video_id, caption, autoplay=None, loop=None):
        """
        :param autoplay: Telegram type: "true".
        :param loop: Telegram type: "true".
        :param video_id: Telegram type: "long".
        :param caption: Telegram type: "RichText".

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.autoplay = autoplay
        self.loop = loop
        self.video_id = video_id
        self.caption = caption

    def to_dict(self):
        return {
            'autoplay': self.autoplay,
            'loop': self.loop,
            'video_id': self.video_id,
            'caption': None if self.caption is None else self.caption.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PageBlockVideo.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.autoplay else 0
        flags |= (1 << 1) if self.loop else 0
        writer.write_int(flags)

        writer.write_long(self.video_id)
        self.caption.on_send(writer)

    @staticmethod
    def empty():
        return PageBlockVideo(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.autoplay = True

        if (flags & (1 << 1)) != 0:
            self.loop = True

        self.video_id = reader.read_long()
        self.caption = reader.tgread_object()

    def __repr__(self):
        return 'pageBlockVideo#d9d71866 flags:# autoplay:flags.0?true loop:flags.1?true video_id:long caption:RichText = PageBlock'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PageFull(TLObject):
    constructor_id = 0x556ec7aa
    subclass_of_id = 0xb438191e

    def __init__(self, blocks, photos, documents):
        """
        :param blocks: Telegram type: "PageBlock". Must be a list.
        :param photos: Telegram type: "Photo". Must be a list.
        :param documents: Telegram type: "Document". Must be a list.

        Constructor for Page: Instance of either PagePart, PageFull.
        """
        super().__init__()

        self.blocks = blocks
        self.photos = photos
        self.documents = documents

    def to_dict(self):
        return {
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'photos': [] if self.photos is None else [None if x is None else x.to_dict() for x in self.photos],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents],
        }

    def on_send(self, writer):
        writer.write_int(PageFull.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.blocks))
        for _x in self.blocks:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.photos))
        for _x in self.photos:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.documents))
        for _x in self.documents:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return PageFull(None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.blocks = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.blocks.append(_x)

        reader.read_int()
        self.photos = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.photos.append(_x)

        reader.read_int()
        self.documents = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.documents.append(_x)

    def __repr__(self):
        return 'pageFull#556ec7aa blocks:Vector<PageBlock> photos:Vector<Photo> documents:Vector<Document> = Page'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PagePart(TLObject):
    constructor_id = 0x8e3f9ebe
    subclass_of_id = 0xb438191e

    def __init__(self, blocks, photos, documents):
        """
        :param blocks: Telegram type: "PageBlock". Must be a list.
        :param photos: Telegram type: "Photo". Must be a list.
        :param documents: Telegram type: "Document". Must be a list.

        Constructor for Page: Instance of either PagePart, PageFull.
        """
        super().__init__()

        self.blocks = blocks
        self.photos = photos
        self.documents = documents

    def to_dict(self):
        return {
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'photos': [] if self.photos is None else [None if x is None else x.to_dict() for x in self.photos],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents],
        }

    def on_send(self, writer):
        writer.write_int(PagePart.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.blocks))
        for _x in self.blocks:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.photos))
        for _x in self.photos:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.documents))
        for _x in self.documents:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return PagePart(None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.blocks = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.blocks.append(_x)

        reader.read_int()
        self.photos = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.photos.append(_x)

        reader.read_int()
        self.documents = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.documents.append(_x)

    def __repr__(self):
        return 'pagePart#8e3f9ebe blocks:Vector<PageBlock> photos:Vector<Photo> documents:Vector<Document> = Page'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PaymentCharge(TLObject):
    constructor_id = 0xea02c27e
    subclass_of_id = 0x3cc830d9

    def __init__(self, id, provider_charge_id):
        """
        :param id: Telegram type: "string".
        :param provider_charge_id: Telegram type: "string".

        Constructor for PaymentCharge: Instance of PaymentCharge.
        """
        super().__init__()

        self.id = id
        self.provider_charge_id = provider_charge_id

    def to_dict(self):
        return {
            'id': self.id,
            'provider_charge_id': self.provider_charge_id,
        }

    def on_send(self, writer):
        writer.write_int(PaymentCharge.constructor_id, signed=False)
        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.provider_charge_id)

    @staticmethod
    def empty():
        return PaymentCharge(None, None)

    def on_response(self, reader):
        self.id = reader.tgread_string()
        self.provider_charge_id = reader.tgread_string()

    def __repr__(self):
        return 'paymentCharge#ea02c27e id:string provider_charge_id:string = PaymentCharge'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PaymentRequestedInfo(TLObject):
    constructor_id = 0x909c3f94
    subclass_of_id = 0x8db03146

    def __init__(self, name=None, phone=None, email=None, shipping_address=None):
        """
        :param name: Telegram type: "string".
        :param phone: Telegram type: "string".
        :param email: Telegram type: "string".
        :param shipping_address: Telegram type: "PostAddress".

        Constructor for PaymentRequestedInfo: Instance of PaymentRequestedInfo.
        """
        super().__init__()

        self.name = name
        self.phone = phone
        self.email = email
        self.shipping_address = shipping_address

    def to_dict(self):
        return {
            'name': self.name,
            'phone': self.phone,
            'email': self.email,
            'shipping_address': None if self.shipping_address is None else self.shipping_address.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PaymentRequestedInfo.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.name else 0
        flags |= (1 << 1) if self.phone else 0
        flags |= (1 << 2) if self.email else 0
        flags |= (1 << 3) if self.shipping_address else 0
        writer.write_int(flags)

        if self.name:
            writer.tgwrite_string(self.name)

        if self.phone:
            writer.tgwrite_string(self.phone)

        if self.email:
            writer.tgwrite_string(self.email)

        if self.shipping_address:
            self.shipping_address.on_send(writer)

    @staticmethod
    def empty():
        return PaymentRequestedInfo(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.name = reader.tgread_string()

        if (flags & (1 << 1)) != 0:
            self.phone = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.email = reader.tgread_string()

        if (flags & (1 << 3)) != 0:
            self.shipping_address = reader.tgread_object()

    def __repr__(self):
        return 'paymentRequestedInfo#909c3f94 flags:# name:flags.0?string phone:flags.1?string email:flags.2?string shipping_address:flags.3?PostAddress = PaymentRequestedInfo'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PaymentSavedCredentialsCard(TLObject):
    constructor_id = 0xcdc27a1f
    subclass_of_id = 0xb3627ee3

    def __init__(self, id, title):
        """
        :param id: Telegram type: "string".
        :param title: Telegram type: "string".

        Constructor for PaymentSavedCredentials: Instance of PaymentSavedCredentialsCard.
        """
        super().__init__()

        self.id = id
        self.title = title

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
        }

    def on_send(self, writer):
        writer.write_int(PaymentSavedCredentialsCard.constructor_id, signed=False)
        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.title)

    @staticmethod
    def empty():
        return PaymentSavedCredentialsCard(None, None)

    def on_response(self, reader):
        self.id = reader.tgread_string()
        self.title = reader.tgread_string()

    def __repr__(self):
        return 'paymentSavedCredentialsCard#cdc27a1f id:string title:string = PaymentSavedCredentials'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerChannel(TLObject):
    constructor_id = 0xbddde532
    subclass_of_id = 0x2d45687

    def __init__(self, channel_id):
        """
        :param channel_id: Telegram type: "int".

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.channel_id = channel_id

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
        }

    def on_send(self, writer):
        writer.write_int(PeerChannel.constructor_id, signed=False)
        writer.write_int(self.channel_id)

    @staticmethod
    def empty():
        return PeerChannel(None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()

    def __repr__(self):
        return 'peerChannel#bddde532 channel_id:int = Peer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerChat(TLObject):
    constructor_id = 0xbad0e5bb
    subclass_of_id = 0x2d45687

    def __init__(self, chat_id):
        """
        :param chat_id: Telegram type: "int".

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.chat_id = chat_id

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(PeerChat.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return PeerChat(None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()

    def __repr__(self):
        return 'peerChat#bad0e5bb chat_id:int = Peer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerNotifyEventsAll(TLObject):
    constructor_id = 0x6d1ded88
    subclass_of_id = 0x180c8bc4

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PeerNotifyEventsAll.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PeerNotifyEventsAll()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'peerNotifyEventsAll#6d1ded88 = PeerNotifyEvents'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerNotifyEventsEmpty(TLObject):
    constructor_id = 0xadd53cb3
    subclass_of_id = 0x180c8bc4

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PeerNotifyEventsEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PeerNotifyEventsEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'peerNotifyEventsEmpty#add53cb3 = PeerNotifyEvents'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerNotifySettings(TLObject):
    constructor_id = 0x9acda4c0
    subclass_of_id = 0xcf20c074

    def __init__(self, mute_until, sound, show_previews=None, silent=None):
        """
        :param show_previews: Telegram type: "true".
        :param silent: Telegram type: "true".
        :param mute_until: Telegram type: "int".
        :param sound: Telegram type: "string".

        Constructor for PeerNotifySettings: Instance of either PeerNotifySettingsEmpty, PeerNotifySettings.
        """
        super().__init__()

        self.show_previews = show_previews
        self.silent = silent
        self.mute_until = mute_until
        self.sound = sound

    def to_dict(self):
        return {
            'show_previews': self.show_previews,
            'silent': self.silent,
            'mute_until': self.mute_until,
            'sound': self.sound,
        }

    def on_send(self, writer):
        writer.write_int(PeerNotifySettings.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.show_previews else 0
        flags |= (1 << 1) if self.silent else 0
        writer.write_int(flags)

        writer.write_int(self.mute_until)
        writer.tgwrite_string(self.sound)

    @staticmethod
    def empty():
        return PeerNotifySettings(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.show_previews = True

        if (flags & (1 << 1)) != 0:
            self.silent = True

        self.mute_until = reader.read_int()
        self.sound = reader.tgread_string()

    def __repr__(self):
        return 'peerNotifySettings#9acda4c0 flags:# show_previews:flags.0?true silent:flags.1?true mute_until:int sound:string = PeerNotifySettings'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerNotifySettingsEmpty(TLObject):
    constructor_id = 0x70a68512
    subclass_of_id = 0xcf20c074

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PeerNotifySettingsEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PeerNotifySettingsEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'peerNotifySettingsEmpty#70a68512 = PeerNotifySettings'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerSettings(TLObject):
    constructor_id = 0x818426cd
    subclass_of_id = 0xf6a79f84

    def __init__(self, report_spam=None):
        """
        :param report_spam: Telegram type: "true".

        Constructor for PeerSettings: Instance of PeerSettings.
        """
        super().__init__()

        self.report_spam = report_spam

    def to_dict(self):
        return {
            'report_spam': self.report_spam,
        }

    def on_send(self, writer):
        writer.write_int(PeerSettings.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.report_spam else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return PeerSettings(None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.report_spam = True

    def __repr__(self):
        return 'peerSettings#818426cd flags:# report_spam:flags.0?true = PeerSettings'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PeerUser(TLObject):
    constructor_id = 0x9db1bc6d
    subclass_of_id = 0x2d45687

    def __init__(self, user_id):
        """
        :param user_id: Telegram type: "int".

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.user_id = user_id

    def to_dict(self):
        return {
            'user_id': self.user_id,
        }

    def on_send(self, writer):
        writer.write_int(PeerUser.constructor_id, signed=False)
        writer.write_int(self.user_id)

    @staticmethod
    def empty():
        return PeerUser(None)

    def on_response(self, reader):
        self.user_id = reader.read_int()

    def __repr__(self):
        return 'peerUser#9db1bc6d user_id:int = Peer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCall(TLObject):
    constructor_id = 0xffe6ab67
    subclass_of_id = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_or_b, key_fingerprint, protocol, connection, alternative_connections, start_date):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param admin_id: Telegram type: "int".
        :param participant_id: Telegram type: "int".
        :param g_a_or_b: Telegram type: "bytes".
        :param key_fingerprint: Telegram type: "long".
        :param protocol: Telegram type: "PhoneCallProtocol".
        :param connection: Telegram type: "PhoneConnection".
        :param alternative_connections: Telegram type: "PhoneConnection". Must be a list.
        :param start_date: Telegram type: "date".

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_or_b = g_a_or_b
        self.key_fingerprint = key_fingerprint
        self.protocol = protocol
        self.connection = connection
        self.alternative_connections = alternative_connections
        self.start_date = start_date

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_or_b': self.g_a_or_b,
            'key_fingerprint': self.key_fingerprint,
            'protocol': None if self.protocol is None else self.protocol.to_dict(),
            'connection': None if self.connection is None else self.connection.to_dict(),
            'alternative_connections': [] if self.alternative_connections is None else [None if x is None else x.to_dict() for x in self.alternative_connections],
            'start_date': self.start_date,
        }

    def on_send(self, writer):
        writer.write_int(PhoneCall.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.write_int(self.admin_id)
        writer.write_int(self.participant_id)
        writer.tgwrite_bytes(self.g_a_or_b)
        writer.write_long(self.key_fingerprint)
        self.protocol.on_send(writer)
        self.connection.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.alternative_connections))
        for _x in self.alternative_connections:
            _x.on_send(writer)

        writer.tgwrite_date(self.start_date)

    @staticmethod
    def empty():
        return PhoneCall(None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        self.admin_id = reader.read_int()
        self.participant_id = reader.read_int()
        self.g_a_or_b = reader.tgread_bytes()
        self.key_fingerprint = reader.read_long()
        self.protocol = reader.tgread_object()
        self.connection = reader.tgread_object()
        reader.read_int()
        self.alternative_connections = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.alternative_connections.append(_x)

        self.start_date = reader.tgread_date()

    def __repr__(self):
        return 'phoneCall#ffe6ab67 id:long access_hash:long date:int admin_id:int participant_id:int g_a_or_b:bytes key_fingerprint:long protocol:PhoneCallProtocol connection:PhoneConnection alternative_connections:Vector<PhoneConnection> start_date:int = PhoneCall'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallAccepted(TLObject):
    constructor_id = 0x6d003d3f
    subclass_of_id = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_b, protocol):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param admin_id: Telegram type: "int".
        :param participant_id: Telegram type: "int".
        :param g_b: Telegram type: "bytes".
        :param protocol: Telegram type: "PhoneCallProtocol".

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_b = g_b
        self.protocol = protocol

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_b': self.g_b,
            'protocol': None if self.protocol is None else self.protocol.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PhoneCallAccepted.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.write_int(self.admin_id)
        writer.write_int(self.participant_id)
        writer.tgwrite_bytes(self.g_b)
        self.protocol.on_send(writer)

    @staticmethod
    def empty():
        return PhoneCallAccepted(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        self.admin_id = reader.read_int()
        self.participant_id = reader.read_int()
        self.g_b = reader.tgread_bytes()
        self.protocol = reader.tgread_object()

    def __repr__(self):
        return 'phoneCallAccepted#6d003d3f id:long access_hash:long date:int admin_id:int participant_id:int g_b:bytes protocol:PhoneCallProtocol = PhoneCall'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallDiscardReasonBusy(TLObject):
    constructor_id = 0xfaf7e8c9
    subclass_of_id = 0xd89bad3d

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PhoneCallDiscardReasonBusy.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PhoneCallDiscardReasonBusy()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'phoneCallDiscardReasonBusy#faf7e8c9 = PhoneCallDiscardReason'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallDiscardReasonDisconnect(TLObject):
    constructor_id = 0xe095c1a0
    subclass_of_id = 0xd89bad3d

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PhoneCallDiscardReasonDisconnect.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PhoneCallDiscardReasonDisconnect()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'phoneCallDiscardReasonDisconnect#e095c1a0 = PhoneCallDiscardReason'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallDiscardReasonHangup(TLObject):
    constructor_id = 0x57adc690
    subclass_of_id = 0xd89bad3d

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PhoneCallDiscardReasonHangup.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PhoneCallDiscardReasonHangup()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'phoneCallDiscardReasonHangup#57adc690 = PhoneCallDiscardReason'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallDiscardReasonMissed(TLObject):
    constructor_id = 0x85e42301
    subclass_of_id = 0xd89bad3d

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PhoneCallDiscardReasonMissed.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PhoneCallDiscardReasonMissed()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'phoneCallDiscardReasonMissed#85e42301 = PhoneCallDiscardReason'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallDiscarded(TLObject):
    constructor_id = 0x50ca4de1
    subclass_of_id = 0xc47f1bd1

    def __init__(self, id, need_rating=None, need_debug=None, reason=None, duration=None):
        """
        :param need_rating: Telegram type: "true".
        :param need_debug: Telegram type: "true".
        :param id: Telegram type: "long".
        :param reason: Telegram type: "PhoneCallDiscardReason".
        :param duration: Telegram type: "int".

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.need_rating = need_rating
        self.need_debug = need_debug
        self.id = id
        self.reason = reason
        self.duration = duration

    def to_dict(self):
        return {
            'need_rating': self.need_rating,
            'need_debug': self.need_debug,
            'id': self.id,
            'reason': None if self.reason is None else self.reason.to_dict(),
            'duration': self.duration,
        }

    def on_send(self, writer):
        writer.write_int(PhoneCallDiscarded.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.need_rating else 0
        flags |= (1 << 3) if self.need_debug else 0
        flags |= (1 << 0) if self.reason else 0
        flags |= (1 << 1) if self.duration else 0
        writer.write_int(flags)

        writer.write_long(self.id)
        if self.reason:
            self.reason.on_send(writer)

        if self.duration:
            writer.write_int(self.duration)

    @staticmethod
    def empty():
        return PhoneCallDiscarded(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 2)) != 0:
            self.need_rating = True

        if (flags & (1 << 3)) != 0:
            self.need_debug = True

        self.id = reader.read_long()
        if (flags & (1 << 0)) != 0:
            self.reason = reader.tgread_object()

        if (flags & (1 << 1)) != 0:
            self.duration = reader.read_int()

    def __repr__(self):
        return 'phoneCallDiscarded#50ca4de1 flags:# need_rating:flags.2?true need_debug:flags.3?true id:long reason:flags.0?PhoneCallDiscardReason duration:flags.1?int = PhoneCall'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallEmpty(TLObject):
    constructor_id = 0x5366c915
    subclass_of_id = 0xc47f1bd1

    def __init__(self, id):
        """
        :param id: Telegram type: "long".

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(PhoneCallEmpty.constructor_id, signed=False)
        writer.write_long(self.id)

    @staticmethod
    def empty():
        return PhoneCallEmpty(None)

    def on_response(self, reader):
        self.id = reader.read_long()

    def __repr__(self):
        return 'phoneCallEmpty#5366c915 id:long = PhoneCall'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallProtocol(TLObject):
    constructor_id = 0xa2bb35cb
    subclass_of_id = 0x783991a3

    def __init__(self, min_layer, max_layer, udp_p2p=None, udp_reflector=None):
        """
        :param udp_p2p: Telegram type: "true".
        :param udp_reflector: Telegram type: "true".
        :param min_layer: Telegram type: "int".
        :param max_layer: Telegram type: "int".

        Constructor for PhoneCallProtocol: Instance of PhoneCallProtocol.
        """
        super().__init__()

        self.udp_p2p = udp_p2p
        self.udp_reflector = udp_reflector
        self.min_layer = min_layer
        self.max_layer = max_layer

    def to_dict(self):
        return {
            'udp_p2p': self.udp_p2p,
            'udp_reflector': self.udp_reflector,
            'min_layer': self.min_layer,
            'max_layer': self.max_layer,
        }

    def on_send(self, writer):
        writer.write_int(PhoneCallProtocol.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.udp_p2p else 0
        flags |= (1 << 1) if self.udp_reflector else 0
        writer.write_int(flags)

        writer.write_int(self.min_layer)
        writer.write_int(self.max_layer)

    @staticmethod
    def empty():
        return PhoneCallProtocol(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.udp_p2p = True

        if (flags & (1 << 1)) != 0:
            self.udp_reflector = True

        self.min_layer = reader.read_int()
        self.max_layer = reader.read_int()

    def __repr__(self):
        return 'phoneCallProtocol#a2bb35cb flags:# udp_p2p:flags.0?true udp_reflector:flags.1?true min_layer:int max_layer:int = PhoneCallProtocol'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallRequested(TLObject):
    constructor_id = 0x83761ce4
    subclass_of_id = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_hash, protocol):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param admin_id: Telegram type: "int".
        :param participant_id: Telegram type: "int".
        :param g_a_hash: Telegram type: "bytes".
        :param protocol: Telegram type: "PhoneCallProtocol".

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_hash = g_a_hash
        self.protocol = protocol

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_hash': self.g_a_hash,
            'protocol': None if self.protocol is None else self.protocol.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(PhoneCallRequested.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.write_int(self.admin_id)
        writer.write_int(self.participant_id)
        writer.tgwrite_bytes(self.g_a_hash)
        self.protocol.on_send(writer)

    @staticmethod
    def empty():
        return PhoneCallRequested(None, None, None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        self.admin_id = reader.read_int()
        self.participant_id = reader.read_int()
        self.g_a_hash = reader.tgread_bytes()
        self.protocol = reader.tgread_object()

    def __repr__(self):
        return 'phoneCallRequested#83761ce4 id:long access_hash:long date:int admin_id:int participant_id:int g_a_hash:bytes protocol:PhoneCallProtocol = PhoneCall'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneCallWaiting(TLObject):
    constructor_id = 0x1b8f4ad1
    subclass_of_id = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, protocol, receive_date=None):
        """
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param admin_id: Telegram type: "int".
        :param participant_id: Telegram type: "int".
        :param protocol: Telegram type: "PhoneCallProtocol".
        :param receive_date: Telegram type: "date".

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.protocol = protocol
        self.receive_date = receive_date

    def to_dict(self):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'protocol': None if self.protocol is None else self.protocol.to_dict(),
            'receive_date': self.receive_date,
        }

    def on_send(self, writer):
        writer.write_int(PhoneCallWaiting.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.receive_date else 0
        writer.write_int(flags)

        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.write_int(self.admin_id)
        writer.write_int(self.participant_id)
        self.protocol.on_send(writer)
        if self.receive_date:
            writer.tgwrite_date(self.receive_date)

    @staticmethod
    def empty():
        return PhoneCallWaiting(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        self.admin_id = reader.read_int()
        self.participant_id = reader.read_int()
        self.protocol = reader.tgread_object()
        if (flags & (1 << 0)) != 0:
            self.receive_date = reader.tgread_date()

    def __repr__(self):
        return 'phoneCallWaiting#1b8f4ad1 flags:# id:long access_hash:long date:int admin_id:int participant_id:int protocol:PhoneCallProtocol receive_date:flags.0?int = PhoneCall'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhoneConnection(TLObject):
    constructor_id = 0x9d4c17c0
    subclass_of_id = 0xaa8de40d

    def __init__(self, id, ip, ipv6, port, peer_tag):
        """
        :param id: Telegram type: "long".
        :param ip: Telegram type: "string".
        :param ipv6: Telegram type: "string".
        :param port: Telegram type: "int".
        :param peer_tag: Telegram type: "bytes".

        Constructor for PhoneConnection: Instance of PhoneConnection.
        """
        super().__init__()

        self.id = id
        self.ip = ip
        self.ipv6 = ipv6
        self.port = port
        self.peer_tag = peer_tag

    def to_dict(self):
        return {
            'id': self.id,
            'ip': self.ip,
            'ipv6': self.ipv6,
            'port': self.port,
            'peer_tag': self.peer_tag,
        }

    def on_send(self, writer):
        writer.write_int(PhoneConnection.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.tgwrite_string(self.ip)
        writer.tgwrite_string(self.ipv6)
        writer.write_int(self.port)
        writer.tgwrite_bytes(self.peer_tag)

    @staticmethod
    def empty():
        return PhoneConnection(None, None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.ip = reader.tgread_string()
        self.ipv6 = reader.tgread_string()
        self.port = reader.read_int()
        self.peer_tag = reader.tgread_bytes()

    def __repr__(self):
        return 'phoneConnection#9d4c17c0 id:long ip:string ipv6:string port:int peer_tag:bytes = PhoneConnection'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Photo(TLObject):
    constructor_id = 0x9288dd29
    subclass_of_id = 0xd576ab1c

    def __init__(self, id, access_hash, date, sizes, has_stickers=None):
        """
        :param has_stickers: Telegram type: "true".
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param date: Telegram type: "date".
        :param sizes: Telegram type: "PhotoSize". Must be a list.

        Constructor for Photo: Instance of either PhotoEmpty, Photo.
        """
        super().__init__()

        self.has_stickers = has_stickers
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.sizes = sizes

    def to_dict(self):
        return {
            'has_stickers': self.has_stickers,
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'sizes': [] if self.sizes is None else [None if x is None else x.to_dict() for x in self.sizes],
        }

    def on_send(self, writer):
        writer.write_int(Photo.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.has_stickers else 0
        writer.write_int(flags)

        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_date(self.date)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.sizes))
        for _x in self.sizes:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return Photo(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.has_stickers = True

        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.date = reader.tgread_date()
        reader.read_int()
        self.sizes = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sizes.append(_x)

    def __repr__(self):
        return 'photo#9288dd29 flags:# has_stickers:flags.0?true id:long access_hash:long date:int sizes:Vector<PhotoSize> = Photo'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhotoCachedSize(TLObject):
    constructor_id = 0xe9a734fa
    subclass_of_id = 0x17cc29d9

    def __init__(self, type, location, w, h, bytes):
        """
        :param type: Telegram type: "string".
        :param location: Telegram type: "FileLocation".
        :param w: Telegram type: "int".
        :param h: Telegram type: "int".
        :param bytes: Telegram type: "bytes".

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type
        self.location = location
        self.w = w
        self.h = h
        self.bytes = bytes

    def to_dict(self):
        return {
            'type': self.type,
            'location': None if self.location is None else self.location.to_dict(),
            'w': self.w,
            'h': self.h,
            'bytes': self.bytes,
        }

    def on_send(self, writer):
        writer.write_int(PhotoCachedSize.constructor_id, signed=False)
        writer.tgwrite_string(self.type)
        self.location.on_send(writer)
        writer.write_int(self.w)
        writer.write_int(self.h)
        writer.tgwrite_bytes(self.bytes)

    @staticmethod
    def empty():
        return PhotoCachedSize(None, None, None, None, None)

    def on_response(self, reader):
        self.type = reader.tgread_string()
        self.location = reader.tgread_object()
        self.w = reader.read_int()
        self.h = reader.read_int()
        self.bytes = reader.tgread_bytes()

    def __repr__(self):
        return 'photoCachedSize#e9a734fa type:string location:FileLocation w:int h:int bytes:bytes = PhotoSize'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhotoEmpty(TLObject):
    constructor_id = 0x2331b22d
    subclass_of_id = 0xd576ab1c

    def __init__(self, id):
        """
        :param id: Telegram type: "long".

        Constructor for Photo: Instance of either PhotoEmpty, Photo.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(PhotoEmpty.constructor_id, signed=False)
        writer.write_long(self.id)

    @staticmethod
    def empty():
        return PhotoEmpty(None)

    def on_response(self, reader):
        self.id = reader.read_long()

    def __repr__(self):
        return 'photoEmpty#2331b22d id:long = Photo'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhotoSize(TLObject):
    constructor_id = 0x77bfb61b
    subclass_of_id = 0x17cc29d9

    def __init__(self, type, location, w, h, size):
        """
        :param type: Telegram type: "string".
        :param location: Telegram type: "FileLocation".
        :param w: Telegram type: "int".
        :param h: Telegram type: "int".
        :param size: Telegram type: "int".

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type
        self.location = location
        self.w = w
        self.h = h
        self.size = size

    def to_dict(self):
        return {
            'type': self.type,
            'location': None if self.location is None else self.location.to_dict(),
            'w': self.w,
            'h': self.h,
            'size': self.size,
        }

    def on_send(self, writer):
        writer.write_int(PhotoSize.constructor_id, signed=False)
        writer.tgwrite_string(self.type)
        self.location.on_send(writer)
        writer.write_int(self.w)
        writer.write_int(self.h)
        writer.write_int(self.size)

    @staticmethod
    def empty():
        return PhotoSize(None, None, None, None, None)

    def on_response(self, reader):
        self.type = reader.tgread_string()
        self.location = reader.tgread_object()
        self.w = reader.read_int()
        self.h = reader.read_int()
        self.size = reader.read_int()

    def __repr__(self):
        return 'photoSize#77bfb61b type:string location:FileLocation w:int h:int size:int = PhotoSize'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PhotoSizeEmpty(TLObject):
    constructor_id = 0xe17e23c
    subclass_of_id = 0x17cc29d9

    def __init__(self, type):
        """
        :param type: Telegram type: "string".

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type

    def to_dict(self):
        return {
            'type': self.type,
        }

    def on_send(self, writer):
        writer.write_int(PhotoSizeEmpty.constructor_id, signed=False)
        writer.tgwrite_string(self.type)

    @staticmethod
    def empty():
        return PhotoSizeEmpty(None)

    def on_response(self, reader):
        self.type = reader.tgread_string()

    def __repr__(self):
        return 'photoSizeEmpty#0e17e23c type:string = PhotoSize'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Pong(TLObject):
    constructor_id = 0x347773c5
    subclass_of_id = 0x816aee71

    def __init__(self, msg_id, ping_id):
        """
        :param msg_id: Telegram type: "long".
        :param ping_id: Telegram type: "long".

        Constructor for Pong: Instance of Pong.
        """
        super().__init__()

        self.msg_id = msg_id
        self.ping_id = ping_id

    def to_dict(self):
        return {
            'msg_id': self.msg_id,
            'ping_id': self.ping_id,
        }

    def on_send(self, writer):
        writer.write_int(Pong.constructor_id, signed=False)
        writer.write_long(self.msg_id)
        writer.write_long(self.ping_id)

    @staticmethod
    def empty():
        return Pong(None, None)

    def on_response(self, reader):
        self.msg_id = reader.read_long()
        self.ping_id = reader.read_long()

    def __repr__(self):
        return 'pong#347773c5 msg_id:long ping_id:long = Pong'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PopularContact(TLObject):
    constructor_id = 0x5ce14175
    subclass_of_id = 0x409255a

    def __init__(self, client_id, importers):
        """
        :param client_id: Telegram type: "long".
        :param importers: Telegram type: "int".

        Constructor for PopularContact: Instance of PopularContact.
        """
        super().__init__()

        self.client_id = client_id
        self.importers = importers

    def to_dict(self):
        return {
            'client_id': self.client_id,
            'importers': self.importers,
        }

    def on_send(self, writer):
        writer.write_int(PopularContact.constructor_id, signed=False)
        writer.write_long(self.client_id)
        writer.write_int(self.importers)

    @staticmethod
    def empty():
        return PopularContact(None, None)

    def on_response(self, reader):
        self.client_id = reader.read_long()
        self.importers = reader.read_int()

    def __repr__(self):
        return 'popularContact#5ce14175 client_id:long importers:int = PopularContact'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PostAddress(TLObject):
    constructor_id = 0x1e8caaeb
    subclass_of_id = 0x8d7eda2c

    def __init__(self, street_line1, street_line2, city, state, country_iso2, post_code):
        """
        :param street_line1: Telegram type: "string".
        :param street_line2: Telegram type: "string".
        :param city: Telegram type: "string".
        :param state: Telegram type: "string".
        :param country_iso2: Telegram type: "string".
        :param post_code: Telegram type: "string".

        Constructor for PostAddress: Instance of PostAddress.
        """
        super().__init__()

        self.street_line1 = street_line1
        self.street_line2 = street_line2
        self.city = city
        self.state = state
        self.country_iso2 = country_iso2
        self.post_code = post_code

    def to_dict(self):
        return {
            'street_line1': self.street_line1,
            'street_line2': self.street_line2,
            'city': self.city,
            'state': self.state,
            'country_iso2': self.country_iso2,
            'post_code': self.post_code,
        }

    def on_send(self, writer):
        writer.write_int(PostAddress.constructor_id, signed=False)
        writer.tgwrite_string(self.street_line1)
        writer.tgwrite_string(self.street_line2)
        writer.tgwrite_string(self.city)
        writer.tgwrite_string(self.state)
        writer.tgwrite_string(self.country_iso2)
        writer.tgwrite_string(self.post_code)

    @staticmethod
    def empty():
        return PostAddress(None, None, None, None, None, None)

    def on_response(self, reader):
        self.street_line1 = reader.tgread_string()
        self.street_line2 = reader.tgread_string()
        self.city = reader.tgread_string()
        self.state = reader.tgread_string()
        self.country_iso2 = reader.tgread_string()
        self.post_code = reader.tgread_string()

    def __repr__(self):
        return 'postAddress#1e8caaeb street_line1:string street_line2:string city:string state:string country_iso2:string post_code:string = PostAddress'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyKeyChatInvite(TLObject):
    constructor_id = 0x500e6dfa
    subclass_of_id = 0x824651c3

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PrivacyKeyChatInvite.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PrivacyKeyChatInvite()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'privacyKeyChatInvite#500e6dfa = PrivacyKey'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyKeyPhoneCall(TLObject):
    constructor_id = 0x3d662b7b
    subclass_of_id = 0x824651c3

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PrivacyKeyPhoneCall.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PrivacyKeyPhoneCall()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'privacyKeyPhoneCall#3d662b7b = PrivacyKey'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyKeyStatusTimestamp(TLObject):
    constructor_id = 0xbc2eab30
    subclass_of_id = 0x824651c3

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PrivacyKeyStatusTimestamp.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PrivacyKeyStatusTimestamp()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'privacyKeyStatusTimestamp#bc2eab30 = PrivacyKey'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyValueAllowAll(TLObject):
    constructor_id = 0x65427b82
    subclass_of_id = 0xebb7f270

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PrivacyValueAllowAll.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PrivacyValueAllowAll()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'privacyValueAllowAll#65427b82 = PrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyValueAllowContacts(TLObject):
    constructor_id = 0xfffe1bac
    subclass_of_id = 0xebb7f270

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PrivacyValueAllowContacts.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PrivacyValueAllowContacts()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'privacyValueAllowContacts#fffe1bac = PrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyValueAllowUsers(TLObject):
    constructor_id = 0x4d5bbe0c
    subclass_of_id = 0xebb7f270

    def __init__(self, users):
        """
        :param users: Telegram type: "int". Must be a list.

        Constructor for PrivacyRule: Instance of either PrivacyValueAllowContacts, PrivacyValueAllowAll, PrivacyValueAllowUsers, PrivacyValueDisallowContacts, PrivacyValueDisallowAll, PrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users

    def to_dict(self):
        return {
            'users': [] if self.users is None else self.users[:],
        }

    def on_send(self, writer):
        writer.write_int(PrivacyValueAllowUsers.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return PrivacyValueAllowUsers(None)

    def on_response(self, reader):
        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_int()
            self.users.append(_x)

    def __repr__(self):
        return 'privacyValueAllowUsers#4d5bbe0c users:Vector<int> = PrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyValueDisallowAll(TLObject):
    constructor_id = 0x8b73e763
    subclass_of_id = 0xebb7f270

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PrivacyValueDisallowAll.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PrivacyValueDisallowAll()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'privacyValueDisallowAll#8b73e763 = PrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyValueDisallowContacts(TLObject):
    constructor_id = 0xf888fa1a
    subclass_of_id = 0xebb7f270

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(PrivacyValueDisallowContacts.constructor_id, signed=False)

    @staticmethod
    def empty():
        return PrivacyValueDisallowContacts()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'privacyValueDisallowContacts#f888fa1a = PrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class PrivacyValueDisallowUsers(TLObject):
    constructor_id = 0xc7f49b7
    subclass_of_id = 0xebb7f270

    def __init__(self, users):
        """
        :param users: Telegram type: "int". Must be a list.

        Constructor for PrivacyRule: Instance of either PrivacyValueAllowContacts, PrivacyValueAllowAll, PrivacyValueAllowUsers, PrivacyValueDisallowContacts, PrivacyValueDisallowAll, PrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users

    def to_dict(self):
        return {
            'users': [] if self.users is None else self.users[:],
        }

    def on_send(self, writer):
        writer.write_int(PrivacyValueDisallowUsers.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return PrivacyValueDisallowUsers(None)

    def on_response(self, reader):
        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_int()
            self.users.append(_x)

    def __repr__(self):
        return 'privacyValueDisallowUsers#0c7f49b7 users:Vector<int> = PrivacyRule'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReceivedNotifyMessage(TLObject):
    constructor_id = 0xa384b779
    subclass_of_id = 0xa962381e

    def __init__(self, id, flags):
        """
        :param id: Telegram type: "int".
        :param flags: Telegram type: "int".

        Constructor for ReceivedNotifyMessage: Instance of ReceivedNotifyMessage.
        """
        super().__init__()

        self.id = id
        self.flags = flags

    def to_dict(self):
        return {
            'id': self.id,
            'flags': self.flags,
        }

    def on_send(self, writer):
        writer.write_int(ReceivedNotifyMessage.constructor_id, signed=False)
        writer.write_int(self.id)
        writer.write_int(self.flags)

    @staticmethod
    def empty():
        return ReceivedNotifyMessage(None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.flags = reader.read_int()

    def __repr__(self):
        return 'receivedNotifyMessage#a384b779 id:int flags:int = ReceivedNotifyMessage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReplyInlineMarkup(TLObject):
    constructor_id = 0x48a30254
    subclass_of_id = 0xe2e10ef2

    def __init__(self, rows):
        """
        :param rows: Telegram type: "KeyboardButtonRow". Must be a list.

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.rows = rows

    def to_dict(self):
        return {
            'rows': [] if self.rows is None else [None if x is None else x.to_dict() for x in self.rows],
        }

    def on_send(self, writer):
        writer.write_int(ReplyInlineMarkup.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.rows))
        for _x in self.rows:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ReplyInlineMarkup(None)

    def on_response(self, reader):
        reader.read_int()
        self.rows = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.rows.append(_x)

    def __repr__(self):
        return 'replyInlineMarkup#48a30254 rows:Vector<KeyboardButtonRow> = ReplyMarkup'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReplyKeyboardForceReply(TLObject):
    constructor_id = 0xf4108aa0
    subclass_of_id = 0xe2e10ef2

    def __init__(self, single_use=None, selective=None):
        """
        :param single_use: Telegram type: "true".
        :param selective: Telegram type: "true".

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.single_use = single_use
        self.selective = selective

    def to_dict(self):
        return {
            'single_use': self.single_use,
            'selective': self.selective,
        }

    def on_send(self, writer):
        writer.write_int(ReplyKeyboardForceReply.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.single_use else 0
        flags |= (1 << 2) if self.selective else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return ReplyKeyboardForceReply(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.single_use = True

        if (flags & (1 << 2)) != 0:
            self.selective = True

    def __repr__(self):
        return 'replyKeyboardForceReply#f4108aa0 flags:# single_use:flags.1?true selective:flags.2?true = ReplyMarkup'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReplyKeyboardHide(TLObject):
    constructor_id = 0xa03e5b85
    subclass_of_id = 0xe2e10ef2

    def __init__(self, selective=None):
        """
        :param selective: Telegram type: "true".

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.selective = selective

    def to_dict(self):
        return {
            'selective': self.selective,
        }

    def on_send(self, writer):
        writer.write_int(ReplyKeyboardHide.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 2) if self.selective else 0
        writer.write_int(flags)


    @staticmethod
    def empty():
        return ReplyKeyboardHide(None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 2)) != 0:
            self.selective = True

    def __repr__(self):
        return 'replyKeyboardHide#a03e5b85 flags:# selective:flags.2?true = ReplyMarkup'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ReplyKeyboardMarkup(TLObject):
    constructor_id = 0x3502758c
    subclass_of_id = 0xe2e10ef2

    def __init__(self, rows, resize=None, single_use=None, selective=None):
        """
        :param resize: Telegram type: "true".
        :param single_use: Telegram type: "true".
        :param selective: Telegram type: "true".
        :param rows: Telegram type: "KeyboardButtonRow". Must be a list.

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.resize = resize
        self.single_use = single_use
        self.selective = selective
        self.rows = rows

    def to_dict(self):
        return {
            'resize': self.resize,
            'single_use': self.single_use,
            'selective': self.selective,
            'rows': [] if self.rows is None else [None if x is None else x.to_dict() for x in self.rows],
        }

    def on_send(self, writer):
        writer.write_int(ReplyKeyboardMarkup.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.resize else 0
        flags |= (1 << 1) if self.single_use else 0
        flags |= (1 << 2) if self.selective else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.rows))
        for _x in self.rows:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ReplyKeyboardMarkup(None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.resize = True

        if (flags & (1 << 1)) != 0:
            self.single_use = True

        if (flags & (1 << 2)) != 0:
            self.selective = True

        reader.read_int()
        self.rows = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.rows.append(_x)

    def __repr__(self):
        return 'replyKeyboardMarkup#3502758c flags:# resize:flags.0?true single_use:flags.1?true selective:flags.2?true rows:Vector<KeyboardButtonRow> = ReplyMarkup'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ResPQ(TLObject):
    constructor_id = 0x5162463
    subclass_of_id = 0x786986b8

    def __init__(self, nonce, server_nonce, pq, server_public_key_fingerprints):
        """
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param pq: Telegram type: "string".
        :param server_public_key_fingerprints: Telegram type: "long". Must be a list.

        Constructor for ResPQ: Instance of ResPQ.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.pq = pq
        self.server_public_key_fingerprints = server_public_key_fingerprints

    def to_dict(self):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'pq': self.pq,
            'server_public_key_fingerprints': [] if self.server_public_key_fingerprints is None else self.server_public_key_fingerprints[:],
        }

    def on_send(self, writer):
        writer.write_int(ResPQ.constructor_id, signed=False)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.tgwrite_string(self.pq)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.server_public_key_fingerprints))
        for _x in self.server_public_key_fingerprints:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return ResPQ(None, None, None, None)

    def on_response(self, reader):
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.pq = reader.tgread_string()
        reader.read_int()
        self.server_public_key_fingerprints = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.server_public_key_fingerprints.append(_x)

    def __repr__(self):
        return 'resPQ#05162463 nonce:int128 server_nonce:int128 pq:string server_public_key_fingerprints:Vector<long> = ResPQ'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class RpcAnswerDropped(TLObject):
    constructor_id = 0xa43ad8b7
    subclass_of_id = 0x4bca7570

    def __init__(self, msg_id, seq_no, bytes):
        """
        :param msg_id: Telegram type: "long".
        :param seq_no: Telegram type: "int".
        :param bytes: Telegram type: "int".

        Constructor for RpcDropAnswer: Instance of either RpcAnswerUnknown, RpcAnswerDroppedRunning, RpcAnswerDropped.
        """
        super().__init__()

        self.msg_id = msg_id
        self.seq_no = seq_no
        self.bytes = bytes

    def to_dict(self):
        return {
            'msg_id': self.msg_id,
            'seq_no': self.seq_no,
            'bytes': self.bytes,
        }

    def on_send(self, writer):
        writer.write_int(RpcAnswerDropped.constructor_id, signed=False)
        writer.write_long(self.msg_id)
        writer.write_int(self.seq_no)
        writer.write_int(self.bytes)

    @staticmethod
    def empty():
        return RpcAnswerDropped(None, None, None)

    def on_response(self, reader):
        self.msg_id = reader.read_long()
        self.seq_no = reader.read_int()
        self.bytes = reader.read_int()

    def __repr__(self):
        return 'rpc_answer_dropped#a43ad8b7 msg_id:long seq_no:int bytes:int = RpcDropAnswer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class RpcAnswerDroppedRunning(TLObject):
    constructor_id = 0xcd78e586
    subclass_of_id = 0x4bca7570

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(RpcAnswerDroppedRunning.constructor_id, signed=False)

    @staticmethod
    def empty():
        return RpcAnswerDroppedRunning()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'rpc_answer_dropped_running#cd78e586 = RpcDropAnswer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class RpcAnswerUnknown(TLObject):
    constructor_id = 0x5e2ad36e
    subclass_of_id = 0x4bca7570

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(RpcAnswerUnknown.constructor_id, signed=False)

    @staticmethod
    def empty():
        return RpcAnswerUnknown()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'rpc_answer_unknown#5e2ad36e = RpcDropAnswer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class RpcError(TLObject):
    constructor_id = 0x2144ca19
    subclass_of_id = 0x4a17e265

    def __init__(self, error_code, error_message):
        """
        :param error_code: Telegram type: "int".
        :param error_message: Telegram type: "string".

        Constructor for RpcError: Instance of RpcError.
        """
        super().__init__()

        self.error_code = error_code
        self.error_message = error_message

    def to_dict(self):
        return {
            'error_code': self.error_code,
            'error_message': self.error_message,
        }

    def on_send(self, writer):
        writer.write_int(RpcError.constructor_id, signed=False)
        writer.write_int(self.error_code)
        writer.tgwrite_string(self.error_message)

    @staticmethod
    def empty():
        return RpcError(None, None)

    def on_response(self, reader):
        self.error_code = reader.read_int()
        self.error_message = reader.tgread_string()

    def __repr__(self):
        return 'rpc_error#2144ca19 error_code:int error_message:string = RpcError'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageCancelAction(TLObject):
    constructor_id = 0xfd5ec8f5
    subclass_of_id = 0x20b2cc21

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SendMessageCancelAction.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SendMessageCancelAction()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'sendMessageCancelAction#fd5ec8f5 = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageChooseContactAction(TLObject):
    constructor_id = 0x628cbc6f
    subclass_of_id = 0x20b2cc21

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SendMessageChooseContactAction.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SendMessageChooseContactAction()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'sendMessageChooseContactAction#628cbc6f = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageGamePlayAction(TLObject):
    constructor_id = 0xdd6a8f48
    subclass_of_id = 0x20b2cc21

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SendMessageGamePlayAction.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SendMessageGamePlayAction()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'sendMessageGamePlayAction#dd6a8f48 = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageGeoLocationAction(TLObject):
    constructor_id = 0x176f8ba1
    subclass_of_id = 0x20b2cc21

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SendMessageGeoLocationAction.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SendMessageGeoLocationAction()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'sendMessageGeoLocationAction#176f8ba1 = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageRecordAudioAction(TLObject):
    constructor_id = 0xd52f73f7
    subclass_of_id = 0x20b2cc21

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SendMessageRecordAudioAction.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SendMessageRecordAudioAction()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'sendMessageRecordAudioAction#d52f73f7 = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageRecordRoundAction(TLObject):
    constructor_id = 0x88f27fbc
    subclass_of_id = 0x20b2cc21

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SendMessageRecordRoundAction.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SendMessageRecordRoundAction()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'sendMessageRecordRoundAction#88f27fbc = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageRecordVideoAction(TLObject):
    constructor_id = 0xa187d66f
    subclass_of_id = 0x20b2cc21

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SendMessageRecordVideoAction.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SendMessageRecordVideoAction()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'sendMessageRecordVideoAction#a187d66f = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageTypingAction(TLObject):
    constructor_id = 0x16bf744e
    subclass_of_id = 0x20b2cc21

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(SendMessageTypingAction.constructor_id, signed=False)

    @staticmethod
    def empty():
        return SendMessageTypingAction()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'sendMessageTypingAction#16bf744e = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageUploadAudioAction(TLObject):
    constructor_id = 0xf351d7ab
    subclass_of_id = 0x20b2cc21

    def __init__(self, progress):
        """
        :param progress: Telegram type: "int".

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self):
        return {
            'progress': self.progress,
        }

    def on_send(self, writer):
        writer.write_int(SendMessageUploadAudioAction.constructor_id, signed=False)
        writer.write_int(self.progress)

    @staticmethod
    def empty():
        return SendMessageUploadAudioAction(None)

    def on_response(self, reader):
        self.progress = reader.read_int()

    def __repr__(self):
        return 'sendMessageUploadAudioAction#f351d7ab progress:int = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageUploadDocumentAction(TLObject):
    constructor_id = 0xaa0cd9e4
    subclass_of_id = 0x20b2cc21

    def __init__(self, progress):
        """
        :param progress: Telegram type: "int".

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self):
        return {
            'progress': self.progress,
        }

    def on_send(self, writer):
        writer.write_int(SendMessageUploadDocumentAction.constructor_id, signed=False)
        writer.write_int(self.progress)

    @staticmethod
    def empty():
        return SendMessageUploadDocumentAction(None)

    def on_response(self, reader):
        self.progress = reader.read_int()

    def __repr__(self):
        return 'sendMessageUploadDocumentAction#aa0cd9e4 progress:int = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageUploadPhotoAction(TLObject):
    constructor_id = 0xd1d34a26
    subclass_of_id = 0x20b2cc21

    def __init__(self, progress):
        """
        :param progress: Telegram type: "int".

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self):
        return {
            'progress': self.progress,
        }

    def on_send(self, writer):
        writer.write_int(SendMessageUploadPhotoAction.constructor_id, signed=False)
        writer.write_int(self.progress)

    @staticmethod
    def empty():
        return SendMessageUploadPhotoAction(None)

    def on_response(self, reader):
        self.progress = reader.read_int()

    def __repr__(self):
        return 'sendMessageUploadPhotoAction#d1d34a26 progress:int = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageUploadRoundAction(TLObject):
    constructor_id = 0x243e1c66
    subclass_of_id = 0x20b2cc21

    def __init__(self, progress):
        """
        :param progress: Telegram type: "int".

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self):
        return {
            'progress': self.progress,
        }

    def on_send(self, writer):
        writer.write_int(SendMessageUploadRoundAction.constructor_id, signed=False)
        writer.write_int(self.progress)

    @staticmethod
    def empty():
        return SendMessageUploadRoundAction(None)

    def on_response(self, reader):
        self.progress = reader.read_int()

    def __repr__(self):
        return 'sendMessageUploadRoundAction#243e1c66 progress:int = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class SendMessageUploadVideoAction(TLObject):
    constructor_id = 0xe9763aec
    subclass_of_id = 0x20b2cc21

    def __init__(self, progress):
        """
        :param progress: Telegram type: "int".

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self):
        return {
            'progress': self.progress,
        }

    def on_send(self, writer):
        writer.write_int(SendMessageUploadVideoAction.constructor_id, signed=False)
        writer.write_int(self.progress)

    @staticmethod
    def empty():
        return SendMessageUploadVideoAction(None)

    def on_response(self, reader):
        self.progress = reader.read_int()

    def __repr__(self):
        return 'sendMessageUploadVideoAction#e9763aec progress:int = SendMessageAction'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ServerDHInnerData(TLObject):
    constructor_id = 0xb5890dba
    subclass_of_id = 0xc69a67bc

    def __init__(self, nonce, server_nonce, g, dh_prime, g_a, server_time):
        """
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param g: Telegram type: "int".
        :param dh_prime: Telegram type: "string".
        :param g_a: Telegram type: "string".
        :param server_time: Telegram type: "int".

        Constructor for Server_DH_inner_data: Instance of ServerDHInnerData.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.g = g
        self.dh_prime = dh_prime
        self.g_a = g_a
        self.server_time = server_time

    def to_dict(self):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'g': self.g,
            'dh_prime': self.dh_prime,
            'g_a': self.g_a,
            'server_time': self.server_time,
        }

    def on_send(self, writer):
        writer.write_int(ServerDHInnerData.constructor_id, signed=False)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.write_int(self.g)
        writer.tgwrite_string(self.dh_prime)
        writer.tgwrite_string(self.g_a)
        writer.write_int(self.server_time)

    @staticmethod
    def empty():
        return ServerDHInnerData(None, None, None, None, None, None)

    def on_response(self, reader):
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.g = reader.read_int()
        self.dh_prime = reader.tgread_string()
        self.g_a = reader.tgread_string()
        self.server_time = reader.read_int()

    def __repr__(self):
        return 'server_DH_inner_data#b5890dba nonce:int128 server_nonce:int128 g:int dh_prime:string g_a:string server_time:int = Server_DH_inner_data'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ServerDHParamsFail(TLObject):
    constructor_id = 0x79cb045d
    subclass_of_id = 0xa6188d9e

    def __init__(self, nonce, server_nonce, new_nonce_hash):
        """
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param new_nonce_hash: Telegram type: "int128".

        Constructor for Server_DH_Params: Instance of either ServerDHParamsFail, ServerDHParamsOk.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce_hash = new_nonce_hash

    def to_dict(self):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash': self.new_nonce_hash,
        }

    def on_send(self, writer):
        writer.write_int(ServerDHParamsFail.constructor_id, signed=False)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.write_large_int(self.new_nonce_hash, bits=128)

    @staticmethod
    def empty():
        return ServerDHParamsFail(None, None, None)

    def on_response(self, reader):
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.new_nonce_hash = reader.read_large_int(bits=128)

    def __repr__(self):
        return 'server_DH_params_fail#79cb045d nonce:int128 server_nonce:int128 new_nonce_hash:int128 = Server_DH_Params'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ServerDHParamsOk(TLObject):
    constructor_id = 0xd0e8075c
    subclass_of_id = 0xa6188d9e

    def __init__(self, nonce, server_nonce, encrypted_answer):
        """
        :param nonce: Telegram type: "int128".
        :param server_nonce: Telegram type: "int128".
        :param encrypted_answer: Telegram type: "string".

        Constructor for Server_DH_Params: Instance of either ServerDHParamsFail, ServerDHParamsOk.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.encrypted_answer = encrypted_answer

    def to_dict(self):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'encrypted_answer': self.encrypted_answer,
        }

    def on_send(self, writer):
        writer.write_int(ServerDHParamsOk.constructor_id, signed=False)
        writer.write_large_int(self.nonce, bits=128)
        writer.write_large_int(self.server_nonce, bits=128)
        writer.tgwrite_string(self.encrypted_answer)

    @staticmethod
    def empty():
        return ServerDHParamsOk(None, None, None)

    def on_response(self, reader):
        self.nonce = reader.read_large_int(bits=128)
        self.server_nonce = reader.read_large_int(bits=128)
        self.encrypted_answer = reader.tgread_string()

    def __repr__(self):
        return 'server_DH_params_ok#d0e8075c nonce:int128 server_nonce:int128 encrypted_answer:string = Server_DH_Params'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class ShippingOption(TLObject):
    constructor_id = 0xb6213cdf
    subclass_of_id = 0xf4e94c78

    def __init__(self, id, title, prices):
        """
        :param id: Telegram type: "string".
        :param title: Telegram type: "string".
        :param prices: Telegram type: "LabeledPrice". Must be a list.

        Constructor for ShippingOption: Instance of ShippingOption.
        """
        super().__init__()

        self.id = id
        self.title = title
        self.prices = prices

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'prices': [] if self.prices is None else [None if x is None else x.to_dict() for x in self.prices],
        }

    def on_send(self, writer):
        writer.write_int(ShippingOption.constructor_id, signed=False)
        writer.tgwrite_string(self.id)
        writer.tgwrite_string(self.title)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.prices))
        for _x in self.prices:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return ShippingOption(None, None, None)

    def on_response(self, reader):
        self.id = reader.tgread_string()
        self.title = reader.tgread_string()
        reader.read_int()
        self.prices = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.prices.append(_x)

    def __repr__(self):
        return 'shippingOption#b6213cdf id:string title:string prices:Vector<LabeledPrice> = ShippingOption'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class StickerPack(TLObject):
    constructor_id = 0x12b299d4
    subclass_of_id = 0x9fefa4d4

    def __init__(self, emoticon, documents):
        """
        :param emoticon: Telegram type: "string".
        :param documents: Telegram type: "long". Must be a list.

        Constructor for StickerPack: Instance of StickerPack.
        """
        super().__init__()

        self.emoticon = emoticon
        self.documents = documents

    def to_dict(self):
        return {
            'emoticon': self.emoticon,
            'documents': [] if self.documents is None else self.documents[:],
        }

    def on_send(self, writer):
        writer.write_int(StickerPack.constructor_id, signed=False)
        writer.tgwrite_string(self.emoticon)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.documents))
        for _x in self.documents:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return StickerPack(None, None)

    def on_response(self, reader):
        self.emoticon = reader.tgread_string()
        reader.read_int()
        self.documents = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.documents.append(_x)

    def __repr__(self):
        return 'stickerPack#12b299d4 emoticon:string documents:Vector<long> = StickerPack'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class StickerSet(TLObject):
    constructor_id = 0xcd303b41
    subclass_of_id = 0xbad3ff91

    def __init__(self, id, access_hash, title, short_name, count, hash, installed=None, archived=None, official=None, masks=None):
        """
        :param installed: Telegram type: "true".
        :param archived: Telegram type: "true".
        :param official: Telegram type: "true".
        :param masks: Telegram type: "true".
        :param id: Telegram type: "long".
        :param access_hash: Telegram type: "long".
        :param title: Telegram type: "string".
        :param short_name: Telegram type: "string".
        :param count: Telegram type: "int".
        :param hash: Telegram type: "int".

        Constructor for StickerSet: Instance of StickerSet.
        """
        super().__init__()

        self.installed = installed
        self.archived = archived
        self.official = official
        self.masks = masks
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.short_name = short_name
        self.count = count
        self.hash = hash

    def to_dict(self):
        return {
            'installed': self.installed,
            'archived': self.archived,
            'official': self.official,
            'masks': self.masks,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'short_name': self.short_name,
            'count': self.count,
            'hash': self.hash,
        }

    def on_send(self, writer):
        writer.write_int(StickerSet.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.installed else 0
        flags |= (1 << 1) if self.archived else 0
        flags |= (1 << 2) if self.official else 0
        flags |= (1 << 3) if self.masks else 0
        writer.write_int(flags)

        writer.write_long(self.id)
        writer.write_long(self.access_hash)
        writer.tgwrite_string(self.title)
        writer.tgwrite_string(self.short_name)
        writer.write_int(self.count)
        writer.write_int(self.hash)

    @staticmethod
    def empty():
        return StickerSet(None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.installed = True

        if (flags & (1 << 1)) != 0:
            self.archived = True

        if (flags & (1 << 2)) != 0:
            self.official = True

        if (flags & (1 << 3)) != 0:
            self.masks = True

        self.id = reader.read_long()
        self.access_hash = reader.read_long()
        self.title = reader.tgread_string()
        self.short_name = reader.tgread_string()
        self.count = reader.read_int()
        self.hash = reader.read_int()

    def __repr__(self):
        return 'stickerSet#cd303b41 flags:# installed:flags.0?true archived:flags.1?true official:flags.2?true masks:flags.3?true id:long access_hash:long title:string short_name:string count:int hash:int = StickerSet'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class StickerSetCovered(TLObject):
    constructor_id = 0x6410a5d2
    subclass_of_id = 0x7f86e4e5

    def __init__(self, set, cover):
        """
        :param set: Telegram type: "StickerSet".
        :param cover: Telegram type: "Document".

        Constructor for StickerSetCovered: Instance of either StickerSetCovered, StickerSetMultiCovered.
        """
        super().__init__()

        self.set = set
        self.cover = cover

    def to_dict(self):
        return {
            'set': None if self.set is None else self.set.to_dict(),
            'cover': None if self.cover is None else self.cover.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(StickerSetCovered.constructor_id, signed=False)
        self.set.on_send(writer)
        self.cover.on_send(writer)

    @staticmethod
    def empty():
        return StickerSetCovered(None, None)

    def on_response(self, reader):
        self.set = reader.tgread_object()
        self.cover = reader.tgread_object()

    def __repr__(self):
        return 'stickerSetCovered#6410a5d2 set:StickerSet cover:Document = StickerSetCovered'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class StickerSetMultiCovered(TLObject):
    constructor_id = 0x3407e51b
    subclass_of_id = 0x7f86e4e5

    def __init__(self, set, covers):
        """
        :param set: Telegram type: "StickerSet".
        :param covers: Telegram type: "Document". Must be a list.

        Constructor for StickerSetCovered: Instance of either StickerSetCovered, StickerSetMultiCovered.
        """
        super().__init__()

        self.set = set
        self.covers = covers

    def to_dict(self):
        return {
            'set': None if self.set is None else self.set.to_dict(),
            'covers': [] if self.covers is None else [None if x is None else x.to_dict() for x in self.covers],
        }

    def on_send(self, writer):
        writer.write_int(StickerSetMultiCovered.constructor_id, signed=False)
        self.set.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.covers))
        for _x in self.covers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return StickerSetMultiCovered(None, None)

    def on_response(self, reader):
        self.set = reader.tgread_object()
        reader.read_int()
        self.covers = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.covers.append(_x)

    def __repr__(self):
        return 'stickerSetMultiCovered#3407e51b set:StickerSet covers:Vector<Document> = StickerSetCovered'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextBold(TLObject):
    constructor_id = 0x6724abc4
    subclass_of_id = 0xf1d0b479

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(TextBold.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return TextBold(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'textBold#6724abc4 text:RichText = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextConcat(TLObject):
    constructor_id = 0x7e6260d7
    subclass_of_id = 0xf1d0b479

    def __init__(self, texts):
        """
        :param texts: Telegram type: "RichText". Must be a list.

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.texts = texts

    def to_dict(self):
        return {
            'texts': [] if self.texts is None else [None if x is None else x.to_dict() for x in self.texts],
        }

    def on_send(self, writer):
        writer.write_int(TextConcat.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.texts))
        for _x in self.texts:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return TextConcat(None)

    def on_response(self, reader):
        reader.read_int()
        self.texts = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.texts.append(_x)

    def __repr__(self):
        return 'textConcat#7e6260d7 texts:Vector<RichText> = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextEmail(TLObject):
    constructor_id = 0xde5a0dd6
    subclass_of_id = 0xf1d0b479

    def __init__(self, text, email):
        """
        :param text: Telegram type: "RichText".
        :param email: Telegram type: "string".

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text
        self.email = email

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
            'email': self.email,
        }

    def on_send(self, writer):
        writer.write_int(TextEmail.constructor_id, signed=False)
        self.text.on_send(writer)
        writer.tgwrite_string(self.email)

    @staticmethod
    def empty():
        return TextEmail(None, None)

    def on_response(self, reader):
        self.text = reader.tgread_object()
        self.email = reader.tgread_string()

    def __repr__(self):
        return 'textEmail#de5a0dd6 text:RichText email:string = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextEmpty(TLObject):
    constructor_id = 0xdc3d824f
    subclass_of_id = 0xf1d0b479

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(TextEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return TextEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'textEmpty#dc3d824f = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextFixed(TLObject):
    constructor_id = 0x6c3f19b9
    subclass_of_id = 0xf1d0b479

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(TextFixed.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return TextFixed(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'textFixed#6c3f19b9 text:RichText = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextItalic(TLObject):
    constructor_id = 0xd912a59c
    subclass_of_id = 0xf1d0b479

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(TextItalic.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return TextItalic(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'textItalic#d912a59c text:RichText = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextPlain(TLObject):
    constructor_id = 0x744694e0
    subclass_of_id = 0xf1d0b479

    def __init__(self, text):
        """
        :param text: Telegram type: "string".

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': self.text,
        }

    def on_send(self, writer):
        writer.write_int(TextPlain.constructor_id, signed=False)
        writer.tgwrite_string(self.text)

    @staticmethod
    def empty():
        return TextPlain(None)

    def on_response(self, reader):
        self.text = reader.tgread_string()

    def __repr__(self):
        return 'textPlain#744694e0 text:string = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextStrike(TLObject):
    constructor_id = 0x9bf8bb95
    subclass_of_id = 0xf1d0b479

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(TextStrike.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return TextStrike(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'textStrike#9bf8bb95 text:RichText = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextUnderline(TLObject):
    constructor_id = 0xc12622c4
    subclass_of_id = 0xf1d0b479

    def __init__(self, text):
        """
        :param text: Telegram type: "RichText".

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(TextUnderline.constructor_id, signed=False)
        self.text.on_send(writer)

    @staticmethod
    def empty():
        return TextUnderline(None)

    def on_response(self, reader):
        self.text = reader.tgread_object()

    def __repr__(self):
        return 'textUnderline#c12622c4 text:RichText = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TextUrl(TLObject):
    constructor_id = 0x3c2884c1
    subclass_of_id = 0xf1d0b479

    def __init__(self, text, url, webpage_id):
        """
        :param text: Telegram type: "RichText".
        :param url: Telegram type: "string".
        :param webpage_id: Telegram type: "long".

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text
        self.url = url
        self.webpage_id = webpage_id

    def to_dict(self):
        return {
            'text': None if self.text is None else self.text.to_dict(),
            'url': self.url,
            'webpage_id': self.webpage_id,
        }

    def on_send(self, writer):
        writer.write_int(TextUrl.constructor_id, signed=False)
        self.text.on_send(writer)
        writer.tgwrite_string(self.url)
        writer.write_long(self.webpage_id)

    @staticmethod
    def empty():
        return TextUrl(None, None, None)

    def on_response(self, reader):
        self.text = reader.tgread_object()
        self.url = reader.tgread_string()
        self.webpage_id = reader.read_long()

    def __repr__(self):
        return 'textUrl#3c2884c1 text:RichText url:string webpage_id:long = RichText'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TopPeer(TLObject):
    constructor_id = 0xedcdc05b
    subclass_of_id = 0x6916c601

    def __init__(self, peer, rating):
        """
        :param peer: Telegram type: "Peer".
        :param rating: Telegram type: "double".

        Constructor for TopPeer: Instance of TopPeer.
        """
        super().__init__()

        self.peer = peer
        self.rating = rating

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'rating': self.rating,
        }

    def on_send(self, writer):
        writer.write_int(TopPeer.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_double(self.rating)

    @staticmethod
    def empty():
        return TopPeer(None, None)

    def on_response(self, reader):
        self.peer = reader.tgread_object()
        self.rating = reader.read_double()

    def __repr__(self):
        return 'topPeer#edcdc05b peer:Peer rating:double = TopPeer'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TopPeerCategoryBotsInline(TLObject):
    constructor_id = 0x148677e2
    subclass_of_id = 0xddf02502

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(TopPeerCategoryBotsInline.constructor_id, signed=False)

    @staticmethod
    def empty():
        return TopPeerCategoryBotsInline()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'topPeerCategoryBotsInline#148677e2 = TopPeerCategory'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TopPeerCategoryBotsPM(TLObject):
    constructor_id = 0xab661b5b
    subclass_of_id = 0xddf02502

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(TopPeerCategoryBotsPM.constructor_id, signed=False)

    @staticmethod
    def empty():
        return TopPeerCategoryBotsPM()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'topPeerCategoryBotsPM#ab661b5b = TopPeerCategory'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TopPeerCategoryChannels(TLObject):
    constructor_id = 0x161d9628
    subclass_of_id = 0xddf02502

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(TopPeerCategoryChannels.constructor_id, signed=False)

    @staticmethod
    def empty():
        return TopPeerCategoryChannels()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'topPeerCategoryChannels#161d9628 = TopPeerCategory'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TopPeerCategoryCorrespondents(TLObject):
    constructor_id = 0x637b7ed
    subclass_of_id = 0xddf02502

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(TopPeerCategoryCorrespondents.constructor_id, signed=False)

    @staticmethod
    def empty():
        return TopPeerCategoryCorrespondents()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'topPeerCategoryCorrespondents#0637b7ed = TopPeerCategory'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TopPeerCategoryGroups(TLObject):
    constructor_id = 0xbd17a14a
    subclass_of_id = 0xddf02502

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(TopPeerCategoryGroups.constructor_id, signed=False)

    @staticmethod
    def empty():
        return TopPeerCategoryGroups()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'topPeerCategoryGroups#bd17a14a = TopPeerCategory'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TopPeerCategoryPeers(TLObject):
    constructor_id = 0xfb834291
    subclass_of_id = 0x4aec930

    def __init__(self, category, count, peers):
        """
        :param category: Telegram type: "TopPeerCategory".
        :param count: Telegram type: "int".
        :param peers: Telegram type: "TopPeer". Must be a list.

        Constructor for TopPeerCategoryPeers: Instance of TopPeerCategoryPeers.
        """
        super().__init__()

        self.category = category
        self.count = count
        self.peers = peers

    def to_dict(self):
        return {
            'category': None if self.category is None else self.category.to_dict(),
            'count': self.count,
            'peers': [] if self.peers is None else [None if x is None else x.to_dict() for x in self.peers],
        }

    def on_send(self, writer):
        writer.write_int(TopPeerCategoryPeers.constructor_id, signed=False)
        self.category.on_send(writer)
        writer.write_int(self.count)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.peers))
        for _x in self.peers:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return TopPeerCategoryPeers(None, None, None)

    def on_response(self, reader):
        self.category = reader.tgread_object()
        self.count = reader.read_int()
        reader.read_int()
        self.peers = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.peers.append(_x)

    def __repr__(self):
        return 'topPeerCategoryPeers#fb834291 category:TopPeerCategory count:int peers:Vector<TopPeer> = TopPeerCategoryPeers'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class TopPeerCategoryPhoneCalls(TLObject):
    constructor_id = 0x1e76a78c
    subclass_of_id = 0xddf02502

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(TopPeerCategoryPhoneCalls.constructor_id, signed=False)

    @staticmethod
    def empty():
        return TopPeerCategoryPhoneCalls()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'topPeerCategoryPhoneCalls#1e76a78c = TopPeerCategory'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateBotCallbackQuery(TLObject):
    constructor_id = 0xe73547e1
    subclass_of_id = 0x9f89304e

    def __init__(self, query_id, user_id, peer, msg_id, chat_instance, data=None, game_short_name=None):
        """
        :param query_id: Telegram type: "long".
        :param user_id: Telegram type: "int".
        :param peer: Telegram type: "Peer".
        :param msg_id: Telegram type: "int".
        :param chat_instance: Telegram type: "long".
        :param data: Telegram type: "bytes".
        :param game_short_name: Telegram type: "string".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.peer = peer
        self.msg_id = msg_id
        self.chat_instance = chat_instance
        self.data = data
        self.game_short_name = game_short_name

    def to_dict(self):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'msg_id': self.msg_id,
            'chat_instance': self.chat_instance,
            'data': self.data,
            'game_short_name': self.game_short_name,
        }

    def on_send(self, writer):
        writer.write_int(UpdateBotCallbackQuery.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.data else 0
        flags |= (1 << 1) if self.game_short_name else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        writer.write_int(self.user_id)
        self.peer.on_send(writer)
        writer.write_int(self.msg_id)
        writer.write_long(self.chat_instance)
        if self.data:
            writer.tgwrite_bytes(self.data)

        if self.game_short_name:
            writer.tgwrite_string(self.game_short_name)

    @staticmethod
    def empty():
        return UpdateBotCallbackQuery(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.query_id = reader.read_long()
        self.user_id = reader.read_int()
        self.peer = reader.tgread_object()
        self.msg_id = reader.read_int()
        self.chat_instance = reader.read_long()
        if (flags & (1 << 0)) != 0:
            self.data = reader.tgread_bytes()

        if (flags & (1 << 1)) != 0:
            self.game_short_name = reader.tgread_string()

    def __repr__(self):
        return 'updateBotCallbackQuery#e73547e1 flags:# query_id:long user_id:int peer:Peer msg_id:int chat_instance:long data:flags.0?bytes game_short_name:flags.1?string = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateBotInlineQuery(TLObject):
    constructor_id = 0x54826690
    subclass_of_id = 0x9f89304e

    def __init__(self, query_id, user_id, query, offset, geo=None):
        """
        :param query_id: Telegram type: "long".
        :param user_id: Telegram type: "int".
        :param query: Telegram type: "string".
        :param geo: Telegram type: "GeoPoint".
        :param offset: Telegram type: "string".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.query = query
        self.geo = geo
        self.offset = offset

    def to_dict(self):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'query': self.query,
            'geo': None if self.geo is None else self.geo.to_dict(),
            'offset': self.offset,
        }

    def on_send(self, writer):
        writer.write_int(UpdateBotInlineQuery.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.geo else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        writer.write_int(self.user_id)
        writer.tgwrite_string(self.query)
        if self.geo:
            self.geo.on_send(writer)

        writer.tgwrite_string(self.offset)

    @staticmethod
    def empty():
        return UpdateBotInlineQuery(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.query_id = reader.read_long()
        self.user_id = reader.read_int()
        self.query = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.geo = reader.tgread_object()

        self.offset = reader.tgread_string()

    def __repr__(self):
        return 'updateBotInlineQuery#54826690 flags:# query_id:long user_id:int query:string geo:flags.0?GeoPoint offset:string = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateBotInlineSend(TLObject):
    constructor_id = 0xe48f964
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, query, id, geo=None, msg_id=None):
        """
        :param user_id: Telegram type: "int".
        :param query: Telegram type: "string".
        :param geo: Telegram type: "GeoPoint".
        :param id: Telegram type: "string".
        :param msg_id: Telegram type: "InputBotInlineMessageID".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.query = query
        self.geo = geo
        self.id = id
        self.msg_id = msg_id

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'query': self.query,
            'geo': None if self.geo is None else self.geo.to_dict(),
            'id': self.id,
            'msg_id': None if self.msg_id is None else self.msg_id.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateBotInlineSend.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.geo else 0
        flags |= (1 << 1) if self.msg_id else 0
        writer.write_int(flags)

        writer.write_int(self.user_id)
        writer.tgwrite_string(self.query)
        if self.geo:
            self.geo.on_send(writer)

        writer.tgwrite_string(self.id)
        if self.msg_id:
            self.msg_id.on_send(writer)

    @staticmethod
    def empty():
        return UpdateBotInlineSend(None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.user_id = reader.read_int()
        self.query = reader.tgread_string()
        if (flags & (1 << 0)) != 0:
            self.geo = reader.tgread_object()

        self.id = reader.tgread_string()
        if (flags & (1 << 1)) != 0:
            self.msg_id = reader.tgread_object()

    def __repr__(self):
        return 'updateBotInlineSend#0e48f964 flags:# user_id:int query:string geo:flags.0?GeoPoint id:string msg_id:flags.1?InputBotInlineMessageID = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateBotPrecheckoutQuery(TLObject):
    constructor_id = 0x5d2f3aa9
    subclass_of_id = 0x9f89304e

    def __init__(self, query_id, user_id, payload, currency, total_amount, info=None, shipping_option_id=None):
        """
        :param query_id: Telegram type: "long".
        :param user_id: Telegram type: "int".
        :param payload: Telegram type: "bytes".
        :param info: Telegram type: "PaymentRequestedInfo".
        :param shipping_option_id: Telegram type: "string".
        :param currency: Telegram type: "string".
        :param total_amount: Telegram type: "long".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.payload = payload
        self.info = info
        self.shipping_option_id = shipping_option_id
        self.currency = currency
        self.total_amount = total_amount

    def to_dict(self):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'payload': self.payload,
            'info': None if self.info is None else self.info.to_dict(),
            'shipping_option_id': self.shipping_option_id,
            'currency': self.currency,
            'total_amount': self.total_amount,
        }

    def on_send(self, writer):
        writer.write_int(UpdateBotPrecheckoutQuery.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.info else 0
        flags |= (1 << 1) if self.shipping_option_id else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        writer.write_int(self.user_id)
        writer.tgwrite_bytes(self.payload)
        if self.info:
            self.info.on_send(writer)

        if self.shipping_option_id:
            writer.tgwrite_string(self.shipping_option_id)

        writer.tgwrite_string(self.currency)
        writer.write_long(self.total_amount)

    @staticmethod
    def empty():
        return UpdateBotPrecheckoutQuery(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.query_id = reader.read_long()
        self.user_id = reader.read_int()
        self.payload = reader.tgread_bytes()
        if (flags & (1 << 0)) != 0:
            self.info = reader.tgread_object()

        if (flags & (1 << 1)) != 0:
            self.shipping_option_id = reader.tgread_string()

        self.currency = reader.tgread_string()
        self.total_amount = reader.read_long()

    def __repr__(self):
        return 'updateBotPrecheckoutQuery#5d2f3aa9 flags:# query_id:long user_id:int payload:bytes info:flags.0?PaymentRequestedInfo shipping_option_id:flags.1?string currency:string total_amount:long = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateBotShippingQuery(TLObject):
    constructor_id = 0xe0cdc940
    subclass_of_id = 0x9f89304e

    def __init__(self, query_id, user_id, payload, shipping_address):
        """
        :param query_id: Telegram type: "long".
        :param user_id: Telegram type: "int".
        :param payload: Telegram type: "bytes".
        :param shipping_address: Telegram type: "PostAddress".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.payload = payload
        self.shipping_address = shipping_address

    def to_dict(self):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'payload': self.payload,
            'shipping_address': None if self.shipping_address is None else self.shipping_address.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateBotShippingQuery.constructor_id, signed=False)
        writer.write_long(self.query_id)
        writer.write_int(self.user_id)
        writer.tgwrite_bytes(self.payload)
        self.shipping_address.on_send(writer)

    @staticmethod
    def empty():
        return UpdateBotShippingQuery(None, None, None, None)

    def on_response(self, reader):
        self.query_id = reader.read_long()
        self.user_id = reader.read_int()
        self.payload = reader.tgread_bytes()
        self.shipping_address = reader.tgread_object()

    def __repr__(self):
        return 'updateBotShippingQuery#e0cdc940 query_id:long user_id:int payload:bytes shipping_address:PostAddress = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateBotWebhookJSON(TLObject):
    constructor_id = 0x8317c0c3
    subclass_of_id = 0x9f89304e

    def __init__(self, data):
        """
        :param data: Telegram type: "DataJSON".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.data = data

    def to_dict(self):
        return {
            'data': None if self.data is None else self.data.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateBotWebhookJSON.constructor_id, signed=False)
        self.data.on_send(writer)

    @staticmethod
    def empty():
        return UpdateBotWebhookJSON(None)

    def on_response(self, reader):
        self.data = reader.tgread_object()

    def __repr__(self):
        return 'updateBotWebhookJSON#8317c0c3 data:DataJSON = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateBotWebhookJSONQuery(TLObject):
    constructor_id = 0x9b9240a6
    subclass_of_id = 0x9f89304e

    def __init__(self, query_id, data, timeout):
        """
        :param query_id: Telegram type: "long".
        :param data: Telegram type: "DataJSON".
        :param timeout: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.data = data
        self.timeout = timeout

    def to_dict(self):
        return {
            'query_id': self.query_id,
            'data': None if self.data is None else self.data.to_dict(),
            'timeout': self.timeout,
        }

    def on_send(self, writer):
        writer.write_int(UpdateBotWebhookJSONQuery.constructor_id, signed=False)
        writer.write_long(self.query_id)
        self.data.on_send(writer)
        writer.write_int(self.timeout)

    @staticmethod
    def empty():
        return UpdateBotWebhookJSONQuery(None, None, None)

    def on_response(self, reader):
        self.query_id = reader.read_long()
        self.data = reader.tgread_object()
        self.timeout = reader.read_int()

    def __repr__(self):
        return 'updateBotWebhookJSONQuery#9b9240a6 query_id:long data:DataJSON timeout:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChannel(TLObject):
    constructor_id = 0xb6d45656
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id):
        """
        :param channel_id: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChannel.constructor_id, signed=False)
        writer.write_int(self.channel_id)

    @staticmethod
    def empty():
        return UpdateChannel(None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()

    def __repr__(self):
        return 'updateChannel#b6d45656 channel_id:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChannelMessageViews(TLObject):
    constructor_id = 0x98a12b4b
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id, id, views):
        """
        :param channel_id: Telegram type: "int".
        :param id: Telegram type: "int".
        :param views: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.id = id
        self.views = views

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'id': self.id,
            'views': self.views,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChannelMessageViews.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        writer.write_int(self.id)
        writer.write_int(self.views)

    @staticmethod
    def empty():
        return UpdateChannelMessageViews(None, None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        self.id = reader.read_int()
        self.views = reader.read_int()

    def __repr__(self):
        return 'updateChannelMessageViews#98a12b4b channel_id:int id:int views:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChannelPinnedMessage(TLObject):
    constructor_id = 0x98592475
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id, id):
        """
        :param channel_id: Telegram type: "int".
        :param id: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.id = id

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChannelPinnedMessage.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        writer.write_int(self.id)

    @staticmethod
    def empty():
        return UpdateChannelPinnedMessage(None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        self.id = reader.read_int()

    def __repr__(self):
        return 'updateChannelPinnedMessage#98592475 channel_id:int id:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChannelReadMessagesContents(TLObject):
    constructor_id = 0x89893b45
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id, messages):
        """
        :param channel_id: Telegram type: "int".
        :param messages: Telegram type: "int". Must be a list.

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.messages = messages

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'messages': [] if self.messages is None else self.messages[:],
        }

    def on_send(self, writer):
        writer.write_int(UpdateChannelReadMessagesContents.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            writer.write_int(_x)

    @staticmethod
    def empty():
        return UpdateChannelReadMessagesContents(None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_int()
            self.messages.append(_x)

    def __repr__(self):
        return 'updateChannelReadMessagesContents#89893b45 channel_id:int messages:Vector<int> = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChannelTooLong(TLObject):
    constructor_id = 0xeb0467fb
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id, pts=None):
        """
        :param channel_id: Telegram type: "int".
        :param pts: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.pts = pts

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'pts': self.pts,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChannelTooLong.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.pts else 0
        writer.write_int(flags)

        writer.write_int(self.channel_id)
        if self.pts:
            writer.write_int(self.pts)

    @staticmethod
    def empty():
        return UpdateChannelTooLong(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.channel_id = reader.read_int()
        if (flags & (1 << 0)) != 0:
            self.pts = reader.read_int()

    def __repr__(self):
        return 'updateChannelTooLong#eb0467fb flags:# channel_id:int pts:flags.0?int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChannelWebPage(TLObject):
    constructor_id = 0x40771900
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id, webpage, pts, pts_count):
        """
        :param channel_id: Telegram type: "int".
        :param webpage: Telegram type: "WebPage".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.webpage = webpage
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'webpage': None if self.webpage is None else self.webpage.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChannelWebPage.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        self.webpage.on_send(writer)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateChannelWebPage(None, None, None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        self.webpage = reader.tgread_object()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateChannelWebPage#40771900 channel_id:int webpage:WebPage pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChatAdmins(TLObject):
    constructor_id = 0x6e947941
    subclass_of_id = 0x9f89304e

    def __init__(self, chat_id, enabled, version):
        """
        :param chat_id: Telegram type: "int".
        :param enabled: Telegram type: "Bool".
        :param version: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.enabled = enabled
        self.version = version

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'enabled': self.enabled,
            'version': self.version,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChatAdmins.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.tgwrite_bool(self.enabled)
        writer.write_int(self.version)

    @staticmethod
    def empty():
        return UpdateChatAdmins(None, None, None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()
        self.enabled = reader.tgread_bool()
        self.version = reader.read_int()

    def __repr__(self):
        return 'updateChatAdmins#6e947941 chat_id:int enabled:Bool version:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChatParticipantAdd(TLObject):
    constructor_id = 0xea4b0e5c
    subclass_of_id = 0x9f89304e

    def __init__(self, chat_id, user_id, inviter_id, date, version):
        """
        :param chat_id: Telegram type: "int".
        :param user_id: Telegram type: "int".
        :param inviter_id: Telegram type: "int".
        :param date: Telegram type: "date".
        :param version: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date
        self.version = version

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
            'version': self.version,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChatParticipantAdd.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.write_int(self.user_id)
        writer.write_int(self.inviter_id)
        writer.tgwrite_date(self.date)
        writer.write_int(self.version)

    @staticmethod
    def empty():
        return UpdateChatParticipantAdd(None, None, None, None, None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()
        self.user_id = reader.read_int()
        self.inviter_id = reader.read_int()
        self.date = reader.tgread_date()
        self.version = reader.read_int()

    def __repr__(self):
        return 'updateChatParticipantAdd#ea4b0e5c chat_id:int user_id:int inviter_id:int date:int version:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChatParticipantAdmin(TLObject):
    constructor_id = 0xb6901959
    subclass_of_id = 0x9f89304e

    def __init__(self, chat_id, user_id, is_admin, version):
        """
        :param chat_id: Telegram type: "int".
        :param user_id: Telegram type: "int".
        :param is_admin: Telegram type: "Bool".
        :param version: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.user_id = user_id
        self.is_admin = is_admin
        self.version = version

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'is_admin': self.is_admin,
            'version': self.version,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChatParticipantAdmin.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.write_int(self.user_id)
        writer.tgwrite_bool(self.is_admin)
        writer.write_int(self.version)

    @staticmethod
    def empty():
        return UpdateChatParticipantAdmin(None, None, None, None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()
        self.user_id = reader.read_int()
        self.is_admin = reader.tgread_bool()
        self.version = reader.read_int()

    def __repr__(self):
        return 'updateChatParticipantAdmin#b6901959 chat_id:int user_id:int is_admin:Bool version:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChatParticipantDelete(TLObject):
    constructor_id = 0x6e5f8c22
    subclass_of_id = 0x9f89304e

    def __init__(self, chat_id, user_id, version):
        """
        :param chat_id: Telegram type: "int".
        :param user_id: Telegram type: "int".
        :param version: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.user_id = user_id
        self.version = version

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'version': self.version,
        }

    def on_send(self, writer):
        writer.write_int(UpdateChatParticipantDelete.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.write_int(self.user_id)
        writer.write_int(self.version)

    @staticmethod
    def empty():
        return UpdateChatParticipantDelete(None, None, None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()
        self.user_id = reader.read_int()
        self.version = reader.read_int()

    def __repr__(self):
        return 'updateChatParticipantDelete#6e5f8c22 chat_id:int user_id:int version:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChatParticipants(TLObject):
    constructor_id = 0x7761198
    subclass_of_id = 0x9f89304e

    def __init__(self, participants):
        """
        :param participants: Telegram type: "ChatParticipants".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.participants = participants

    def to_dict(self):
        return {
            'participants': None if self.participants is None else self.participants.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateChatParticipants.constructor_id, signed=False)
        self.participants.on_send(writer)

    @staticmethod
    def empty():
        return UpdateChatParticipants(None)

    def on_response(self, reader):
        self.participants = reader.tgread_object()

    def __repr__(self):
        return 'updateChatParticipants#07761198 participants:ChatParticipants = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateChatUserTyping(TLObject):
    constructor_id = 0x9a65ea1f
    subclass_of_id = 0x9f89304e

    def __init__(self, chat_id, user_id, action):
        """
        :param chat_id: Telegram type: "int".
        :param user_id: Telegram type: "int".
        :param action: Telegram type: "SendMessageAction".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.user_id = user_id
        self.action = action

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateChatUserTyping.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.write_int(self.user_id)
        self.action.on_send(writer)

    @staticmethod
    def empty():
        return UpdateChatUserTyping(None, None, None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()
        self.user_id = reader.read_int()
        self.action = reader.tgread_object()

    def __repr__(self):
        return 'updateChatUserTyping#9a65ea1f chat_id:int user_id:int action:SendMessageAction = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateConfig(TLObject):
    constructor_id = 0xa229dd06
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdateConfig.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdateConfig()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updateConfig#a229dd06 = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateContactLink(TLObject):
    constructor_id = 0x9d2e67c5
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, my_link, foreign_link):
        """
        :param user_id: Telegram type: "int".
        :param my_link: Telegram type: "ContactLink".
        :param foreign_link: Telegram type: "ContactLink".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.my_link = my_link
        self.foreign_link = foreign_link

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'my_link': None if self.my_link is None else self.my_link.to_dict(),
            'foreign_link': None if self.foreign_link is None else self.foreign_link.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateContactLink.constructor_id, signed=False)
        writer.write_int(self.user_id)
        self.my_link.on_send(writer)
        self.foreign_link.on_send(writer)

    @staticmethod
    def empty():
        return UpdateContactLink(None, None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.my_link = reader.tgread_object()
        self.foreign_link = reader.tgread_object()

    def __repr__(self):
        return 'updateContactLink#9d2e67c5 user_id:int my_link:ContactLink foreign_link:ContactLink = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateContactRegistered(TLObject):
    constructor_id = 0x2575bbb9
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, date):
        """
        :param user_id: Telegram type: "int".
        :param date: Telegram type: "date".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.date = date

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(UpdateContactRegistered.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return UpdateContactRegistered(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'updateContactRegistered#2575bbb9 user_id:int date:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateContactsReset(TLObject):
    constructor_id = 0x7084a7be
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdateContactsReset.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdateContactsReset()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updateContactsReset#7084a7be = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateDcOptions(TLObject):
    constructor_id = 0x8e5e9873
    subclass_of_id = 0x9f89304e

    def __init__(self, dc_options):
        """
        :param dc_options: Telegram type: "DcOption". Must be a list.

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.dc_options = dc_options

    def to_dict(self):
        return {
            'dc_options': [] if self.dc_options is None else [None if x is None else x.to_dict() for x in self.dc_options],
        }

    def on_send(self, writer):
        writer.write_int(UpdateDcOptions.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.dc_options))
        for _x in self.dc_options:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return UpdateDcOptions(None)

    def on_response(self, reader):
        reader.read_int()
        self.dc_options = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.dc_options.append(_x)

    def __repr__(self):
        return 'updateDcOptions#8e5e9873 dc_options:Vector<DcOption> = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateDeleteChannelMessages(TLObject):
    constructor_id = 0xc37521c9
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id, messages, pts, pts_count):
        """
        :param channel_id: Telegram type: "int".
        :param messages: Telegram type: "int". Must be a list.
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateDeleteChannelMessages.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            writer.write_int(_x)

        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateDeleteChannelMessages(None, None, None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_int()
            self.messages.append(_x)

        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateDeleteChannelMessages#c37521c9 channel_id:int messages:Vector<int> pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateDeleteMessages(TLObject):
    constructor_id = 0xa20db0e5
    subclass_of_id = 0x9f89304e

    def __init__(self, messages, pts, pts_count):
        """
        :param messages: Telegram type: "int". Must be a list.
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateDeleteMessages.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            writer.write_int(_x)

        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateDeleteMessages(None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_int()
            self.messages.append(_x)

        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateDeleteMessages#a20db0e5 messages:Vector<int> pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateDialogPinned(TLObject):
    constructor_id = 0xd711a2cc
    subclass_of_id = 0x9f89304e

    def __init__(self, peer, pinned=None):
        """
        :param pinned: Telegram type: "true".
        :param peer: Telegram type: "Peer".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.pinned = pinned
        self.peer = peer

    def to_dict(self):
        return {
            'pinned': self.pinned,
            'peer': None if self.peer is None else self.peer.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateDialogPinned.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.pinned else 0
        writer.write_int(flags)

        self.peer.on_send(writer)

    @staticmethod
    def empty():
        return UpdateDialogPinned(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.pinned = True

        self.peer = reader.tgread_object()

    def __repr__(self):
        return 'updateDialogPinned#d711a2cc flags:# pinned:flags.0?true peer:Peer = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateDraftMessage(TLObject):
    constructor_id = 0xee2bb969
    subclass_of_id = 0x9f89304e

    def __init__(self, peer, draft):
        """
        :param peer: Telegram type: "Peer".
        :param draft: Telegram type: "DraftMessage".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.peer = peer
        self.draft = draft

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'draft': None if self.draft is None else self.draft.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateDraftMessage.constructor_id, signed=False)
        self.peer.on_send(writer)
        self.draft.on_send(writer)

    @staticmethod
    def empty():
        return UpdateDraftMessage(None, None)

    def on_response(self, reader):
        self.peer = reader.tgread_object()
        self.draft = reader.tgread_object()

    def __repr__(self):
        return 'updateDraftMessage#ee2bb969 peer:Peer draft:DraftMessage = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateEditChannelMessage(TLObject):
    constructor_id = 0x1b3f4df7
    subclass_of_id = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param message: Telegram type: "Message".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateEditChannelMessage.constructor_id, signed=False)
        self.message.on_send(writer)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateEditChannelMessage(None, None, None)

    def on_response(self, reader):
        self.message = reader.tgread_object()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateEditChannelMessage#1b3f4df7 message:Message pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateEditMessage(TLObject):
    constructor_id = 0xe40370a3
    subclass_of_id = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param message: Telegram type: "Message".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateEditMessage.constructor_id, signed=False)
        self.message.on_send(writer)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateEditMessage(None, None, None)

    def on_response(self, reader):
        self.message = reader.tgread_object()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateEditMessage#e40370a3 message:Message pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateEncryptedChatTyping(TLObject):
    constructor_id = 0x1710f156
    subclass_of_id = 0x9f89304e

    def __init__(self, chat_id):
        """
        :param chat_id: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
        }

    def on_send(self, writer):
        writer.write_int(UpdateEncryptedChatTyping.constructor_id, signed=False)
        writer.write_int(self.chat_id)

    @staticmethod
    def empty():
        return UpdateEncryptedChatTyping(None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()

    def __repr__(self):
        return 'updateEncryptedChatTyping#1710f156 chat_id:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateEncryptedMessagesRead(TLObject):
    constructor_id = 0x38fe25b7
    subclass_of_id = 0x9f89304e

    def __init__(self, chat_id, max_date, date):
        """
        :param chat_id: Telegram type: "int".
        :param max_date: Telegram type: "date".
        :param date: Telegram type: "date".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.max_date = max_date
        self.date = date

    def to_dict(self):
        return {
            'chat_id': self.chat_id,
            'max_date': self.max_date,
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(UpdateEncryptedMessagesRead.constructor_id, signed=False)
        writer.write_int(self.chat_id)
        writer.tgwrite_date(self.max_date)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return UpdateEncryptedMessagesRead(None, None, None)

    def on_response(self, reader):
        self.chat_id = reader.read_int()
        self.max_date = reader.tgread_date()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'updateEncryptedMessagesRead#38fe25b7 chat_id:int max_date:int date:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateEncryption(TLObject):
    constructor_id = 0xb4a2e88d
    subclass_of_id = 0x9f89304e

    def __init__(self, chat, date):
        """
        :param chat: Telegram type: "EncryptedChat".
        :param date: Telegram type: "date".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat = chat
        self.date = date

    def to_dict(self):
        return {
            'chat': None if self.chat is None else self.chat.to_dict(),
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(UpdateEncryption.constructor_id, signed=False)
        self.chat.on_send(writer)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return UpdateEncryption(None, None)

    def on_response(self, reader):
        self.chat = reader.tgread_object()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'updateEncryption#b4a2e88d chat:EncryptedChat date:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateFavedStickers(TLObject):
    constructor_id = 0xe511996d
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdateFavedStickers.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdateFavedStickers()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updateFavedStickers#e511996d = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateInlineBotCallbackQuery(TLObject):
    constructor_id = 0xf9d27a5a
    subclass_of_id = 0x9f89304e

    def __init__(self, query_id, user_id, msg_id, chat_instance, data=None, game_short_name=None):
        """
        :param query_id: Telegram type: "long".
        :param user_id: Telegram type: "int".
        :param msg_id: Telegram type: "InputBotInlineMessageID".
        :param chat_instance: Telegram type: "long".
        :param data: Telegram type: "bytes".
        :param game_short_name: Telegram type: "string".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.msg_id = msg_id
        self.chat_instance = chat_instance
        self.data = data
        self.game_short_name = game_short_name

    def to_dict(self):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'msg_id': None if self.msg_id is None else self.msg_id.to_dict(),
            'chat_instance': self.chat_instance,
            'data': self.data,
            'game_short_name': self.game_short_name,
        }

    def on_send(self, writer):
        writer.write_int(UpdateInlineBotCallbackQuery.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.data else 0
        flags |= (1 << 1) if self.game_short_name else 0
        writer.write_int(flags)

        writer.write_long(self.query_id)
        writer.write_int(self.user_id)
        self.msg_id.on_send(writer)
        writer.write_long(self.chat_instance)
        if self.data:
            writer.tgwrite_bytes(self.data)

        if self.game_short_name:
            writer.tgwrite_string(self.game_short_name)

    @staticmethod
    def empty():
        return UpdateInlineBotCallbackQuery(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.query_id = reader.read_long()
        self.user_id = reader.read_int()
        self.msg_id = reader.tgread_object()
        self.chat_instance = reader.read_long()
        if (flags & (1 << 0)) != 0:
            self.data = reader.tgread_bytes()

        if (flags & (1 << 1)) != 0:
            self.game_short_name = reader.tgread_string()

    def __repr__(self):
        return 'updateInlineBotCallbackQuery#f9d27a5a flags:# query_id:long user_id:int msg_id:InputBotInlineMessageID chat_instance:long data:flags.0?bytes game_short_name:flags.1?string = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateLangPack(TLObject):
    constructor_id = 0x56022f4d
    subclass_of_id = 0x9f89304e

    def __init__(self, difference):
        """
        :param difference: Telegram type: "LangPackDifference".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.difference = difference

    def to_dict(self):
        return {
            'difference': None if self.difference is None else self.difference.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateLangPack.constructor_id, signed=False)
        self.difference.on_send(writer)

    @staticmethod
    def empty():
        return UpdateLangPack(None)

    def on_response(self, reader):
        self.difference = reader.tgread_object()

    def __repr__(self):
        return 'updateLangPack#56022f4d difference:LangPackDifference = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateLangPackTooLong(TLObject):
    constructor_id = 0x10c2404b
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdateLangPackTooLong.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdateLangPackTooLong()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updateLangPackTooLong#10c2404b = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

import os


class UpdateMessageID(TLObject):
    constructor_id = 0x4e90bfd6
    subclass_of_id = 0x9f89304e

    def __init__(self, id, random_id=None):
        """
        :param id: Telegram type: "int".
        :param random_id: Telegram type: "long".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.id = id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            'id': self.id,
            'random_id': self.random_id,
        }

    def on_send(self, writer):
        writer.write_int(UpdateMessageID.constructor_id, signed=False)
        writer.write_int(self.id)
        writer.write_long(self.random_id)

    @staticmethod
    def empty():
        return UpdateMessageID(None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.random_id = reader.read_long()

    def __repr__(self):
        return 'updateMessageID#4e90bfd6 id:int random_id:long = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateNewChannelMessage(TLObject):
    constructor_id = 0x62ba04d9
    subclass_of_id = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param message: Telegram type: "Message".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateNewChannelMessage.constructor_id, signed=False)
        self.message.on_send(writer)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateNewChannelMessage(None, None, None)

    def on_response(self, reader):
        self.message = reader.tgread_object()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateNewChannelMessage#62ba04d9 message:Message pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateNewEncryptedMessage(TLObject):
    constructor_id = 0x12bcbd9a
    subclass_of_id = 0x9f89304e

    def __init__(self, message, qts):
        """
        :param message: Telegram type: "EncryptedMessage".
        :param qts: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.qts = qts

    def to_dict(self):
        return {
            'message': None if self.message is None else self.message.to_dict(),
            'qts': self.qts,
        }

    def on_send(self, writer):
        writer.write_int(UpdateNewEncryptedMessage.constructor_id, signed=False)
        self.message.on_send(writer)
        writer.write_int(self.qts)

    @staticmethod
    def empty():
        return UpdateNewEncryptedMessage(None, None)

    def on_response(self, reader):
        self.message = reader.tgread_object()
        self.qts = reader.read_int()

    def __repr__(self):
        return 'updateNewEncryptedMessage#12bcbd9a message:EncryptedMessage qts:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateNewMessage(TLObject):
    constructor_id = 0x1f2b0afd
    subclass_of_id = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param message: Telegram type: "Message".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateNewMessage.constructor_id, signed=False)
        self.message.on_send(writer)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateNewMessage(None, None, None)

    def on_response(self, reader):
        self.message = reader.tgread_object()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateNewMessage#1f2b0afd message:Message pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateNewStickerSet(TLObject):
    constructor_id = 0x688a30aa
    subclass_of_id = 0x9f89304e

    def __init__(self, stickerset):
        """
        :param stickerset: Telegram type: "messages.StickerSet".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.stickerset = stickerset

    def to_dict(self):
        return {
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateNewStickerSet.constructor_id, signed=False)
        self.stickerset.on_send(writer)

    @staticmethod
    def empty():
        return UpdateNewStickerSet(None)

    def on_response(self, reader):
        self.stickerset = reader.tgread_object()

    def __repr__(self):
        return 'updateNewStickerSet#688a30aa stickerset:messages.StickerSet = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateNotifySettings(TLObject):
    constructor_id = 0xbec268ef
    subclass_of_id = 0x9f89304e

    def __init__(self, peer, notify_settings):
        """
        :param peer: Telegram type: "NotifyPeer".
        :param notify_settings: Telegram type: "PeerNotifySettings".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.peer = peer
        self.notify_settings = notify_settings

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateNotifySettings.constructor_id, signed=False)
        self.peer.on_send(writer)
        self.notify_settings.on_send(writer)

    @staticmethod
    def empty():
        return UpdateNotifySettings(None, None)

    def on_response(self, reader):
        self.peer = reader.tgread_object()
        self.notify_settings = reader.tgread_object()

    def __repr__(self):
        return 'updateNotifySettings#bec268ef peer:NotifyPeer notify_settings:PeerNotifySettings = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdatePhoneCall(TLObject):
    constructor_id = 0xab0f6b1e
    subclass_of_id = 0x9f89304e

    def __init__(self, phone_call):
        """
        :param phone_call: Telegram type: "PhoneCall".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.phone_call = phone_call

    def to_dict(self):
        return {
            'phone_call': None if self.phone_call is None else self.phone_call.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdatePhoneCall.constructor_id, signed=False)
        self.phone_call.on_send(writer)

    @staticmethod
    def empty():
        return UpdatePhoneCall(None)

    def on_response(self, reader):
        self.phone_call = reader.tgread_object()

    def __repr__(self):
        return 'updatePhoneCall#ab0f6b1e phone_call:PhoneCall = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdatePinnedDialogs(TLObject):
    constructor_id = 0xd8caf68d
    subclass_of_id = 0x9f89304e

    def __init__(self, order=None):
        """
        :param order: Telegram type: "Peer". Must be a list.

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.order = order

    def to_dict(self):
        return {
            'order': [] if self.order is None else [None if x is None else x.to_dict() for x in self.order],
        }

    def on_send(self, writer):
        writer.write_int(UpdatePinnedDialogs.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.order else 0
        writer.write_int(flags)

        if self.order:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.order))
            for _x in self.order:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return UpdatePinnedDialogs(None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            reader.read_int()
            self.order = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.order.append(_x)

    def __repr__(self):
        return 'updatePinnedDialogs#d8caf68d flags:# order:flags.0?Vector<Peer> = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdatePrivacy(TLObject):
    constructor_id = 0xee3b272a
    subclass_of_id = 0x9f89304e

    def __init__(self, key, rules):
        """
        :param key: Telegram type: "PrivacyKey".
        :param rules: Telegram type: "PrivacyRule". Must be a list.

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.key = key
        self.rules = rules

    def to_dict(self):
        return {
            'key': None if self.key is None else self.key.to_dict(),
            'rules': [] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules],
        }

    def on_send(self, writer):
        writer.write_int(UpdatePrivacy.constructor_id, signed=False)
        self.key.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.rules))
        for _x in self.rules:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return UpdatePrivacy(None, None)

    def on_response(self, reader):
        self.key = reader.tgread_object()
        reader.read_int()
        self.rules = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.rules.append(_x)

    def __repr__(self):
        return 'updatePrivacy#ee3b272a key:PrivacyKey rules:Vector<PrivacyRule> = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdatePtsChanged(TLObject):
    constructor_id = 0x3354678f
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdatePtsChanged.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdatePtsChanged()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updatePtsChanged#3354678f = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateReadChannelInbox(TLObject):
    constructor_id = 0x4214f37f
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id, max_id):
        """
        :param channel_id: Telegram type: "int".
        :param max_id: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.max_id = max_id

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(UpdateReadChannelInbox.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return UpdateReadChannelInbox(None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        self.max_id = reader.read_int()

    def __repr__(self):
        return 'updateReadChannelInbox#4214f37f channel_id:int max_id:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateReadChannelOutbox(TLObject):
    constructor_id = 0x25d6c9c7
    subclass_of_id = 0x9f89304e

    def __init__(self, channel_id, max_id):
        """
        :param channel_id: Telegram type: "int".
        :param max_id: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.max_id = max_id

    def to_dict(self):
        return {
            'channel_id': self.channel_id,
            'max_id': self.max_id,
        }

    def on_send(self, writer):
        writer.write_int(UpdateReadChannelOutbox.constructor_id, signed=False)
        writer.write_int(self.channel_id)
        writer.write_int(self.max_id)

    @staticmethod
    def empty():
        return UpdateReadChannelOutbox(None, None)

    def on_response(self, reader):
        self.channel_id = reader.read_int()
        self.max_id = reader.read_int()

    def __repr__(self):
        return 'updateReadChannelOutbox#25d6c9c7 channel_id:int max_id:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateReadFeaturedStickers(TLObject):
    constructor_id = 0x571d2742
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdateReadFeaturedStickers.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdateReadFeaturedStickers()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updateReadFeaturedStickers#571d2742 = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateReadHistoryInbox(TLObject):
    constructor_id = 0x9961fd5c
    subclass_of_id = 0x9f89304e

    def __init__(self, peer, max_id, pts, pts_count):
        """
        :param peer: Telegram type: "Peer".
        :param max_id: Telegram type: "int".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.peer = peer
        self.max_id = max_id
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateReadHistoryInbox.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.max_id)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateReadHistoryInbox(None, None, None, None)

    def on_response(self, reader):
        self.peer = reader.tgread_object()
        self.max_id = reader.read_int()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateReadHistoryInbox#9961fd5c peer:Peer max_id:int pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateReadHistoryOutbox(TLObject):
    constructor_id = 0x2f2f21bf
    subclass_of_id = 0x9f89304e

    def __init__(self, peer, max_id, pts, pts_count):
        """
        :param peer: Telegram type: "Peer".
        :param max_id: Telegram type: "int".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.peer = peer
        self.max_id = max_id
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateReadHistoryOutbox.constructor_id, signed=False)
        self.peer.on_send(writer)
        writer.write_int(self.max_id)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateReadHistoryOutbox(None, None, None, None)

    def on_response(self, reader):
        self.peer = reader.tgread_object()
        self.max_id = reader.read_int()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateReadHistoryOutbox#2f2f21bf peer:Peer max_id:int pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateReadMessagesContents(TLObject):
    constructor_id = 0x68c13933
    subclass_of_id = 0x9f89304e

    def __init__(self, messages, pts, pts_count):
        """
        :param messages: Telegram type: "int". Must be a list.
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateReadMessagesContents.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.messages))
        for _x in self.messages:
            writer.write_int(_x)

        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateReadMessagesContents(None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.messages = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_int()
            self.messages.append(_x)

        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateReadMessagesContents#68c13933 messages:Vector<int> pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateRecentStickers(TLObject):
    constructor_id = 0x9a422c20
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdateRecentStickers.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdateRecentStickers()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updateRecentStickers#9a422c20 = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateSavedGifs(TLObject):
    constructor_id = 0x9375341e
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdateSavedGifs.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdateSavedGifs()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updateSavedGifs#9375341e = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateServiceNotification(TLObject):
    constructor_id = 0xebe46819
    subclass_of_id = 0x9f89304e

    def __init__(self, type, message, media, entities, popup=None, inbox_date=None):
        """
        :param popup: Telegram type: "true".
        :param inbox_date: Telegram type: "date".
        :param type: Telegram type: "string".
        :param message: Telegram type: "string".
        :param media: Telegram type: "MessageMedia".
        :param entities: Telegram type: "MessageEntity". Must be a list.

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.popup = popup
        self.inbox_date = inbox_date
        self.type = type
        self.message = message
        self.media = media
        self.entities = entities

    def to_dict(self):
        return {
            'popup': self.popup,
            'inbox_date': self.inbox_date,
            'type': self.type,
            'message': self.message,
            'media': None if self.media is None else self.media.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
        }

    def on_send(self, writer):
        writer.write_int(UpdateServiceNotification.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.popup else 0
        flags |= (1 << 1) if self.inbox_date else 0
        writer.write_int(flags)

        if self.inbox_date:
            writer.tgwrite_date(self.inbox_date)

        writer.tgwrite_string(self.type)
        writer.tgwrite_string(self.message)
        self.media.on_send(writer)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.entities))
        for _x in self.entities:
            _x.on_send(writer)

    @staticmethod
    def empty():
        return UpdateServiceNotification(None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.popup = True

        if (flags & (1 << 1)) != 0:
            self.inbox_date = reader.tgread_date()

        self.type = reader.tgread_string()
        self.message = reader.tgread_string()
        self.media = reader.tgread_object()
        reader.read_int()
        self.entities = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.entities.append(_x)

    def __repr__(self):
        return 'updateServiceNotification#ebe46819 flags:# popup:flags.0?true inbox_date:flags.1?int type:string message:string media:MessageMedia entities:Vector<MessageEntity> = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateShort(TLObject):
    constructor_id = 0x78d4dec1
    subclass_of_id = 0x8af52aac

    def __init__(self, update, date):
        """
        :param update: Telegram type: "Update".
        :param date: Telegram type: "date".

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.update = update
        self.date = date

    def to_dict(self):
        return {
            'update': None if self.update is None else self.update.to_dict(),
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(UpdateShort.constructor_id, signed=False)
        self.update.on_send(writer)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return UpdateShort(None, None)

    def on_response(self, reader):
        self.update = reader.tgread_object()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'updateShort#78d4dec1 update:Update date:int = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateShortChatMessage(TLObject):
    constructor_id = 0x16812688
    subclass_of_id = 0x8af52aac

    def __init__(self, id, from_id, chat_id, message, pts, pts_count, date, out=None, mentioned=None, media_unread=None, silent=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, entities=None):
        """
        :param out: Telegram type: "true".
        :param mentioned: Telegram type: "true".
        :param media_unread: Telegram type: "true".
        :param silent: Telegram type: "true".
        :param id: Telegram type: "int".
        :param from_id: Telegram type: "int".
        :param chat_id: Telegram type: "int".
        :param message: Telegram type: "string".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".
        :param date: Telegram type: "date".
        :param fwd_from: Telegram type: "MessageFwdHeader".
        :param via_bot_id: Telegram type: "int".
        :param reply_to_msg_id: Telegram type: "int".
        :param entities: Telegram type: "MessageEntity". Must be a list.

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.id = id
        self.from_id = from_id
        self.chat_id = chat_id
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to_msg_id = reply_to_msg_id
        self.entities = entities

    def to_dict(self):
        return {
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'id': self.id,
            'from_id': self.from_id,
            'chat_id': self.chat_id,
            'message': self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'fwd_from': None if self.fwd_from is None else self.fwd_from.to_dict(),
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
        }

    def on_send(self, writer):
        writer.write_int(UpdateShortChatMessage.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.out else 0
        flags |= (1 << 4) if self.mentioned else 0
        flags |= (1 << 5) if self.media_unread else 0
        flags |= (1 << 13) if self.silent else 0
        flags |= (1 << 2) if self.fwd_from else 0
        flags |= (1 << 11) if self.via_bot_id else 0
        flags |= (1 << 3) if self.reply_to_msg_id else 0
        flags |= (1 << 7) if self.entities else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        writer.write_int(self.from_id)
        writer.write_int(self.chat_id)
        writer.tgwrite_string(self.message)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)
        writer.tgwrite_date(self.date)
        if self.fwd_from:
            self.fwd_from.on_send(writer)

        if self.via_bot_id:
            writer.write_int(self.via_bot_id)

        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return UpdateShortChatMessage(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.out = True

        if (flags & (1 << 4)) != 0:
            self.mentioned = True

        if (flags & (1 << 5)) != 0:
            self.media_unread = True

        if (flags & (1 << 13)) != 0:
            self.silent = True

        self.id = reader.read_int()
        self.from_id = reader.read_int()
        self.chat_id = reader.read_int()
        self.message = reader.tgread_string()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()
        self.date = reader.tgread_date()
        if (flags & (1 << 2)) != 0:
            self.fwd_from = reader.tgread_object()

        if (flags & (1 << 11)) != 0:
            self.via_bot_id = reader.read_int()

        if (flags & (1 << 3)) != 0:
            self.reply_to_msg_id = reader.read_int()

        if (flags & (1 << 7)) != 0:
            reader.read_int()
            self.entities = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.entities.append(_x)

    def __repr__(self):
        return 'updateShortChatMessage#16812688 flags:# out:flags.1?true mentioned:flags.4?true media_unread:flags.5?true silent:flags.13?true id:int from_id:int chat_id:int message:string pts:int pts_count:int date:int fwd_from:flags.2?MessageFwdHeader via_bot_id:flags.11?int reply_to_msg_id:flags.3?int entities:flags.7?Vector<MessageEntity> = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateShortMessage(TLObject):
    constructor_id = 0x914fbf11
    subclass_of_id = 0x8af52aac

    def __init__(self, id, user_id, message, pts, pts_count, date, out=None, mentioned=None, media_unread=None, silent=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, entities=None):
        """
        :param out: Telegram type: "true".
        :param mentioned: Telegram type: "true".
        :param media_unread: Telegram type: "true".
        :param silent: Telegram type: "true".
        :param id: Telegram type: "int".
        :param user_id: Telegram type: "int".
        :param message: Telegram type: "string".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".
        :param date: Telegram type: "date".
        :param fwd_from: Telegram type: "MessageFwdHeader".
        :param via_bot_id: Telegram type: "int".
        :param reply_to_msg_id: Telegram type: "int".
        :param entities: Telegram type: "MessageEntity". Must be a list.

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.id = id
        self.user_id = user_id
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to_msg_id = reply_to_msg_id
        self.entities = entities

    def to_dict(self):
        return {
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'id': self.id,
            'user_id': self.user_id,
            'message': self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'fwd_from': None if self.fwd_from is None else self.fwd_from.to_dict(),
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
        }

    def on_send(self, writer):
        writer.write_int(UpdateShortMessage.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.out else 0
        flags |= (1 << 4) if self.mentioned else 0
        flags |= (1 << 5) if self.media_unread else 0
        flags |= (1 << 13) if self.silent else 0
        flags |= (1 << 2) if self.fwd_from else 0
        flags |= (1 << 11) if self.via_bot_id else 0
        flags |= (1 << 3) if self.reply_to_msg_id else 0
        flags |= (1 << 7) if self.entities else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        writer.write_int(self.user_id)
        writer.tgwrite_string(self.message)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)
        writer.tgwrite_date(self.date)
        if self.fwd_from:
            self.fwd_from.on_send(writer)

        if self.via_bot_id:
            writer.write_int(self.via_bot_id)

        if self.reply_to_msg_id:
            writer.write_int(self.reply_to_msg_id)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return UpdateShortMessage(None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.out = True

        if (flags & (1 << 4)) != 0:
            self.mentioned = True

        if (flags & (1 << 5)) != 0:
            self.media_unread = True

        if (flags & (1 << 13)) != 0:
            self.silent = True

        self.id = reader.read_int()
        self.user_id = reader.read_int()
        self.message = reader.tgread_string()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()
        self.date = reader.tgread_date()
        if (flags & (1 << 2)) != 0:
            self.fwd_from = reader.tgread_object()

        if (flags & (1 << 11)) != 0:
            self.via_bot_id = reader.read_int()

        if (flags & (1 << 3)) != 0:
            self.reply_to_msg_id = reader.read_int()

        if (flags & (1 << 7)) != 0:
            reader.read_int()
            self.entities = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.entities.append(_x)

    def __repr__(self):
        return 'updateShortMessage#914fbf11 flags:# out:flags.1?true mentioned:flags.4?true media_unread:flags.5?true silent:flags.13?true id:int user_id:int message:string pts:int pts_count:int date:int fwd_from:flags.2?MessageFwdHeader via_bot_id:flags.11?int reply_to_msg_id:flags.3?int entities:flags.7?Vector<MessageEntity> = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateShortSentMessage(TLObject):
    constructor_id = 0x11f1331c
    subclass_of_id = 0x8af52aac

    def __init__(self, id, pts, pts_count, date, out=None, media=None, entities=None):
        """
        :param out: Telegram type: "true".
        :param id: Telegram type: "int".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".
        :param date: Telegram type: "date".
        :param media: Telegram type: "MessageMedia".
        :param entities: Telegram type: "MessageEntity". Must be a list.

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out
        self.id = id
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.media = media
        self.entities = entities

    def to_dict(self):
        return {
            'out': self.out,
            'id': self.id,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'media': None if self.media is None else self.media.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
        }

    def on_send(self, writer):
        writer.write_int(UpdateShortSentMessage.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 1) if self.out else 0
        flags |= (1 << 9) if self.media else 0
        flags |= (1 << 7) if self.entities else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)
        writer.tgwrite_date(self.date)
        if self.media:
            self.media.on_send(writer)

        if self.entities:
            writer.write_int(0x1cb5c415, signed=False)
            writer.write_int(len(self.entities))
            for _x in self.entities:
                if _x:
                    _x.on_send(writer)

    @staticmethod
    def empty():
        return UpdateShortSentMessage(None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 1)) != 0:
            self.out = True

        self.id = reader.read_int()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()
        self.date = reader.tgread_date()
        if (flags & (1 << 9)) != 0:
            self.media = reader.tgread_object()

        if (flags & (1 << 7)) != 0:
            reader.read_int()
            self.entities = []
            _len = reader.read_int()
            for _ in range(_len):
                _x = reader.tgread_object()
                self.entities.append(_x)

    def __repr__(self):
        return 'updateShortSentMessage#11f1331c flags:# out:flags.1?true id:int pts:int pts_count:int date:int media:flags.9?MessageMedia entities:flags.7?Vector<MessageEntity> = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateStickerSets(TLObject):
    constructor_id = 0x43ae3dec
    subclass_of_id = 0x9f89304e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdateStickerSets.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdateStickerSets()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updateStickerSets#43ae3dec = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateStickerSetsOrder(TLObject):
    constructor_id = 0xbb2d201
    subclass_of_id = 0x9f89304e

    def __init__(self, order, masks=None):
        """
        :param masks: Telegram type: "true".
        :param order: Telegram type: "long". Must be a list.

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.masks = masks
        self.order = order

    def to_dict(self):
        return {
            'masks': self.masks,
            'order': [] if self.order is None else self.order[:],
        }

    def on_send(self, writer):
        writer.write_int(UpdateStickerSetsOrder.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.masks else 0
        writer.write_int(flags)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.order))
        for _x in self.order:
            writer.write_long(_x)

    @staticmethod
    def empty():
        return UpdateStickerSetsOrder(None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.masks = True

        reader.read_int()
        self.order = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.read_long()
            self.order.append(_x)

    def __repr__(self):
        return 'updateStickerSetsOrder#0bb2d201 flags:# masks:flags.0?true order:Vector<long> = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateUserBlocked(TLObject):
    constructor_id = 0x80ece81a
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, blocked):
        """
        :param user_id: Telegram type: "int".
        :param blocked: Telegram type: "Bool".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.blocked = blocked

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'blocked': self.blocked,
        }

    def on_send(self, writer):
        writer.write_int(UpdateUserBlocked.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_bool(self.blocked)

    @staticmethod
    def empty():
        return UpdateUserBlocked(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.blocked = reader.tgread_bool()

    def __repr__(self):
        return 'updateUserBlocked#80ece81a user_id:int blocked:Bool = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateUserName(TLObject):
    constructor_id = 0xa7332b73
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, first_name, last_name, username):
        """
        :param user_id: Telegram type: "int".
        :param first_name: Telegram type: "string".
        :param last_name: Telegram type: "string".
        :param username: Telegram type: "string".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.first_name = first_name
        self.last_name = last_name
        self.username = username

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'username': self.username,
        }

    def on_send(self, writer):
        writer.write_int(UpdateUserName.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_string(self.first_name)
        writer.tgwrite_string(self.last_name)
        writer.tgwrite_string(self.username)

    @staticmethod
    def empty():
        return UpdateUserName(None, None, None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.first_name = reader.tgread_string()
        self.last_name = reader.tgread_string()
        self.username = reader.tgread_string()

    def __repr__(self):
        return 'updateUserName#a7332b73 user_id:int first_name:string last_name:string username:string = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateUserPhone(TLObject):
    constructor_id = 0x12b9417b
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, phone):
        """
        :param user_id: Telegram type: "int".
        :param phone: Telegram type: "string".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.phone = phone

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'phone': self.phone,
        }

    def on_send(self, writer):
        writer.write_int(UpdateUserPhone.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_string(self.phone)

    @staticmethod
    def empty():
        return UpdateUserPhone(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.phone = reader.tgread_string()

    def __repr__(self):
        return 'updateUserPhone#12b9417b user_id:int phone:string = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateUserPhoto(TLObject):
    constructor_id = 0x95313b0c
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, date, photo, previous):
        """
        :param user_id: Telegram type: "int".
        :param date: Telegram type: "date".
        :param photo: Telegram type: "UserProfilePhoto".
        :param previous: Telegram type: "Bool".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.date = date
        self.photo = photo
        self.previous = previous

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'date': self.date,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'previous': self.previous,
        }

    def on_send(self, writer):
        writer.write_int(UpdateUserPhoto.constructor_id, signed=False)
        writer.write_int(self.user_id)
        writer.tgwrite_date(self.date)
        self.photo.on_send(writer)
        writer.tgwrite_bool(self.previous)

    @staticmethod
    def empty():
        return UpdateUserPhoto(None, None, None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.date = reader.tgread_date()
        self.photo = reader.tgread_object()
        self.previous = reader.tgread_bool()

    def __repr__(self):
        return 'updateUserPhoto#95313b0c user_id:int date:int photo:UserProfilePhoto previous:Bool = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateUserStatus(TLObject):
    constructor_id = 0x1bfbd823
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, status):
        """
        :param user_id: Telegram type: "int".
        :param status: Telegram type: "UserStatus".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.status = status

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'status': None if self.status is None else self.status.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateUserStatus.constructor_id, signed=False)
        writer.write_int(self.user_id)
        self.status.on_send(writer)

    @staticmethod
    def empty():
        return UpdateUserStatus(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.status = reader.tgread_object()

    def __repr__(self):
        return 'updateUserStatus#1bfbd823 user_id:int status:UserStatus = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateUserTyping(TLObject):
    constructor_id = 0x5c486927
    subclass_of_id = 0x9f89304e

    def __init__(self, user_id, action):
        """
        :param user_id: Telegram type: "int".
        :param action: Telegram type: "SendMessageAction".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.action = action

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UpdateUserTyping.constructor_id, signed=False)
        writer.write_int(self.user_id)
        self.action.on_send(writer)

    @staticmethod
    def empty():
        return UpdateUserTyping(None, None)

    def on_response(self, reader):
        self.user_id = reader.read_int()
        self.action = reader.tgread_object()

    def __repr__(self):
        return 'updateUserTyping#5c486927 user_id:int action:SendMessageAction = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdateWebPage(TLObject):
    constructor_id = 0x7f891213
    subclass_of_id = 0x9f89304e

    def __init__(self, webpage, pts, pts_count):
        """
        :param webpage: Telegram type: "WebPage".
        :param pts: Telegram type: "int".
        :param pts_count: Telegram type: "int".

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.webpage = webpage
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            'webpage': None if self.webpage is None else self.webpage.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def on_send(self, writer):
        writer.write_int(UpdateWebPage.constructor_id, signed=False)
        self.webpage.on_send(writer)
        writer.write_int(self.pts)
        writer.write_int(self.pts_count)

    @staticmethod
    def empty():
        return UpdateWebPage(None, None, None)

    def on_response(self, reader):
        self.webpage = reader.tgread_object()
        self.pts = reader.read_int()
        self.pts_count = reader.read_int()

    def __repr__(self):
        return 'updateWebPage#7f891213 webpage:WebPage pts:int pts_count:int = Update'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class Updates(TLObject):
    constructor_id = 0x74ae4240
    subclass_of_id = 0x8af52aac

    def __init__(self, updates, users, chats, date, seq):
        """
        :param updates: Telegram type: "Update". Must be a list.
        :param users: Telegram type: "User". Must be a list.
        :param chats: Telegram type: "Chat". Must be a list.
        :param date: Telegram type: "date".
        :param seq: Telegram type: "int".

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.updates = updates
        self.users = users
        self.chats = chats
        self.date = date
        self.seq = seq

    def to_dict(self):
        return {
            'updates': [] if self.updates is None else [None if x is None else x.to_dict() for x in self.updates],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'date': self.date,
            'seq': self.seq,
        }

    def on_send(self, writer):
        writer.write_int(Updates.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.updates))
        for _x in self.updates:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.tgwrite_date(self.date)
        writer.write_int(self.seq)

    @staticmethod
    def empty():
        return Updates(None, None, None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.updates = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.updates.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        self.date = reader.tgread_date()
        self.seq = reader.read_int()

    def __repr__(self):
        return 'updates#74ae4240 updates:Vector<Update> users:Vector<User> chats:Vector<Chat> date:int seq:int = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdatesCombined(TLObject):
    constructor_id = 0x725b04c3
    subclass_of_id = 0x8af52aac

    def __init__(self, updates, users, chats, date, seq_start, seq):
        """
        :param updates: Telegram type: "Update". Must be a list.
        :param users: Telegram type: "User". Must be a list.
        :param chats: Telegram type: "Chat". Must be a list.
        :param date: Telegram type: "date".
        :param seq_start: Telegram type: "int".
        :param seq: Telegram type: "int".

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.updates = updates
        self.users = users
        self.chats = chats
        self.date = date
        self.seq_start = seq_start
        self.seq = seq

    def to_dict(self):
        return {
            'updates': [] if self.updates is None else [None if x is None else x.to_dict() for x in self.updates],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'date': self.date,
            'seq_start': self.seq_start,
            'seq': self.seq,
        }

    def on_send(self, writer):
        writer.write_int(UpdatesCombined.constructor_id, signed=False)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.updates))
        for _x in self.updates:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.users))
        for _x in self.users:
            _x.on_send(writer)

        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.chats))
        for _x in self.chats:
            _x.on_send(writer)

        writer.tgwrite_date(self.date)
        writer.write_int(self.seq_start)
        writer.write_int(self.seq)

    @staticmethod
    def empty():
        return UpdatesCombined(None, None, None, None, None, None)

    def on_response(self, reader):
        reader.read_int()
        self.updates = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.updates.append(_x)

        reader.read_int()
        self.users = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.users.append(_x)

        reader.read_int()
        self.chats = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.chats.append(_x)

        self.date = reader.tgread_date()
        self.seq_start = reader.read_int()
        self.seq = reader.read_int()

    def __repr__(self):
        return 'updatesCombined#725b04c3 updates:Vector<Update> users:Vector<User> chats:Vector<Chat> date:int seq_start:int seq:int = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UpdatesTooLong(TLObject):
    constructor_id = 0xe317af7e
    subclass_of_id = 0x8af52aac

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UpdatesTooLong.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UpdatesTooLong()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'updatesTooLong#e317af7e = Updates'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class User(TLObject):
    constructor_id = 0x2e13f4c3
    subclass_of_id = 0x2da17977

    def __init__(self, id, is_self=None, contact=None, mutual_contact=None, deleted=None, bot=None, bot_chat_history=None, bot_nochats=None, verified=None, restricted=None, min=None, bot_inline_geo=None, access_hash=None, first_name=None, last_name=None, username=None, phone=None, photo=None, status=None, bot_info_version=None, restriction_reason=None, bot_inline_placeholder=None, lang_code=None):
        """
        :param is_self: Telegram type: "true".
        :param contact: Telegram type: "true".
        :param mutual_contact: Telegram type: "true".
        :param deleted: Telegram type: "true".
        :param bot: Telegram type: "true".
        :param bot_chat_history: Telegram type: "true".
        :param bot_nochats: Telegram type: "true".
        :param verified: Telegram type: "true".
        :param restricted: Telegram type: "true".
        :param min: Telegram type: "true".
        :param bot_inline_geo: Telegram type: "true".
        :param id: Telegram type: "int".
        :param access_hash: Telegram type: "long".
        :param first_name: Telegram type: "string".
        :param last_name: Telegram type: "string".
        :param username: Telegram type: "string".
        :param phone: Telegram type: "string".
        :param photo: Telegram type: "UserProfilePhoto".
        :param status: Telegram type: "UserStatus".
        :param bot_info_version: Telegram type: "int".
        :param restriction_reason: Telegram type: "string".
        :param bot_inline_placeholder: Telegram type: "string".
        :param lang_code: Telegram type: "string".

        Constructor for User: Instance of either UserEmpty, User.
        """
        super().__init__()

        self.is_self = is_self
        self.contact = contact
        self.mutual_contact = mutual_contact
        self.deleted = deleted
        self.bot = bot
        self.bot_chat_history = bot_chat_history
        self.bot_nochats = bot_nochats
        self.verified = verified
        self.restricted = restricted
        self.min = min
        self.bot_inline_geo = bot_inline_geo
        self.id = id
        self.access_hash = access_hash
        self.first_name = first_name
        self.last_name = last_name
        self.username = username
        self.phone = phone
        self.photo = photo
        self.status = status
        self.bot_info_version = bot_info_version
        self.restriction_reason = restriction_reason
        self.bot_inline_placeholder = bot_inline_placeholder
        self.lang_code = lang_code

    def to_dict(self):
        return {
            'is_self': self.is_self,
            'contact': self.contact,
            'mutual_contact': self.mutual_contact,
            'deleted': self.deleted,
            'bot': self.bot,
            'bot_chat_history': self.bot_chat_history,
            'bot_nochats': self.bot_nochats,
            'verified': self.verified,
            'restricted': self.restricted,
            'min': self.min,
            'bot_inline_geo': self.bot_inline_geo,
            'id': self.id,
            'access_hash': self.access_hash,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'username': self.username,
            'phone': self.phone,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'status': None if self.status is None else self.status.to_dict(),
            'bot_info_version': self.bot_info_version,
            'restriction_reason': self.restriction_reason,
            'bot_inline_placeholder': self.bot_inline_placeholder,
            'lang_code': self.lang_code,
        }

    def on_send(self, writer):
        writer.write_int(User.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 10) if self.is_self else 0
        flags |= (1 << 11) if self.contact else 0
        flags |= (1 << 12) if self.mutual_contact else 0
        flags |= (1 << 13) if self.deleted else 0
        flags |= (1 << 14) if self.bot else 0
        flags |= (1 << 15) if self.bot_chat_history else 0
        flags |= (1 << 16) if self.bot_nochats else 0
        flags |= (1 << 17) if self.verified else 0
        flags |= (1 << 18) if self.restricted else 0
        flags |= (1 << 20) if self.min else 0
        flags |= (1 << 21) if self.bot_inline_geo else 0
        flags |= (1 << 0) if self.access_hash else 0
        flags |= (1 << 1) if self.first_name else 0
        flags |= (1 << 2) if self.last_name else 0
        flags |= (1 << 3) if self.username else 0
        flags |= (1 << 4) if self.phone else 0
        flags |= (1 << 5) if self.photo else 0
        flags |= (1 << 6) if self.status else 0
        flags |= (1 << 14) if self.bot_info_version else 0
        flags |= (1 << 18) if self.restriction_reason else 0
        flags |= (1 << 19) if self.bot_inline_placeholder else 0
        flags |= (1 << 22) if self.lang_code else 0
        writer.write_int(flags)

        writer.write_int(self.id)
        if self.access_hash:
            writer.write_long(self.access_hash)

        if self.first_name:
            writer.tgwrite_string(self.first_name)

        if self.last_name:
            writer.tgwrite_string(self.last_name)

        if self.username:
            writer.tgwrite_string(self.username)

        if self.phone:
            writer.tgwrite_string(self.phone)

        if self.photo:
            self.photo.on_send(writer)

        if self.status:
            self.status.on_send(writer)

        if self.bot_info_version:
            writer.write_int(self.bot_info_version)

        if self.restriction_reason:
            writer.tgwrite_string(self.restriction_reason)

        if self.bot_inline_placeholder:
            writer.tgwrite_string(self.bot_inline_placeholder)

        if self.lang_code:
            writer.tgwrite_string(self.lang_code)

    @staticmethod
    def empty():
        return User(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 10)) != 0:
            self.is_self = True

        if (flags & (1 << 11)) != 0:
            self.contact = True

        if (flags & (1 << 12)) != 0:
            self.mutual_contact = True

        if (flags & (1 << 13)) != 0:
            self.deleted = True

        if (flags & (1 << 14)) != 0:
            self.bot = True

        if (flags & (1 << 15)) != 0:
            self.bot_chat_history = True

        if (flags & (1 << 16)) != 0:
            self.bot_nochats = True

        if (flags & (1 << 17)) != 0:
            self.verified = True

        if (flags & (1 << 18)) != 0:
            self.restricted = True

        if (flags & (1 << 20)) != 0:
            self.min = True

        if (flags & (1 << 21)) != 0:
            self.bot_inline_geo = True

        self.id = reader.read_int()
        if (flags & (1 << 0)) != 0:
            self.access_hash = reader.read_long()

        if (flags & (1 << 1)) != 0:
            self.first_name = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.last_name = reader.tgread_string()

        if (flags & (1 << 3)) != 0:
            self.username = reader.tgread_string()

        if (flags & (1 << 4)) != 0:
            self.phone = reader.tgread_string()

        if (flags & (1 << 5)) != 0:
            self.photo = reader.tgread_object()

        if (flags & (1 << 6)) != 0:
            self.status = reader.tgread_object()

        if (flags & (1 << 14)) != 0:
            self.bot_info_version = reader.read_int()

        if (flags & (1 << 18)) != 0:
            self.restriction_reason = reader.tgread_string()

        if (flags & (1 << 19)) != 0:
            self.bot_inline_placeholder = reader.tgread_string()

        if (flags & (1 << 22)) != 0:
            self.lang_code = reader.tgread_string()

    def __repr__(self):
        return 'user#2e13f4c3 flags:# is_self:flags.10?true contact:flags.11?true mutual_contact:flags.12?true deleted:flags.13?true bot:flags.14?true bot_chat_history:flags.15?true bot_nochats:flags.16?true verified:flags.17?true restricted:flags.18?true min:flags.20?true bot_inline_geo:flags.21?true id:int access_hash:flags.0?long first_name:flags.1?string last_name:flags.2?string username:flags.3?string phone:flags.4?string photo:flags.5?UserProfilePhoto status:flags.6?UserStatus bot_info_version:flags.14?int restriction_reason:flags.18?string bot_inline_placeholder:flags.19?string lang_code:flags.22?string = User'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserEmpty(TLObject):
    constructor_id = 0x200250ba
    subclass_of_id = 0x2da17977

    def __init__(self, id):
        """
        :param id: Telegram type: "int".

        Constructor for User: Instance of either UserEmpty, User.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(UserEmpty.constructor_id, signed=False)
        writer.write_int(self.id)

    @staticmethod
    def empty():
        return UserEmpty(None)

    def on_response(self, reader):
        self.id = reader.read_int()

    def __repr__(self):
        return 'userEmpty#200250ba id:int = User'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserFull(TLObject):
    constructor_id = 0xf220f3f
    subclass_of_id = 0x1f4661b9

    def __init__(self, user, link, notify_settings, common_chats_count, blocked=None, phone_calls_available=None, phone_calls_private=None, about=None, profile_photo=None, bot_info=None):
        """
        :param blocked: Telegram type: "true".
        :param phone_calls_available: Telegram type: "true".
        :param phone_calls_private: Telegram type: "true".
        :param user: Telegram type: "User".
        :param about: Telegram type: "string".
        :param link: Telegram type: "contacts.Link".
        :param profile_photo: Telegram type: "Photo".
        :param notify_settings: Telegram type: "PeerNotifySettings".
        :param bot_info: Telegram type: "BotInfo".
        :param common_chats_count: Telegram type: "int".

        Constructor for UserFull: Instance of UserFull.
        """
        super().__init__()

        self.blocked = blocked
        self.phone_calls_available = phone_calls_available
        self.phone_calls_private = phone_calls_private
        self.user = user
        self.about = about
        self.link = link
        self.profile_photo = profile_photo
        self.notify_settings = notify_settings
        self.bot_info = bot_info
        self.common_chats_count = common_chats_count

    def to_dict(self):
        return {
            'blocked': self.blocked,
            'phone_calls_available': self.phone_calls_available,
            'phone_calls_private': self.phone_calls_private,
            'user': None if self.user is None else self.user.to_dict(),
            'about': self.about,
            'link': None if self.link is None else self.link.to_dict(),
            'profile_photo': None if self.profile_photo is None else self.profile_photo.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'bot_info': None if self.bot_info is None else self.bot_info.to_dict(),
            'common_chats_count': self.common_chats_count,
        }

    def on_send(self, writer):
        writer.write_int(UserFull.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.blocked else 0
        flags |= (1 << 4) if self.phone_calls_available else 0
        flags |= (1 << 5) if self.phone_calls_private else 0
        flags |= (1 << 1) if self.about else 0
        flags |= (1 << 2) if self.profile_photo else 0
        flags |= (1 << 3) if self.bot_info else 0
        writer.write_int(flags)

        self.user.on_send(writer)
        if self.about:
            writer.tgwrite_string(self.about)

        self.link.on_send(writer)
        if self.profile_photo:
            self.profile_photo.on_send(writer)

        self.notify_settings.on_send(writer)
        if self.bot_info:
            self.bot_info.on_send(writer)

        writer.write_int(self.common_chats_count)

    @staticmethod
    def empty():
        return UserFull(None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        if (flags & (1 << 0)) != 0:
            self.blocked = True

        if (flags & (1 << 4)) != 0:
            self.phone_calls_available = True

        if (flags & (1 << 5)) != 0:
            self.phone_calls_private = True

        self.user = reader.tgread_object()
        if (flags & (1 << 1)) != 0:
            self.about = reader.tgread_string()

        self.link = reader.tgread_object()
        if (flags & (1 << 2)) != 0:
            self.profile_photo = reader.tgread_object()

        self.notify_settings = reader.tgread_object()
        if (flags & (1 << 3)) != 0:
            self.bot_info = reader.tgread_object()

        self.common_chats_count = reader.read_int()

    def __repr__(self):
        return 'userFull#0f220f3f flags:# blocked:flags.0?true phone_calls_available:flags.4?true phone_calls_private:flags.5?true user:User about:flags.1?string link:contacts.Link profile_photo:flags.2?Photo notify_settings:PeerNotifySettings bot_info:flags.3?BotInfo common_chats_count:int = UserFull'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserProfilePhoto(TLObject):
    constructor_id = 0xd559d8c8
    subclass_of_id = 0xc6338f7d

    def __init__(self, photo_id, photo_small, photo_big):
        """
        :param photo_id: Telegram type: "long".
        :param photo_small: Telegram type: "FileLocation".
        :param photo_big: Telegram type: "FileLocation".

        Constructor for UserProfilePhoto: Instance of either UserProfilePhotoEmpty, UserProfilePhoto.
        """
        super().__init__()

        self.photo_id = photo_id
        self.photo_small = photo_small
        self.photo_big = photo_big

    def to_dict(self):
        return {
            'photo_id': self.photo_id,
            'photo_small': None if self.photo_small is None else self.photo_small.to_dict(),
            'photo_big': None if self.photo_big is None else self.photo_big.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(UserProfilePhoto.constructor_id, signed=False)
        writer.write_long(self.photo_id)
        self.photo_small.on_send(writer)
        self.photo_big.on_send(writer)

    @staticmethod
    def empty():
        return UserProfilePhoto(None, None, None)

    def on_response(self, reader):
        self.photo_id = reader.read_long()
        self.photo_small = reader.tgread_object()
        self.photo_big = reader.tgread_object()

    def __repr__(self):
        return 'userProfilePhoto#d559d8c8 photo_id:long photo_small:FileLocation photo_big:FileLocation = UserProfilePhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserProfilePhotoEmpty(TLObject):
    constructor_id = 0x4f11bae1
    subclass_of_id = 0xc6338f7d

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UserProfilePhotoEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UserProfilePhotoEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'userProfilePhotoEmpty#4f11bae1 = UserProfilePhoto'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserStatusEmpty(TLObject):
    constructor_id = 0x9d05049
    subclass_of_id = 0x5b0b743e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UserStatusEmpty.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UserStatusEmpty()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'userStatusEmpty#09d05049 = UserStatus'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserStatusLastMonth(TLObject):
    constructor_id = 0x77ebc742
    subclass_of_id = 0x5b0b743e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UserStatusLastMonth.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UserStatusLastMonth()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'userStatusLastMonth#77ebc742 = UserStatus'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserStatusLastWeek(TLObject):
    constructor_id = 0x7bf09fc
    subclass_of_id = 0x5b0b743e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UserStatusLastWeek.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UserStatusLastWeek()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'userStatusLastWeek#07bf09fc = UserStatus'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserStatusOffline(TLObject):
    constructor_id = 0x8c703f
    subclass_of_id = 0x5b0b743e

    def __init__(self, was_online):
        """
        :param was_online: Telegram type: "date".

        Constructor for UserStatus: Instance of either UserStatusEmpty, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth.
        """
        super().__init__()

        self.was_online = was_online

    def to_dict(self):
        return {
            'was_online': self.was_online,
        }

    def on_send(self, writer):
        writer.write_int(UserStatusOffline.constructor_id, signed=False)
        writer.tgwrite_date(self.was_online)

    @staticmethod
    def empty():
        return UserStatusOffline(None)

    def on_response(self, reader):
        self.was_online = reader.tgread_date()

    def __repr__(self):
        return 'userStatusOffline#008c703f was_online:int = UserStatus'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserStatusOnline(TLObject):
    constructor_id = 0xedb93949
    subclass_of_id = 0x5b0b743e

    def __init__(self, expires):
        """
        :param expires: Telegram type: "date".

        Constructor for UserStatus: Instance of either UserStatusEmpty, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth.
        """
        super().__init__()

        self.expires = expires

    def to_dict(self):
        return {
            'expires': self.expires,
        }

    def on_send(self, writer):
        writer.write_int(UserStatusOnline.constructor_id, signed=False)
        writer.tgwrite_date(self.expires)

    @staticmethod
    def empty():
        return UserStatusOnline(None)

    def on_response(self, reader):
        self.expires = reader.tgread_date()

    def __repr__(self):
        return 'userStatusOnline#edb93949 expires:int = UserStatus'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class UserStatusRecently(TLObject):
    constructor_id = 0xe26f42f1
    subclass_of_id = 0x5b0b743e

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(UserStatusRecently.constructor_id, signed=False)

    @staticmethod
    def empty():
        return UserStatusRecently()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'userStatusRecently#e26f42f1 = UserStatus'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class WallPaper(TLObject):
    constructor_id = 0xccb03657
    subclass_of_id = 0x96a2c98b

    def __init__(self, id, title, sizes, color):
        """
        :param id: Telegram type: "int".
        :param title: Telegram type: "string".
        :param sizes: Telegram type: "PhotoSize". Must be a list.
        :param color: Telegram type: "int".

        Constructor for WallPaper: Instance of either WallPaper, WallPaperSolid.
        """
        super().__init__()

        self.id = id
        self.title = title
        self.sizes = sizes
        self.color = color

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'sizes': [] if self.sizes is None else [None if x is None else x.to_dict() for x in self.sizes],
            'color': self.color,
        }

    def on_send(self, writer):
        writer.write_int(WallPaper.constructor_id, signed=False)
        writer.write_int(self.id)
        writer.tgwrite_string(self.title)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.sizes))
        for _x in self.sizes:
            _x.on_send(writer)

        writer.write_int(self.color)

    @staticmethod
    def empty():
        return WallPaper(None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.title = reader.tgread_string()
        reader.read_int()
        self.sizes = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.sizes.append(_x)

        self.color = reader.read_int()

    def __repr__(self):
        return 'wallPaper#ccb03657 id:int title:string sizes:Vector<PhotoSize> color:int = WallPaper'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class WallPaperSolid(TLObject):
    constructor_id = 0x63117f24
    subclass_of_id = 0x96a2c98b

    def __init__(self, id, title, bg_color, color):
        """
        :param id: Telegram type: "int".
        :param title: Telegram type: "string".
        :param bg_color: Telegram type: "int".
        :param color: Telegram type: "int".

        Constructor for WallPaper: Instance of either WallPaper, WallPaperSolid.
        """
        super().__init__()

        self.id = id
        self.title = title
        self.bg_color = bg_color
        self.color = color

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'bg_color': self.bg_color,
            'color': self.color,
        }

    def on_send(self, writer):
        writer.write_int(WallPaperSolid.constructor_id, signed=False)
        writer.write_int(self.id)
        writer.tgwrite_string(self.title)
        writer.write_int(self.bg_color)
        writer.write_int(self.color)

    @staticmethod
    def empty():
        return WallPaperSolid(None, None, None, None)

    def on_response(self, reader):
        self.id = reader.read_int()
        self.title = reader.tgread_string()
        self.bg_color = reader.read_int()
        self.color = reader.read_int()

    def __repr__(self):
        return 'wallPaperSolid#63117f24 id:int title:string bg_color:int color:int = WallPaper'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class WebDocument(TLObject):
    constructor_id = 0xc61acbd8
    subclass_of_id = 0x3b642814

    def __init__(self, url, access_hash, size, mime_type, attributes, dc_id):
        """
        :param url: Telegram type: "string".
        :param access_hash: Telegram type: "long".
        :param size: Telegram type: "int".
        :param mime_type: Telegram type: "string".
        :param attributes: Telegram type: "DocumentAttribute". Must be a list.
        :param dc_id: Telegram type: "int".

        Constructor for WebDocument: Instance of WebDocument.
        """
        super().__init__()

        self.url = url
        self.access_hash = access_hash
        self.size = size
        self.mime_type = mime_type
        self.attributes = attributes
        self.dc_id = dc_id

    def to_dict(self):
        return {
            'url': self.url,
            'access_hash': self.access_hash,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes],
            'dc_id': self.dc_id,
        }

    def on_send(self, writer):
        writer.write_int(WebDocument.constructor_id, signed=False)
        writer.tgwrite_string(self.url)
        writer.write_long(self.access_hash)
        writer.write_int(self.size)
        writer.tgwrite_string(self.mime_type)
        writer.write_int(0x1cb5c415, signed=False)
        writer.write_int(len(self.attributes))
        for _x in self.attributes:
            _x.on_send(writer)

        writer.write_int(self.dc_id)

    @staticmethod
    def empty():
        return WebDocument(None, None, None, None, None, None)

    def on_response(self, reader):
        self.url = reader.tgread_string()
        self.access_hash = reader.read_long()
        self.size = reader.read_int()
        self.mime_type = reader.tgread_string()
        reader.read_int()
        self.attributes = []
        _len = reader.read_int()
        for _ in range(_len):
            _x = reader.tgread_object()
            self.attributes.append(_x)

        self.dc_id = reader.read_int()

    def __repr__(self):
        return 'webDocument#c61acbd8 url:string access_hash:long size:int mime_type:string attributes:Vector<DocumentAttribute> dc_id:int = WebDocument'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class WebPage(TLObject):
    constructor_id = 0x5f07b4bc
    subclass_of_id = 0x55a97481

    def __init__(self, id, url, display_url, hash, type=None, site_name=None, title=None, description=None, photo=None, embed_url=None, embed_type=None, embed_width=None, embed_height=None, duration=None, author=None, document=None, cached_page=None):
        """
        :param id: Telegram type: "long".
        :param url: Telegram type: "string".
        :param display_url: Telegram type: "string".
        :param hash: Telegram type: "int".
        :param type: Telegram type: "string".
        :param site_name: Telegram type: "string".
        :param title: Telegram type: "string".
        :param description: Telegram type: "string".
        :param photo: Telegram type: "Photo".
        :param embed_url: Telegram type: "string".
        :param embed_type: Telegram type: "string".
        :param embed_width: Telegram type: "int".
        :param embed_height: Telegram type: "int".
        :param duration: Telegram type: "int".
        :param author: Telegram type: "string".
        :param document: Telegram type: "Document".
        :param cached_page: Telegram type: "Page".

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id
        self.url = url
        self.display_url = display_url
        self.hash = hash
        self.type = type
        self.site_name = site_name
        self.title = title
        self.description = description
        self.photo = photo
        self.embed_url = embed_url
        self.embed_type = embed_type
        self.embed_width = embed_width
        self.embed_height = embed_height
        self.duration = duration
        self.author = author
        self.document = document
        self.cached_page = cached_page

    def to_dict(self):
        return {
            'id': self.id,
            'url': self.url,
            'display_url': self.display_url,
            'hash': self.hash,
            'type': self.type,
            'site_name': self.site_name,
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'embed_url': self.embed_url,
            'embed_type': self.embed_type,
            'embed_width': self.embed_width,
            'embed_height': self.embed_height,
            'duration': self.duration,
            'author': self.author,
            'document': None if self.document is None else self.document.to_dict(),
            'cached_page': None if self.cached_page is None else self.cached_page.to_dict(),
        }

    def on_send(self, writer):
        writer.write_int(WebPage.constructor_id, signed=False)
        flags = 0
        flags |= (1 << 0) if self.type else 0
        flags |= (1 << 1) if self.site_name else 0
        flags |= (1 << 2) if self.title else 0
        flags |= (1 << 3) if self.description else 0
        flags |= (1 << 4) if self.photo else 0
        flags |= (1 << 5) if self.embed_url else 0
        flags |= (1 << 5) if self.embed_type else 0
        flags |= (1 << 6) if self.embed_width else 0
        flags |= (1 << 6) if self.embed_height else 0
        flags |= (1 << 7) if self.duration else 0
        flags |= (1 << 8) if self.author else 0
        flags |= (1 << 9) if self.document else 0
        flags |= (1 << 10) if self.cached_page else 0
        writer.write_int(flags)

        writer.write_long(self.id)
        writer.tgwrite_string(self.url)
        writer.tgwrite_string(self.display_url)
        writer.write_int(self.hash)
        if self.type:
            writer.tgwrite_string(self.type)

        if self.site_name:
            writer.tgwrite_string(self.site_name)

        if self.title:
            writer.tgwrite_string(self.title)

        if self.description:
            writer.tgwrite_string(self.description)

        if self.photo:
            self.photo.on_send(writer)

        if self.embed_url:
            writer.tgwrite_string(self.embed_url)

        if self.embed_type:
            writer.tgwrite_string(self.embed_type)

        if self.embed_width:
            writer.write_int(self.embed_width)

        if self.embed_height:
            writer.write_int(self.embed_height)

        if self.duration:
            writer.write_int(self.duration)

        if self.author:
            writer.tgwrite_string(self.author)

        if self.document:
            self.document.on_send(writer)

        if self.cached_page:
            self.cached_page.on_send(writer)

    @staticmethod
    def empty():
        return WebPage(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def on_response(self, reader):
        flags = reader.read_int()

        self.id = reader.read_long()
        self.url = reader.tgread_string()
        self.display_url = reader.tgread_string()
        self.hash = reader.read_int()
        if (flags & (1 << 0)) != 0:
            self.type = reader.tgread_string()

        if (flags & (1 << 1)) != 0:
            self.site_name = reader.tgread_string()

        if (flags & (1 << 2)) != 0:
            self.title = reader.tgread_string()

        if (flags & (1 << 3)) != 0:
            self.description = reader.tgread_string()

        if (flags & (1 << 4)) != 0:
            self.photo = reader.tgread_object()

        if (flags & (1 << 5)) != 0:
            self.embed_url = reader.tgread_string()

        if (flags & (1 << 5)) != 0:
            self.embed_type = reader.tgread_string()

        if (flags & (1 << 6)) != 0:
            self.embed_width = reader.read_int()

        if (flags & (1 << 6)) != 0:
            self.embed_height = reader.read_int()

        if (flags & (1 << 7)) != 0:
            self.duration = reader.read_int()

        if (flags & (1 << 8)) != 0:
            self.author = reader.tgread_string()

        if (flags & (1 << 9)) != 0:
            self.document = reader.tgread_object()

        if (flags & (1 << 10)) != 0:
            self.cached_page = reader.tgread_object()

    def __repr__(self):
        return 'webPage#5f07b4bc flags:# id:long url:string display_url:string hash:int type:flags.0?string site_name:flags.1?string title:flags.2?string description:flags.3?string photo:flags.4?Photo embed_url:flags.5?string embed_type:flags.5?string embed_width:flags.6?int embed_height:flags.6?int duration:flags.7?int author:flags.8?string document:flags.9?Document cached_page:flags.10?Page = WebPage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class WebPageEmpty(TLObject):
    constructor_id = 0xeb1477e8
    subclass_of_id = 0x55a97481

    def __init__(self, id):
        """
        :param id: Telegram type: "long".

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id

    def to_dict(self):
        return {
            'id': self.id,
        }

    def on_send(self, writer):
        writer.write_int(WebPageEmpty.constructor_id, signed=False)
        writer.write_long(self.id)

    @staticmethod
    def empty():
        return WebPageEmpty(None)

    def on_response(self, reader):
        self.id = reader.read_long()

    def __repr__(self):
        return 'webPageEmpty#eb1477e8 id:long = WebPage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class WebPageNotModified(TLObject):
    constructor_id = 0x85849473
    subclass_of_id = 0x55a97481

    def __init__(self):
        super().__init__()

    @staticmethod
    def to_dict():
        return {}

    def on_send(self, writer):
        writer.write_int(WebPageNotModified.constructor_id, signed=False)

    @staticmethod
    def empty():
        return WebPageNotModified()

    def on_response(self, reader):
        pass

    def __repr__(self):
        return 'webPageNotModified#85849473 = WebPage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)



class WebPagePending(TLObject):
    constructor_id = 0xc586da1c
    subclass_of_id = 0x55a97481

    def __init__(self, id, date):
        """
        :param id: Telegram type: "long".
        :param date: Telegram type: "date".

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id
        self.date = date

    def to_dict(self):
        return {
            'id': self.id,
            'date': self.date,
        }

    def on_send(self, writer):
        writer.write_int(WebPagePending.constructor_id, signed=False)
        writer.write_long(self.id)
        writer.tgwrite_date(self.date)

    @staticmethod
    def empty():
        return WebPagePending(None, None)

    def on_response(self, reader):
        self.id = reader.read_long()
        self.date = reader.tgread_date()

    def __repr__(self):
        return 'webPagePending#c586da1c id:long date:int = WebPage'

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)

