import collections
from numbers import Number
import os



##############################################################################################################
#
# NOTE !!!
#
# THIS FILE MAY BE AUTOGENERATED.
# ONLY MODIFY THE ORIGINAL FILE IN THE /sharedData/ FOLDER!
# OTHER INSTANCES OF THIS FILE ARE COPIES!
#
# NOTE !
#
##############################################################################################################


class Identifier:
    """
    a token by which objects of different types can be compared.
    This has a serverside SQL counterpart called IdentifierModel.
    All objects that are read from the input have an identifier.
    All objects generated during the output have a preliminary identifier, because the output will be interpreted by the Execution Environment.
    (preliminary identifiers can be used like any other).
    An identifier may optionally also have a name.
    Identifiers provided by the server will have this field set if the Identifier refers to an object with a name.
    If both an ID and a name are given, the ID takes precedence.
    """
    def __init__(self, model_id, type, preliminary=False, name=None):
        self.id = model_id
        self.type = type
        self.preliminary = preliminary
        self.name = name
    def __str__(self):
        return "%s Identifier %s%s" % (self.type, self.id, " (preliminary)" if self.preliminry else "")
    def __hash__(self):
        """
        override the default hashing, to make equality comparisons possible
        """
        res = hash(self.type)
        res *= 17
        res += hash(self.id)
        res *= 17
        res += hash(self.preliminary)
        return res
    def __eq__(self, other):
        """
        Override the default Equals behavior
        """
        return (self.type == other.type) and (self.id == other.id) and (self.preliminary == other.preliminary)
    def __ne__(self, other):
        """
        Define a non-equality test
        """
        return not self.__eq__(other)
    def to_json(self):
        """
        gives a JSON dictionary representation of this identifier.
        Counterpart to parse_identifier().
        """
        res = {
            'type' : self.type,
            'id' : self.id,
        }
        if self.preliminary:
            res['preliminary'] = True
        if self.name:
            res['name'] = self.name
        return res
    def get_program_name_and_version_separately(self):
        """
        if this Identifier refers to a program and has a name, splits the name into the base name and the version and returns a tuple of both.
        """
        if self.type != 'program':
            raise ValueError("this Identifier does not refer to a program.")
        if self.name is None:
            raise ValueError("this program Identifier does not have its name set.")
        if '#' not in self.name:
            raise ValueError("no version is given for this Identifier. This should not be possible.")
        l = self.name.split('#')
        name = l[0]
        version = int(l[1])
        return name, version


def parse_identifier(dictionary):
        """
        creates an Identifier from a JSON dictionary structure
        Counterpart to Identifier.to_json().
        """
        id = dictionary['id']
        type = dictionary['type']
        preliminary = dictionary.get('preliminary', False)
        name = dictionary.get('name', None)
        return Identifier(id, type, preliminary=preliminary, name=name)


_preliminary_dentifier_counter = 0
def create_preliminary_identifier(type, name=None):
    """
    creates a preliminary Identifier, for use by output objects.
    """
    global _preliminary_dentifier_counter
    res = Identifier(_preliminary_dentifier_counter, type, preliminary=True, name=name)
    _preliminary_dentifier_counter += 1
    return res


class Program:
    """
    represents a Program on the server.
    This object is only created from the corresponding serverside object, which is why no type checking or parameter verification is done here.
    """
    def __init__(self, identifier, name, version, description):
        self.identifier
        self.name
        self.version
        self.description
    def to_json(self):
        """
        creates a JSON dictionary structure form this object.
        Counterpart to parse_program().
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'name' : self.name,
            'version' : self.version,
            'description' : self.description,
        }
        return res


def parse_program(dictionary):
    """
    creates an Program from a JSON dictionary structure
    Counterpart to Program.to_json().
    """
    identifier = parse_identifier(dictionary['identifier'])
    name = dictionary['name']
    version = dictionary['version']
    description = dictionary['description']
    res = Program(identifier, name, version, description)
    return res


class Symbol:
    """
    represents a SymbolModel on the server.
    Symbols have a name and a description, and exist for communication purposes.
    """
    def __init__(self, identifier, name, description):
        self.identifier = identifier
        self.name = name
        self.description = description
    def to_json(self):
        """
        creates a JSON dictionary structure form this object.
        Counterpart to parse_program().
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'name' : self.name,
            'description' : self.description,
        }
        return res


def parse_symbol(dictionary):
    """
    creates a Symbol from a JSON dictionary structure
    Counterpart to Symbol.to_json().
    """
    identifier = parse_identifier(dictionary['identifier'])
    name = dictionary['name']
    description = dictionary['description']
    res = Symbol(identifier, name, description)
    return res


class Rule:
    """
    represents a RuleModel on the server.
    """
    def __init__(self, identifier, description, dependencies, threshold, trigger_rule, actions, creator_id=None):
        self.identifier = identifier
        self.description = description
        self.dependencies = dependencies
        self.threshold = threshold
        self.trigger_rule = trigger_rule
        self.actions = actions
        if creator_id is not None:
            self.creator_id = creator_id
    def to_json(self):
        """
        returns a JSON representation of the Rule object.
        This is a counterpart to parse_exec_rule(), but not exactly, because parse_exec_rule() creation will fill in missing default values.
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'creator_id' : self.creator_id,
            'description' : self.description,
            'dependencies' : self.dependencies,
            'threshold' : self.threshold,
            'trigger_rule' : self.trigger_rule,
            'actions' : self.actions,
        }
        return res


def parse_rule(dictionary):
    """
    creates an Rule from a JSON dictionary structure.
    This is a counterpart to Rule.to_json(), but not exactly, because parse_exec_rule() creation will fill in missing default values.
    """
    # the identifier
    identifier = dictionary.get('identifier', None)
    if identifier is not None:
        identifier = parse_identifier(identifier)
        if identifier.type != 'rule':
            raise ValueError("the identifier of the rule is not of type 'rule'.")
    # the description
    description = dictionary.get('description', None)
    if description is not None and not isinstance(description, str):
        raise ValueError("only strings are a valid description")
    # the dependencies
    dependencies = dictionary['dependencies']
    cleaned_dependencies = []
    error_message = "the dependencies must be a list of values that are each either a string identifying a symbol, or a dictionary of 'symbol' and 'weight'."
    if not isinstance(dependencies, list):
        raise ValueError(error_message)
    default_weight = 1.0
    for a in dependencies:
        valid = False
        if isinstance(a, str):
            symbol_name = a
            weight = default_weight
            valid = True
        elif isinstance(a, dict):
            symbol_name = a['symbol']
            weight = a.get('weight', default_weight)
            if isinstance(symbol_name, str) and isinstance(weight, Number):
                valid = True
        if valid:
            clean = {
                'symbol' : symbol_name,
                'weight' : weight,
            }
            cleaned_dependencies.append(clean)
        else:
            raiseValueError(error_message)
    # the threshold
    default_threshold = 1.0
    cleaned_threshold = dictionary.get('threshold', default_threshold)
    if not isinstance(cleaned_threshold, Number):
        raise ValueError("the threshold must be a number")
    # the trigger rule
    cleaned_trigger_rule = {
        'TODO' : 'in basics.py/parse_exec_rule(), clean the trigger rules properly'
    }
    # the actions
    actions = dictionary['actions']
    cleaned_actions = []
    for action in actions:
        action_type = action['type']
        params = action.get('params', None)
        if action_type == 'tag':
            clean = { 'TODO' : 'in basics.py/parse_exec_rule(), clean the actions properly' }
            valid = True
        elif action_type == 'option':
            clean = { 'TODO' : 'in basics.py/parse_exec_rule(), clean the actions properly' }
            valid = True
        elif action_type == 'event':
            clean = { 'TODO' : 'in basics.py/parse_exec_rule(), clean the actions properly' }
            valid = True
        if valid:
            cleaned_actions.append(clean)
        else:
            raise ValueError("'%s' is not a valid type of action" % (action_type,))
    cleaned_actions = [
        {
            'TODO_1' : '1 of 2'
        },
        {
            'TODO_2' : '2 of 2'
        },
    ]
    # return
    res = Rule(identifier, description, cleaned_dependencies, cleaned_threshold, cleaned_trigger_rule, cleaned_actions)
    return res


class FileObject:
    """
    represents a file that was given as an input argument, along with information about it.
    """
    def __init__(self, identifier, file_name, creation_step, creation_index):
        self.identifier = identifier
        self.file_name = file_name
        self.creation_step = creation_step
        self.creation_index = creation_index
    def __str__(self):
        return self.identifier
    def _change_file_name_for_use_as_input(self, index):
        """
        replaces the name of the file with a name that is used for input files.
        This method should be used by the ExecutionEnvironment after copying a file to use it as input for another program execution.
        """
        self.file_name = "in_%d" % index
    def to_json(self):
        """
        gives a JSON dictionary representation of this FileObject that can be parsed as a new FileObject.
        this is a counterpart to parse_file_object().
        """
        res = {}
        res['file'] =  self.file_name
        res['identifier'] = self.identifier.to_json()
        res['creation_step'] = self.creation_step
        res['creation_index'] = self.creation_index
        return res


def parse_file_object(dictionary):
    """
    creates a FileObject from a JSON dictionary structure
    Counterpart to FileObject.to_json()
    """
    identifier = parse_identifier(dictionary['identifier'])
    file_name = dictionary['file']
    creation_step = dictionary['creation_step']
    creation_index = dictionary['creation_index']
    res = FileObject(identifier, file_name, creation_step, creation_index)
    return res


class Message:
    """
    represents a message that is displayed to the user. Can contain interactive features.
    """
    def __init__(self, message_components, add_feedback_buttons):
        self.message_components = message_components
        self.add_feedback_buttons = add_feedback_buttons
    def to_json(self):
        """
        gives a JSON dictionary representation of this Message that can be parsed as a new Message.
        this is a counterpart to parse_message().
        """
        res = {
            'message_components' : self.message_components,
            'add_feedback_buttons' : self.add_feedback_buttons,
        }
        return res


def parse_message(dictionary):
    """
    creates a Message from a JSON dictionary structure
    Counterpart to Message.to_json()
    """
    message_components = dictionary['message_components']
    add_feedback_buttons = dictionary['add_feedback_buttons']
    res = Message(message_components, add_feedback_buttons)
    return res


class Tag:
    """
    represents a TagModel on the server.
    A Tag consists of a Symbol, defined here as a string, and a number of identifiers.
    It also has an identifier of its own.
    Optionally, it may also have a comment and a weight.
    NOTE:
    when defining a Tag, it is ok to specify only the symbol_name. The symbol_identifier will then be set by the server later.
    This does however mean that the created Tag can't be safely converted back from json() until it has been cleaned up by the server.
    """
    def __init__(self, own_identifier, arguments, symbol_name=None, symbol_identifier=None, comment=None, weight=None):
        self.identifier = own_identifier
        self.symbol_name = symbol_name
        self.symbol_identifier = symbol_identifier
        self.argument_identifiers = [a if isinstance(a, Identifier) else a.identifier for a in arguments]
        self.comment = comment
        self.weight = weight
    def __str__(self):
        return "Tag %s: symbol=%s, arguments=(%s)" % (self.identifier, self.symbol_identifier.name, ', '.join(['%s' % a for a in self.argument_identifiers]))
    def to_json(self):
        """
        gives a JSON dictionary representation of this Tag.
        Counterpart to parse_tag().
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'symbol_name' : self.symbol_name,
            'symbol_identifier' : None if self.symbol_identifier is None else self.symbol_identifier.to_json(),
            'argument_identifiers' : [a.to_json() for a in self.argument_identifiers],
            'comment' : self.comment,
            'weight' : self.weight,
        }
        return res


def parse_tag(dictionary):
    """
    creates a Tag from a JSON dictionary structure
    Counterpart to Tag.to_json().
    """
    identifier = parse_identifier(dictionary['identifier'])
    symbol_name = dictionary['symbol_name']
    symbol_identifier = parse_identifier(dictionary['symbol_identifier'])
    argument_identifiers = [parse_identifier(a) for a in dictionary['argument_identifiers']]
    comment = dictionary['comment']
    weight = dictionary['weight']
    return Tag(identifier, argument_identifiers, symbol_name=symbol_name, symbol_identifier=symbol_identifier, comment=comment, weight=weight)


def parse_object_according_to_type(type, dictionary):
    """
    helper function.
    Calls one of the other parse_x() functions, depending on the provided type.
    """
    if type == 'program':
        return parse_program(dictionary)
    elif type == 'symbol':
        return parse_symbol(dictionary)
    elif type == 'rule':
        return parse_rule(dictionary)
    elif type == 'file':
        return parse_file_object(dictionary)
    elif type == 'message':
        return parse_message(dictionary)
    elif type == 'tag':
        return parse_tag(dictionary)
    raise ValueException("can't parse unknown type: %s" % type)


class ObjectManager:
    """
    a manager to keep track of all of the following objects in use in an ExecutionEnvironment, as well as the relations between them:
    Program, Symbol, Rule, FileObject, Tag, Identifier.
    This acts as a single source-of-truth for all objects in use by an active ExecEnv/ExecutionEnvironment.
    It is also used to make communicating and synchronizing knowledge between server and local executions easier because this object is JSONable.
    """
    def __init__(self):
        self.identifiers_in_order = []
        self.identifier_to_object_dict = {}
        self.identifier_to_identifier_model_id = {}
        self.tag_argument_backreferences = {}
        self.preliminary_identifier_mapping = {}
    def add_object(self, obj, identifier_model_id):
        """
        adds an object to this manager.
        """
        # add the mapping identifier->object
        identifier = self.get_identifier_for_object(obj)
        if identifier in self.identifier_to_object_dict:
            raise ValueError("an object with this Identifier has already been added!")
        if identifier.preliminary:
            raise ValueError("the object to be added must already have a non-preliminary Identifier!")
        self.identifier_to_object_dict[identifier] = obj
        # remember the ID of the database model corresponding to this Identifier
        self.identifier_to_identifier_model_id[identifier] = identifier_model_id
        # add the identifier in the right order
        self.identifiers_in_order.append(identifier)
        # if it's a Tag, add the argument backreferences
        if isinstance(obj, Tag):
            for arg_ident in obj.argument_identifiers:
                # add a backreference from the identifier of the Tag's argument to the identifier of the Tag
                if arg_ident not in self.tag_argument_backreferences:
                    self.tag_argument_backreferences[arg_ident] = []
                self.tag_argument_backreferences[arg_ident].append(identifier)
    def reset_preliminary_identifier_mapping(self):
        """
        resets the mapping for preliminary identifiers to real identifiers.
        """
        self.preliminary_identifier_mapping = {}
    def register_mapping_for_preliminary_identifier_to_real_identifier(self, preliminary, real):
        """
        takes a preliminary identifier and a real one and remembers that the one maps to the other.
        """
        if not preliminary.preliminary or real.preliminary or preliminary.type != real.type:
            raise ValueError('the first Identifier must be preliminary, the second not, and they must both refer to the same type:\n%s\n%s' % (preliminary.to_json(), real.to_json()))
        if preliminary in self.preliminary_identifier_mapping:
            raise ValueError("this preliminary identifier is already registered.")
        self.preliminary_identifier_mapping[preliminary] = real
    def get_real_identifier(self, identifier):
        """
        returns the real Identifier corresponding to a previously registered preliminary one.
        If the given Identifier is already a real one, and is registered, returns it instead.
        """
        if identifier in self.identifier_to_object_dict:
            return identifier
        return self.preliminary_identifier_mapping[identifier]
    def identifier_exists(self, identifier):
        """
        returns whether or not a given Identifier is already registered.
        """
        return identifier in self.identifier_to_object_dict
    def get_object_for_identifier(self, identifier):
        """
        returns the object corresponding to an Identifier, if it has been registered.
        If the identifier is a preliminary one, uses the corresponding real one instead instead.
        """
        if identifier.preliminary:
            identifier = self.preliminary_identifier_mapping[identifier]
        return self.identifier_to_object_dict[identifier]
    def get_identifier_model_id_for_identifier(self, identifier):
        """
        returns the ID of the IdentifierModel corresponding to an Identifier, if it has been registered.
        If the identifier is a preliminary one, uses the corresponding real one instead instead.
        """
        if identifier.preliminary:
            identifier = self.preliminary_identifier_mapping[identifier]
        return self.identifier_to_identifier_model_id[identifier]
    def get_identifier_for_object(self, obj):
        """
        returns the Identifier of an object.
        This uses the object's own identifier field, so it works even if the object is just a copy of the one that was originally added to this manager.
        """
        valid_types = [Program, Symbol, Rule, FileObject, Tag]
        for t in valid_types:
            if isinstance(obj, t):
                return obj.identifier
        raise ValueError("Invalid object type. Does not have identifier: %s" % (type(obj),))
    def get_tag_arguments(self, tag_identifier):
        """
        returns a list of the Identifiers of arguments of a given Tag's Identifier.
        """
        tag = self.get_object_for_identifier(tag_identifier)
        res = [self.get_object_for_identifier(a) for a in tag.argument_identifiers]
        return res
    def get_tag_backreferences(self, object_identifier):
        tags = [self.get_object_for_identifier(a) for a in self.tag_argument_backreferences[object_identifier]]
        for t in tags:
            if not isinstance(t, Tag):
                raise ValueError("Programming error: it should not be possible for a backreference to return something other than a list of Tags")
        return tags
    def get_all_objects(self, object_type):
        """
        return a list of the Tags stored in this ObjectManager.
        """
        res = []
        for identifier in self.identifiers_in_order:
            if identifier.type == object_type:
                obj = self.get_object_for_identifier(identifier)
                res.append(obj)
        return res
    def to_json(self):
        """
        gives a JSON dictionary representation of this ObjectManager that can be parsed as a new ObjectManager.
        this is a counterpart to parse_object_manager().
        """
        res = {
            'identifiers_in_order' : [a.to_json() for a in self.identifiers_in_order],
            'identifier_to_object_dict' : [ [k.to_json(), v.to_json()] for k,v in self.identifier_to_object_dict.items() ],
            'identifier_to_identifier_model_id' : [ [k.to_json(), v] for k,v in self.identifier_to_identifier_model_id.items() ],
            'tag_argument_backreferences' : [ [k.to_json(), [a.to_json() for a in v]] for k,v in self.tag_argument_backreferences.items() ],
            'preliminary_identifier_mapping' : [ [k.to_json(), v.to_json()] for k,v in self.preliminary_identifier_mapping.items() ],
        }
        return res


def parse_object_manager(dictionary):
    """
    creates an ObjectManager from a JSON dictionary structure
    Counterpart to ObjectManager.to_json().
    """
    res = ObjectManager()
    res.identifiers_in_order = [parse_identifier(a) for a in dictionary['identifiers_in_order']]
    res.identifier_to_object_dict = { parse_identifier(kv[0]) : parse_object_according_to_type(kv[0]['type'], kv[1]) for kv in dictionary['identifier_to_object_dict'] }
    res.identifier_to_identifier_model_id = { parse_identifier(kv[0]) : kv[1] for kv in dictionary['identifier_to_identifier_model_id'] }
    res.tag_argument_backreferences = { parse_identifier(kv[0]) : [parse_identifier(a) for a in kv[1]] for kv in dictionary['tag_argument_backreferences'] }
    res.preliminary_identifier_mapping = { parse_identifier(kv[0]) : parse_identifier(kv[1]) for kv in dictionary['preliminary_identifier_mapping'] }
    return res


class EventRequest:
    """
    represents a request of a running program to the Execution Environment.
    """
    def __init__(self, event_type, args=None):
        self.event_type = event_type
        self.args = args
    def to_json(self):
        """
        gives a JSON dictionary representation of this EventRequest.
        this is a counterpart to parse_event_request().
        """
        res = {
            'event_type' : self.event_type,
            'args' : self._args_to_json() if self.args is None else self.args,
        }
        return res


def parse_event_request(dictionary):
    """
    creates an EventRequest from a JSON dictionary structure
    Counterpart to EventRequest.to_json().
    """
    event_type = dictionary['event_type']
    args = dictionary['args']
    res = EventRequest(event_type, args)
    return res


class ProgramExecutionRequest(EventRequest):
    """
    a class that uses method-chaining to create a request to execute a Program.
    """
    def __init__(self):
        super().__init__('execute_program')
        self.program_identifier = None
        self.argument_identifiers = []
    def program(self, program_identifier):
        if not isinstance(program_identifier, str) and not isinstance(program_identifier, int):
            error_message = """The program may be identified as a String displaying the name of the program (in which case the latest version is picked),
                as a String of <name>#<version> (which identifies the version directly),
                or as an integer that is the program's ID (which is unambiguous and includes the version)"""
            raise ValueError(error_message)
        self.program_identifier = program_identifier
        return self
    def arguments(self, argument_identifiers):
        for arg in argument_identifiers:
            if not isinstance(arg, str) and not isinstance(arg, Identifier):
                raise ValueError("each argument of a program execution request must be a string or an Identifier")
        self.argument_identifiers = argument_identifiers
        return self
    def _args_to_json(self):
        res = {
            'program_identifier' : self.program_identifier,
            'argument_identifiers' : [a.to_json() for a in self.argument_identifiers],
        }
        return res


class DisplayMessageRequest(EventRequest):
    """
    a class that uses method-chaining to create a request to display a message to the user in an interactive website.
    The message generated here will be put in a HTML form and displayed.
    """
    def __init__(self):
        super().__init__('display_message')
        self.message_components = []
        self.add_feedback_buttons = False
    def add_text(self, message_text):
        if not isinstance(message_text, str):
            raise ValueError("The message to display must be a string")
        component = {
            'type' : 'unformatted_text',
            'content' : message_text,
        }
        self.message_components.append(component)
        return self
    def set_feedback_buttons(self, add=True):
        self.add_feedback_buttons = add
        return self
    def _args_to_json(self):
        res = {
            'message_object_dicts' : [Message(self.message_components, self.add_feedback_buttons).to_json()],
        }
        return res


