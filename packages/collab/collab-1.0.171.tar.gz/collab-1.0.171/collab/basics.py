import collections
import numbers
import threading
import os



##############################################################################################################
#
# NOTE !!!
#
# THIS FILE MAY BE AUTOGENERATED.
# ONLY MODIFY THE ORIGINAL FILE IN THE /sharedData/ FOLDER!
# OTHER INSTANCES OF THIS FILE ARE COPIES!
#
# NOTE !
#
##############################################################################################################


class Identifier:
    """
    a token by which objects of different types can be compared.
    This has a serverside SQL counterpart called IdentifierModel.
    All objects that are read from the input have an identifier.
    All objects generated during the output have a preliminary identifier, because the output will be interpreted by the Execution Environment.
    (preliminary identifiers can be used like any other).
    An identifier may optionally also have a name.
    Identifiers provided by the server will have this field set if the Identifier refers to an object with a name.
    If both an ID and a name are given, the ID takes precedence.
    """
    def __init__(self, model_id, type, preliminary=False, name=None):
        self.id = model_id
        self.type = type
        self.preliminary = preliminary
        self.name = name
    def __str__(self):
        return "%s Identifier %s%s" % (self.type, self.id, " (preliminary)" if self.preliminry else "")
    def __hash__(self):
        """
        override the default hashing, to make equality comparisons possible
        """
        res = hash(self.type)
        res *= 17
        res += hash(self.id)
        res *= 17
        res += hash(self.preliminary)
        return res
    def __eq__(self, other):
        """
        Override the default Equals behavior
        """
        return (self.type == other.type) and (self.id == other.id) and (self.preliminary == other.preliminary)
    def __ne__(self, other):
        """
        Define a non-equality test
        """
        return not self.__eq__(other)
    def to_json(self):
        """
        gives a JSON dictionary representation of this identifier.
        Counterpart to parse_identifier().
        """
        res = {
            'type' : self.type,
            'id' : self.id,
        }
        if self.preliminary:
            res['preliminary'] = True
        if self.name:
            res['name'] = self.name
        return res
    def get_program_name_and_version_separately(self):
        """
        if this Identifier refers to a program and has a name, splits the name into the base name and the version and returns a tuple of both.
        """
        if self.type != 'program':
            raise ValueError("this Identifier does not refer to a program.")
        if self.name is None:
            raise ValueError("this program Identifier does not have its name set.")
        if '#' not in self.name:
            raise ValueError("no version is given for this Identifier. This should not be possible.")
        l = self.name.split('#')
        name = l[0]
        version = int(l[1])
        return name, version


def parse_identifier(dictionary):
        """
        creates an Identifier from a JSON dictionary structure
        Counterpart to Identifier.to_json().
        """
        id = dictionary['id']
        type = dictionary['type']
        preliminary = dictionary.get('preliminary', False)
        name = dictionary.get('name', None)
        return Identifier(id, type, preliminary=preliminary, name=name)


_preliminary_identifier_counter_lock = threading.RLock()
_preliminary_identifier_counter = 0
def create_preliminary_identifier(type, name=None):
    """
    creates a preliminary Identifier, for use by output objects.
    """
    with _preliminary_identifier_counter_lock:
        global _preliminary_identifier_counter
        c = _preliminary_identifier_counter
        _preliminary_identifier_counter += 1
    res = Identifier(c, type, preliminary=True, name=name)
    return res


class Program:
    """
    represents a Program on the server.
    This object is only created from the corresponding serverside object, which is why no type checking or parameter verification is done here.
    """
    def __init__(self, identifier, name, version, description):
        self.identifier = identifier
        self.name = name
        self.version = version
        self.description = description
    def to_json(self):
        """
        creates a JSON dictionary structure form this object.
        Counterpart to parse_program().
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'name' : self.name,
            'version' : self.version,
            'description' : self.description,
        }
        return res


def parse_program(dictionary):
    """
    creates an Program from a JSON dictionary structure
    Counterpart to Program.to_json().
    """
    identifier = parse_identifier(dictionary['identifier'])
    name = dictionary['name']
    version = dictionary['version']
    description = dictionary['description']
    res = Program(identifier, name, version, description)
    return res


class Symbol:
    """
    represents a SymbolModel on the server.
    Symbols have a name and a description, and exist for communication purposes.
    """
    def __init__(self, identifier, name, description):
        self.identifier = identifier
        self.name = name
        self.description = description
    def to_json(self):
        """
        creates a JSON dictionary structure form this object.
        Counterpart to parse_program().
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'name' : self.name,
            'description' : self.description,
        }
        return res


def parse_symbol(dictionary):
    """
    creates a Symbol from a JSON dictionary structure
    Counterpart to Symbol.to_json().
    """
    identifier = parse_identifier(dictionary['identifier'])
    name = dictionary['name']
    description = dictionary['description']
    res = Symbol(identifier, name, description)
    return res


class Rule:
    """
    represents a RuleModel on the server.
    """
    def __init__(self, identifier, creator_id, description, dependencies, threshold, trigger_rule, actions):
        self.identifier = identifier
        self.creator_id = creator_id
        self.description = description
        self.dependencies = dependencies
        self.threshold = threshold
        self.trigger_rule = trigger_rule
        self.actions = actions
    def to_json(self):
        """
        returns a JSON representation of the Rule object.
        This is a counterpart to parse_exec_rule(), but not exactly, because parse_exec_rule() creation will fill in missing default values.
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'creator_id' : self.creator_id,
            'description' : self.description,
            'dependencies' : self.dependencies,
            'threshold' : self.threshold,
            'trigger_rule' : self.trigger_rule,
            'actions' : self.actions,
        }
        return res


def parse_rule(dictionary):
    """
    creates an Rule from a JSON dictionary structure.
    Counterpart to Rule.to_json().
    """
    # the identifier
    identifier = parse_identifier(dictionary['identifier'])
    creator_id = dictionary['creator_id']
    description = dictionary['description']
    dependencies = dictionary['dependencies']
    threshold = dictionary['threshold']
    trigger_rule = dictionary['trigger_rule']
    actions = dictionary['actions']
    res = Rule(identifier, creator_id, description, dependencies, threshold, trigger_rule, actions)
    return res


class FileObject:
    """
    represents a file that was given as an input argument, along with information about it.
    """
    def __init__(self, identifier, file_name, creation_step, creation_index):
        self.identifier = identifier
        self.file_name = file_name
        self.creation_step = creation_step # set by the server; values provided by the user are ignored
        self.creation_index = creation_index # set by the server; values provided by the user are ignored
    def __str__(self):
        return self.identifier
    def _change_file_name_for_use_as_input(self, index):
        """
        replaces the name of the file with a name that is used for input files.
        This method should be used by the ExecutionEnvironment after copying a file to use it as input for another program execution.
        """
        self.file_name = "in_%d" % index
    def to_json(self):
        """
        gives a JSON dictionary representation of this FileObject that can be parsed as a new FileObject.
        this is a counterpart to parse_file_object().
        """
        res = {}
        res['file'] =  self.file_name
        res['identifier'] = self.identifier.to_json()
        res['creation_step'] = self.creation_step
        res['creation_index'] = self.creation_index
        return res


def parse_file_object(dictionary):
    """
    creates a FileObject from a JSON dictionary structure
    Counterpart to FileObject.to_json()
    """
    identifier = parse_identifier(dictionary['identifier'])
    file_name = dictionary['file']
    creation_step = dictionary['creation_step']
    creation_index = dictionary['creation_index']
    res = FileObject(identifier, file_name, creation_step, creation_index)
    return res


class Message:
    """
    represents a message that is displayed to the user. Can contain interactive features.
    """
    def __init__(self, identifier, message_components, add_feedback_buttons):
        self.identifier = identifier
        self.message_components = message_components
        self.add_feedback_buttons = add_feedback_buttons
    def to_json(self):
        """
        gives a JSON dictionary representation of this Message that can be parsed as a new Message.
        this is a counterpart to parse_message().
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'message_components' : self.message_components,
            'add_feedback_buttons' : self.add_feedback_buttons,
        }
        return res


def parse_message(dictionary):
    """
    creates a Message from a JSON dictionary structure
    Counterpart to Message.to_json()
    """
    identifier = parse_identifier(dictionary['identifier'])
    message_components = dictionary['message_components']
    add_feedback_buttons = dictionary['add_feedback_buttons']
    res = Message(identifier, message_components, add_feedback_buttons)
    return res


class DisplayMessageRequest(Message):
    """
    a class that uses method-chaining to create a message to the user in an interactive website.
    The message generated here will be put in a HTML form and displayed.
    """
    def __init__(self, identifier=None):
        super().__init__(create_preliminary_identifier('message') if identifier is None else identifier, [], False)
    def add_text(self, message_text):
        if not isinstance(message_text, str):
            raise ValueError("The message to display must be a string")
        component = {
            'type' : 'unformatted_text',
            'text' : message_text,
        }
        self.message_components.append(component)
        return self
    def add_plot(self, data, options=None):
        component = {
            'type' : 'plot',
            'data' : data,
            'options' : {} if options is None else options,
        }
        self.message_components.append(component)
        return self
    def set_feedback_buttons(self, add=True):
        self.add_feedback_buttons = add
        return self


class Tag:
    """
    represents a TagModel on the server.
    A Tag consists of a Symbol, defined here as a string, and a number of identifiers.
    It also has an identifier of its own.
    Optionally, it may also have a comment and a weight.
    NOTE:
    when defining a Tag, it is ok to specify only the symbol_name. The symbol_identifier will then be set by the server later.
    This does however mean that the created Tag can't be safely converted back from json() until it has been cleaned up by the server.
    """
    def __init__(self, own_identifier, arguments, symbol_name=None, symbol_identifier=None, comment=None, weight=None):
        self.identifier = own_identifier
        self.symbol_name = symbol_name
        self.symbol_identifier = symbol_identifier
        self.argument_identifiers = [a if isinstance(a, Identifier) else a.identifier for a in arguments]
        self.comment_field = comment
        self.weight_field = weight
    def __str__(self):
        return "Tag %s: symbol=%s, arguments=(%s)" % (self.identifier, self.symbol_identifier.name, ', '.join(['%s' % a for a in self.argument_identifiers]))
    def to_json(self):
        """
        gives a JSON dictionary representation of this Tag.
        Counterpart to parse_tag().
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'symbol_name' : self.symbol_name,
            'symbol_identifier' : None if self.symbol_identifier is None else self.symbol_identifier.to_json(),
            'argument_identifiers' : [a.to_json() for a in self.argument_identifiers],
            'comment' : self.comment_field,
            'weight' : self.weight_field,
        }
        return res


def parse_tag(dictionary):
    """
    creates a Tag from a JSON dictionary structure
    Counterpart to Tag.to_json().
    """
    identifier = parse_identifier(dictionary['identifier'])
    symbol_name = dictionary['symbol_name']
    symbol_identifier = parse_identifier(dictionary['symbol_identifier'])
    argument_identifiers = [parse_identifier(a) for a in dictionary['argument_identifiers']]
    comment = dictionary['comment']
    weight = dictionary['weight']
    return Tag(identifier, argument_identifiers, symbol_name=symbol_name, symbol_identifier=symbol_identifier, comment=comment, weight=weight)


class TagRequest(Tag):
    """
    a class that uses method-chaining to create a Tag.
    """
    def __init__(self):
        super().__init__(create_preliminary_identifier('tag'), [])
    def symbol(self, name_or_identifier):
        """
        the symbol can be specified either as a string, a Symbol object or an Identifier.
        """
        if isinstance(name_or_identifier, str):
            self.symbol_name = name_or_identifier
        elif isinstance(name_or_identifier, Symbol):
            self.symbol_name = name_or_identifier.name
        elif isinstance(name_or_identifier, Identifier) and name_or_identifier.type == 'symbol':
            self.symbol_name = name_or_identifier.name
        else:
            raise ValueError("the Symbol of the Tag must be specified either through a string, a Symbol object or an Identifier")
        return self
    def arguments(self, arguments):
        """
        the arguments of a Tag must be specified either as Identifiers or as objects with an Identifier as a field.
        """
        argument_identifiers = []
        for arg in arguments:
            if isinstance(arg, Identifier):
                argument_identifiers.append(arg)
            else:
                argument_identifiers.append(arg.identifier)
        self.argument_identifiers = argument_identifiers
        return self
    def comment(self, comment):
        if comment is not None and not isinstance(comment, str):
            raise ValueError("the comment must be either None or a String")
        self.comment_field = comment
        return self
    def weight(self, weight):
        if weight is not None and not isinstance(weight, numbers.Number):
            raise ValueError("the weight must be either None or a number")
        self.weight_field = weight
        return self


class Event:
    """
    represents an event in the Execution Environment.
    """
    def __init__(self, identifier, event_type, args, priority=False, triggering_step=None, trigger=None):
        self.identifier = identifier
        self.event_type = event_type
        self.args = args
        self.priority = priority
        self.triggering_step = triggering_step # set by the server; values provided by the user are ignored when this gets parsed by the server
        self.trigger = trigger # set by the server; values provided by the user are ignored when this gets parsed by the server
    def set_priority(self, priority=True):
        """
        mark the event as a priority.
        Priority events are executed before any of the other ones.
        """
        self.priority = priority
        return self
    def to_json(self):
        """
        gives a JSON dictionary representation of this Event.
        this is a counterpart to parse_event_request().
        """
        res = {
            'identifier' : self.identifier.to_json(),
            'event_type' : self.event_type,
            'priority' : self.priority,
            'args' : self.args,
            'triggering_step' : self.triggering_step,
            'trigger' : self.trigger,
        }
        return res


def parse_event(dictionary):
    """
    creates an Event from a JSON dictionary structure
    Counterpart to Event.to_json().
    """
    identifier = parse_identifier(dictionary['identifier'])
    event_type = dictionary['event_type']
    priority = dictionary['priority']
    args = dictionary['args']
    triggering_step = dictionary['triggering_step']
    trigger = dictionary['trigger']
    res = Event(identifier, event_type, args, priority=priority, triggering_step=triggering_step, trigger=trigger)
    return res


class ProgramExecutionRequest(Event):
    """
    a class that uses method-chaining to create a request to execute a Program.
    """
    def __init__(self):
        super().__init__(create_preliminary_identifier('event'), 'execute_program', {})
    def program(self, program_identifier):
        error_message = """The program may be identified as an Identifier,
            as a String displaying the name of the program (in which case the latest version is picked),
            as a String of <name>#<version> (which identifies the version directly),
            or as an integer that is the program's ID (which is unambiguous and includes the version)"""
        if isinstance(program_identifier, Identifier):
            self.args['program_identifier'] = program_identifier
        elif isinstance(program_identifier, int):
            self.args['program_identifier'] = Identifier(program_identifier, 'program', preliminary=False, name=None)
        elif isinstance(program_identifier, str):
            self.args['program_identifier'] = Identifier(None, 'program', preliminary=False, name=program_identifier)
        else:
            raise ValueError(error_message)
        self.args['program_identifier'] = self.args['program_identifier'].to_json()
        return self
    def arguments(self, argument_identifiers):
        cleaned_argument_identifiers = []
        for arg in argument_identifiers:
            if isinstance(arg, FileObject):
                cleaned_argument_identifiers.append(arg.identifier)
            elif isinstance(arg, Identifier) and arg.type == 'file':
                cleaned_argument_identifiers.append(arg)
            else:
                raise ValueError("each argument of a program execution request must be a FileObject or an Identifier of a FileObject")
        self.args['argument_identifiers'] = [a.to_json() for a in cleaned_argument_identifiers]
        return self


def parse_object_according_to_type(type, dictionary):
    """
    helper function.
    Calls one of the other parse_x() functions, depending on the provided type.
    """
    if type == 'program':
        return parse_program(dictionary)
    elif type == 'symbol':
        return parse_symbol(dictionary)
    elif type == 'rule':
        return parse_rule(dictionary)
    elif type == 'file':
        return parse_file_object(dictionary)
    elif type == 'message':
        return parse_message(dictionary)
    elif type == 'tag':
        return parse_tag(dictionary)
    elif type == 'event':
        return parse_event(dictionary)
    raise ValueException("can't parse unknown type: %s" % type)


class ObjectManager:
    """
    a manager to keep track of all of the following objects in use in an ExecutionEnvironment, as well as the relations between them:
    Program, Symbol, Rule, FileObject, Tag, Identifier.
    This acts as a single source-of-truth for all objects in use by an active ExecEnv/ExecutionEnvironment.
    It is also used to make communicating and synchronizing knowledge between server and local executions easier because this object is JSONable.
    """
    def __init__(self):
        self.current_step = None
        self.identifiers = []
        self.identifier_to_object_dict = {}
        self.identifier_to_step_number = {}
        self.identifier_to_identifier_model_id = {}
        self.tag_argument_backreferences = {}
        self.ordered_list_of_event_identifiers = []
        # this mapping exists so that Tags created by a Program or a Rule can refer to objects that were created by that same Program or Rule,
        # since these objects have preliminary identifiers.
        # These get turned into proper Identifiers by the server, so this is only a temporary mapping that gets reset all the time.
        self.preliminary_identifier_mapping = {}
    def add_object(self, obj, identifier_model_id):
        """
        adds an object to this manager.
        """
        # add the mapping identifier->object
        identifier = self.get_identifier_for_object(obj)
        if identifier in self.identifier_to_object_dict:
            raise ValueError("an object with this Identifier has already been added!")
        if identifier.preliminary:
            raise ValueError("the object to be added must already have a non-preliminary Identifier!")
        self.identifier_to_object_dict[identifier] = obj
        # remember the step number at which the object was added
        self.identifier_to_step_number[identifier] = self.current_step
        # remember the ID of the database model corresponding to this Identifier
        self.identifier_to_identifier_model_id[identifier] = identifier_model_id
        # add the identifier in the right order
        self.identifiers.append(identifier)
        # if it's a Tag, add the argument backreferences
        if isinstance(obj, Tag):
            for arg_ident in obj.argument_identifiers:
                # add a backreference from the identifier of the Tag's argument to the identifier of the Tag
                if arg_ident not in self.tag_argument_backreferences:
                    self.tag_argument_backreferences[arg_ident] = []
                self.tag_argument_backreferences[arg_ident].append(identifier)
        # if it's an Event, add it to the ordered list of events
        # the position of this event in the list depends on its priority
        if isinstance(obj, Event):
            if obj.priority:
                # look down the list of events until you find the first non-priority one, then add this event before that one
                i = self.current_step
                while(True):
                    if i > len(self.ordered_list_of_event_identifiers):
                        raise ValueError("there are too few events in the ordered list for the current_step to make sense.")
                    if i == len(self.ordered_list_of_event_identifiers):
                        self.ordered_list_of_event_identifiers.append(identifier)
                        break
                    existing_event_identifier = self.ordered_list_of_event_identifiers[i]
                    existing_event = self.get_object_for_identifier(existing_event_identifier)
                    if not existing_event.priority:
                        self.ordered_list_of_event_identifiers.insert(i, identifier)
                    i += 1
            else:
                self.ordered_list_of_event_identifiers.append(identifier)
    def reset_preliminary_identifier_mapping(self):
        """
        resets the mapping for preliminary identifiers to real identifiers.
        """
        self.preliminary_identifier_mapping = {}
    def register_mapping_for_preliminary_identifier_to_real_identifier(self, preliminary, real):
        """
        takes a preliminary identifier and a real one and remembers that the one maps to the other.
        """
        if not preliminary.preliminary or real.preliminary or preliminary.type != real.type:
            raise ValueError('the first Identifier must be preliminary, the second not, and they must both refer to the same type:\n%s\n%s' % (preliminary.to_json(), real.to_json()))
        if preliminary in self.preliminary_identifier_mapping:
            raise ValueError("this preliminary identifier is already registered.")
        self.preliminary_identifier_mapping[preliminary] = real
    def get_real_identifier(self, identifier):
        """
        returns the real Identifier corresponding to a previously registered preliminary one.
        If the given Identifier is already a real one, and is registered, returns it instead.
        """
        if identifier in self.identifier_to_object_dict:
            return identifier
        return self.preliminary_identifier_mapping[identifier]
    def identifier_exists(self, identifier):
        """
        returns whether or not a given Identifier is already registered.
        """
        return (identifier in self.identifier_to_object_dict) or (identifier in self.preliminary_identifier_mapping)
    def get_object_for_identifier(self, identifier):
        """
        returns the object corresponding to an Identifier, if it has been registered.
        If the identifier is a preliminary one, uses the corresponding real one instead instead.
        """
        if identifier.preliminary:
            identifier = self.preliminary_identifier_mapping[identifier]
        return self.identifier_to_object_dict[identifier]
    def get_step_number_of_addition_for_identifier(self, identifier):
        """
        returns the number of the step at which an Identifier has first been registered.
        If the identifier is a preliminary one, uses the corresponding real one instead instead.
        """
        if identifier.preliminary:
            identifier = self.preliminary_identifier_mapping[identifier]
        return self.identifier_to_step_number[identifier]
    def get_identifier_model_id_for_identifier(self, identifier):
        """
        returns the ID of the IdentifierModel corresponding to an Identifier, if it has been registered.
        If the identifier is a preliminary one, uses the corresponding real one instead instead.
        """
        if identifier.preliminary:
            identifier = self.preliminary_identifier_mapping[identifier]
        return self.identifier_to_identifier_model_id[identifier]
    def get_identifier_for_object(self, obj):
        """
        returns the Identifier of an object.
        This uses the object's own identifier field, so it works even if the object is just a copy of the one that was originally added to this manager.
        """
        return obj.identifier
    def get_tag_arguments(self, tag_identifier):
        """
        returns a list of the Identifiers of arguments of a given Tag's Identifier.
        """
        tag = self.get_object_for_identifier(tag_identifier)
        res = [self.get_object_for_identifier(a) for a in tag.argument_identifiers]
        return res
    def get_tag_backreferences(self, object_identifier):
        tags = [self.get_object_for_identifier(a) for a in self.tag_argument_backreferences[object_identifier]]
        for t in tags:
            if not isinstance(t, Tag):
                raise ValueError("Programming error: it should not be possible for a backreference to return something other than a list of Tags")
        return tags
    def get_all_objects(self, object_type=None, step_of_creation=None):
        """
        return a list of Objects stored in this ObjectManager.
        """
        res = []
        for identifier in self.identifiers:
            object_passes = (object_type is None or identifier.type == object_type)
            object_passes = object_passes and (step_of_creation is None or self.get_step_number_of_addition_for_identifier(identifier) == step_of_creation)
            if object_passes:
                obj = self.get_object_for_identifier(identifier)
                res.append(obj)
        return res
    def get_current_event(self):
        """
        based on the current_step and the ordered_list_of_event_identifiers, return the Event that should be executed next.
        If the queue has been exceeded, returns None.
        """
        if self.current_step == len(self.ordered_list_of_event_identifiers):
            return None
        identifier = self.ordered_list_of_event_identifiers[self.current_step]
        event = self.get_object_for_identifier(identifier)
        return event
    def to_json(self):
        """
        gives a JSON dictionary representation of this ObjectManager that can be parsed as a new ObjectManager.
        this is a counterpart to parse_object_manager().
        """
        if len(self.preliminary_identifier_mapping.items()) != 0:
            raise ValueError("The preliminary_identifier_mapping should be reset before serializing an ObjectManager. It is only a temporary variable that shouldn't persist.")
        res = {
            'current_step' : self.current_step,
            'identifiers' : [a.to_json() for a in self.identifiers],
            'identifier_to_object_dict' : [ [k.to_json(), v.to_json()] for k,v in self.identifier_to_object_dict.items() ],
            'identifier_to_step_number' : [ [k.to_json(), v] for k,v in self.identifier_to_step_number.items()],
            'identifier_to_identifier_model_id' : [ [k.to_json(), v] for k,v in self.identifier_to_identifier_model_id.items() ],
            'tag_argument_backreferences' : [ [k.to_json(), [a.to_json() for a in v]] for k,v in self.tag_argument_backreferences.items() ],
            'ordered_list_of_event_identifiers' : [a.to_json() for a in self.ordered_list_of_event_identifiers],
        }
        return res


def parse_object_manager(dictionary):
    """
    creates an ObjectManager from a JSON dictionary structure
    Counterpart to ObjectManager.to_json().
    """
    res = ObjectManager()
    res.current_step = dictionary['current_step']
    res.identifiers = [parse_identifier(a) for a in dictionary['identifiers']]
    res.identifier_to_object_dict = { parse_identifier(kv[0]) : parse_object_according_to_type(kv[0]['type'], kv[1]) for kv in dictionary['identifier_to_object_dict'] }
    res.identifier_to_step_number = { parse_identifier(kv[0]) : kv[1] for kv in dictionary['identifier_to_step_number'] }
    res.identifier_to_identifier_model_id = { parse_identifier(kv[0]) : kv[1] for kv in dictionary['identifier_to_identifier_model_id'] }
    res.tag_argument_backreferences = { parse_identifier(kv[0]) : [parse_identifier(a) for a in kv[1]] for kv in dictionary['tag_argument_backreferences'] }
    res.ordered_list_of_event_identifiers = [parse_identifier(a) for a in dictionary['ordered_list_of_event_identifiers']]
    return res


