import operator
import asyncio
import re
import logging
from enum import IntEnum

from aioethereum import create_ethereum_client
from aioethereum.errors import BadResponseError

from .utils import hex_to_dec, wei_to_ether, ether_to_gwei, ether_to_wei


GAS_AMOUNT = 21000
GAS_PRICE = 20  # Gwei
DEFAUT_FEE = wei_to_ether(ether_to_gwei(GAS_PRICE) * GAS_AMOUNT)


class Category(IntEnum):
    Blockchain = 0
    Control = 1
    Generating = 2
    Mining = 3
    Network = 4
    Rawtransactions = 5
    Util = 6
    Wallet = 7


class Method:
    _r = {}

    @classmethod
    def registry(cls, category):
        def decorator(fn):
            cls._r.setdefault('category_%s' % int(category), []) \
                .append(fn.__name__)
            return fn
        return decorator

    @classmethod
    def get_categories(cls):
        for key, funcs in cls._r.items():
            if 'category_' in key:
                yield (Category(int(key.replace('category_', ''))).name, funcs)


class EthereumProxy:

    def __init__(self, rpc):
        self._rpc = rpc
        self._log = logging.getLogger('ethereum-proxy')

    async def help(self, command=None):
        """"help ( "command" )

List all commands, or get help for a specified command.

Arguments:
1. "command"     (string, optional) The command to get help on

Result:
"text"     (string) The help text
        """
        if command:
            func = getattr(EthereumProxy, command, None)
            if func:
                return func.__doc__
            return 'help: unknown command: %s' % command

        result = ""
        for category, funcs in Method.get_categories():
            result += "== %s ==\n" % category
            for func in funcs:
                doc = getattr(EthereumProxy, func).__doc__
                if not doc:
                    result += func + '\n'
                else:
                    result += doc.split('\n')[0] + '\n'
            result += "\n"
        result = result.rstrip('\n')
        return result

    @Method.registry(Category.Util)
    async def validateaddress(self, address):
        """validateaddress "address"

Return information about the given ethereum address.

Arguments:
1. "address"     (string, required) The ethereum address to validate

Result:
{
  "isvalid" : true|false,       (boolean) If the address is valid or not. If not, this is the only property returned.
  "address" : "address", (string) The ethereum address validated
  "scriptPubKey" : "hex",       (string) The hex encoded scriptPubKey generated by the address
  "ismine" : true|false,        (boolean) If the address is yours or not
  "iswatchonly" : true|false,   (boolean) If the address is watchonly
  "isscript" : true|false,      (boolean) If the key is a script
  "pubkey" : "publickeyhex",    (string) The hex value of the raw public key
  "iscompressed" : true|false,  (boolean) If the address is compressed
  "timestamp" : timestamp,        (number, optional) The creation time of the key if available in seconds since epoch (Jan 1 1970 GMT)
}

Examples:
> ethereum-cli validateaddress "0x6cace0528324a8afc2b157ceba3cdd2a27c4e21f"
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "validateaddress", "params": ["0x6cace0528324a8afc2b157ceba3cdd2a27c4e21f"] }'  http://127.0.0.01:9500/
        """
        if not isinstance(address, (bytes, str, bytearray)):
            return {
                'isvalid': False
            }

        address = '0x{0}'.format(address) if len(address) == 40 else address
        if len(address) != 42:
            return {
                'isvalid': False
            }
        elif re.match(r"^((0x)|(0X))?[0-9a-fA-F]{40}", address):
            return {
                'isvalid': True,
                'address': address,
                'scriptPubKey': 'hex',
                'ismine': (True if address in
                           (await self._rpc.eth_accounts()) else False),
                'iswatchonly': False,  # TODO
                'isscript': False,
                'pubkey': address,
                'iscompressed': False,
                'timestamp': None,  # TODO
            }
        else:
            return {
                'isvalid': False
            }

    @Method.registry(Category.Wallet)
    async def listsinceblock(self, blockhash, target_confirmations=1,
                             include_watchonly=False):
        """listsinceblock ( "blockhash" target_confirmations include_watchonly)

Get all transactions in blocks since block [blockhash]

Arguments:
1. "blockhash"            (string, required) The block hash to list transactions since
2. target_confirmations:    (numeric, optional) The confirmations required, must be 1 or more
3. include_watchonly:       (bool, optional, default=false) Include transactions to watch-only addresses (see 'importaddress')
Result:
{
  "transactions": [
    "address":"address",    (string) The ethereum address of the transaction. Not present for move transactions (category = move).
    "category":"send|receive",     (string) The transaction category. 'send' has negative amounts, 'receive' has positive amounts.
    "amount": x.xxx,          (numeric) The amount in BTC. This is negative for the 'send' category, and for the 'move' category for moves
                                          outbound. It is positive for the 'receive' category, and for the 'move' category for inbound funds.
    "vout" : n,               (numeric) the vout value
    "fee": x.xxx,             (numeric) The amount of the fee in BTC. This is negative and only available for the 'send' category of transactions.
    "confirmations": n,       (numeric) The number of confirmations for the transaction. Available for 'send' and 'receive' category of transactions.
                                          When it's < 0, it means the transaction conflicted that many blocks ago.
    "blockhash": "hashvalue",     (string) The block hash containing the transaction. Available for 'send' and 'receive' category of transactions.
    "blockindex": n,          (numeric) The index of the transaction in the block that includes it. Available for 'send' and 'receive' category of transactions.
    "blocktime": xxx,         (numeric) The block time in seconds since epoch (1 Jan 1970 GMT).
    "txid": "transactionid",  (string) The transaction id. Available for 'send' and 'receive' category of transactions.
    "time": xxx,              (numeric) The transaction time in seconds since epoch (Jan 1 1970 GMT).
    "timereceived": xxx,      (numeric) The time received in seconds since epoch (Jan 1 1970 GMT). Available for 'send' and 'receive' category of transactions.
    "abandoned": xxx,         (bool) 'true' if the transaction has been abandoned (inputs are respendable). Only available for the 'send' category of transactions.
    "comment": "...",       (string) If a comment is associated with the transaction.
    "label" : "label"       (string) A comment for the address/transaction, if any
    "to": "...",            (string) If a comment to is associated with the transaction.
  ],
  "lastblock": "lastblockhash"     (string) The hash of the last block
}

Examples:
> ethereum-cli listsinceblock
> ethereum-cli listsinceblock "0x2a7f92d11cf8194f2bc8976e0532a9d7735e60e99e3339cb2316bd4c5b4137ce"
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "listsinceblock", "params": ["0x2a7f92d11cf8194f2bc8976e0532a9d7735e60e99e3339cb2316bd4c5b4137ce"] }'  http://127.0.0.01:9500/
        """
        # TODO: Optimization??
        # TODO: Correct return data
        if target_confirmations < 1:
            raise BadResponseError('Invalid parameter', code=-8)
        transactions = []

        latest_block, from_block, addresses = await asyncio.gather(
            self._rpc.eth_getBlockByNumber(),
            self._rpc.eth_getBlockByHash(blockhash),
            self._rpc.eth_accounts()
        )
        if target_confirmations == 1:
            lst_hash = await self.getbestblockhash()
        else:
            need_height = hex_to_dec(latest_block['number']) + 1 - \
                target_confirmations
            lst_hash = (await self._rpc.eth_getBlockByNumber(need_height))['hash']
        if not from_block:
            return {
                'transactions': transactions,
                'lastblock': lst_hash,
            }

        start_height = hex_to_dec(from_block['number']) + 1
        end_height = hex_to_dec(latest_block['number'])

        def _fetch_block_transacs(addresses, block, tr):
            category = None
            if tr['from'] in addresses:
                address = tr['to']
                category = 'send'
            elif tr['to'] in addresses:
                address = tr['to']
                category = 'receive'

            if category:
                return {
                    'address': address,
                    'category': category,
                    'amount': wei_to_ether(hex_to_dec(tr['value'])),
                    'vout': 1,
                    'fee': (hex_to_dec(tr['gasPrice']) *
                            wei_to_ether(hex_to_dec(tr['gas']))),
                    'confirmations': (end_height + 1 -
                                      hex_to_dec(tr['blockNumber'])),
                    'blockhash': tr['blockHash'],
                    'blockindex': None,  # TODO
                    'blocktime': hex_to_dec(block['timestamp']),
                    'txid': tr['hash'],
                    'time': hex_to_dec(block['timestamp']),
                    'timereceived': None,  # TODO
                    'abandoned': False,  # TODO
                    'comment': None,  # TODO
                    'label': None,  # TODO
                    'to': None,  # TODO
                }

        blocks = [from_block]
        blocks.extend(filter(lambda b: b is not None,
                             await asyncio.gather(*(
                                 self._rpc.eth_getBlockByNumber(height)
                                 for height in range(start_height,
                                                     end_height)))))
        blocks.append(latest_block)
        for block in blocks:
            for tr in block['transactions']:
                if not (
                    tr['to'] in addresses and tr['from'] in addresses
                ):
                    fetched_tr = _fetch_block_transacs(addresses, block, tr)
                    if fetched_tr:
                        transactions.append(fetched_tr)

        return {
            'transactions': transactions,
            'lastblock': lst_hash,
        }

    @Method.registry(Category.Wallet)
    async def walletpassphrase(self, address, passphrase, timeout):
        """walletpassphrase "passphrase" timeout

Stores the wallet decryption key in memory for 'timeout' seconds.
This is needed prior to performing transactions related to private keys such as sending ether

Arguments:
1. "address"          (string, required) Address of account.
2. "passphrase"     (string, required) The wallet passphrase
3. timeout          (numeric, required) The time to keep the decryption key in seconds.

Note:
Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock
time that overrides the old one.

Examples:

unlock the wallet for 60 seconds
> ethereum-cli walletpassphrase "0x6cace0528324a8afc2b157ceba3cdd2a27c4e21f" "my pass phrase" 60

Lock the wallet again (before 60 seconds)
> ethereum-cli walletlock "0x6cace0528324a8afc2b157ceba3cdd2a27c4e21f"

As json rpc call
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "walletpassphrase", "params": ["0x6cace0528324a8afc2b157ceba3cdd2a27c4e21f", "my pass phrase", 60] }'  http://127.0.0.01:9500/
        """
        return await self._rpc.personal_unlockAccount(address, passphrase,
                                                      timeout)

    @Method.registry(Category.Wallet)
    async def walletlock(self, address):
        """walletlock

Removes the wallet encryption key from memory, locking the wallet.
After calling this method, you will need to call walletpassphrase again
before being able to call any methods which require the wallet to be unlocked.

Arguments:
1. "address"         (string, required) Address of account.

Examples:

Clear the passphrase since we are done before 2 minutes is up
> ethereum-cli walletlock "0x6cace0528324a8afc2b157ceba3cdd2a27c4e21f"

As json rpc call
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "walletlock", "params": ["0x6cace0528324a8afc2b157ceba3cdd2a27c4e21f"] }'  http://127.0.0.01:9500/
        """
        return await self._rpc.personal_lockAccount(address)

    @Method.registry(Category.Blockchain)
    async def getblockhash(self, height):
        """getblockhash height

Returns hash of block in best-block-chain at height provided.

Arguments:
1. height         (numeric, required) The height index

Result:
"hash"         (string) The block hash

Examples:
> ethereum-cli getblockhash 1000
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "getblockhash", "params": [1000] }'  http://127.0.0.01:9500/
        """
        if height < 0:
            raise BadResponseError('Block height out of range', code=-8)

        block = await self._rpc.eth_getBlockByNumber(height)
        if block is None:
            raise BadResponseError('Block height out of range', code=-8)

        return block['hash']

    @Method.registry(Category.Blockchain)
    async def getdifficulty(self):
        """getdifficulty

Returns the proof-of-work difficulty as a multiple of the minimum difficulty.

Result:
n.nnn       (numeric) the proof-of-work difficulty as a multiple of the minimum difficulty.

Examples:
> ethereum-cli getdifficulty
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "getdifficulty", "params": [] }'  http://127.0.0.01:9500/
        """
        return await self._rpc.eth_hashrate()

    @Method.registry(Category.Util)
    async def estimatefee(self, nblocks=1):
        """estimatefee nblocks

Estimates the approximate fee needed for a transaction to begin
confirmation within nblocks blocks.

Arguments:
1. nblocks     (numeric, required) DEPRECATED.

Result:
n              (numeric) estimated fee-per-kilobyte

Example:
> ethereum-cli estimatefee
        """
        gas = await self._paytxfee_to_etherfee()
        return wei_to_ether(gas['gas_amount'] * gas['gas_price'])

    @Method.registry(Category.Wallet)
    async def getbalance(self, account=None, minconf=1,
                         include_watchonly=True):
        """getbalance ( "account" minconf include_watchonly )

If account is not specified, returns the server's total available balance.
If account is specified (DEPRECATED), returns the balance in the account.
Note that the account "" is not the same as leaving the parameter out.
The server total may be different to the balance in the default "" account.

Arguments:
1. "account"         (string, optional) DEPRECATED. The account string may be given as a
                     specific account name to find the balance associated with wallet keys in
                     a named account, or as the empty string ("") to find the balance
                     associated with wallet keys not in any named account, or as "*" to find
                     the balance associated with all wallet keys regardless of account.
                     When this option is specified, it calculates the balance in a different
                     way than when it is not specified, and which can count spends twice when
                     there are conflicting pending transactions (such as those created by
                     the bumpfee command), temporarily resulting in low or even negative
                     balances. In general, account balance calculation is not considered
                     reliable and has resulted in confusing outcomes, so it is recommended to
                     avoid passing this argument.
2. minconf           (numeric, optional, default=1) Only include transactions confirmed at least this many times.
3. include_watchonly (bool, optional, default=false) DEPRECATED. Also include balance in watch-only addresses (see 'importaddress')

Result:
amount              (numeric) The total amount in BTC received for this account.

Examples:

The total amount in the wallet
> ethereum-cli getbalance

The total amount in the wallet at least 5 blocks confirmed
> ethereum-cli getbalance "*" 6

As a json rpc call
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "getbalance", "params": ["*", 6] }'  http://127.0.0.01:9500/
        """
        # NOTE: minconf nt work curently
        async def _get_balance(address):
            balance = (await self._rpc.eth_getBalance(address)) or 0
            if not isinstance(balance, (int, float)):
                balance = hex_to_dec(balance)
            return wei_to_ether(balance)

        if account:
            return await _get_balance(account)

        addresses = await self._rpc.eth_accounts()
        return sum(await asyncio.gather(*(_get_balance(address)
                                          for address in addresses)))

    @Method.registry(Category.Wallet)
    async def settxfee(self, amount):
        """settxfee amount

Set the transaction fee for transactions only. Overwrites the paytxfee parameter.

Arguments:
1. amount         (numeric or string, required) The transaction fee in ether

Result
true|false        (boolean) Returns true if successful

Examples:
> ethereum-cli settxfee 0.00042
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "settxfee", "params": [0.00042] }'  http://127.0.0.01:9500/
        """
        if isinstance(amount, (int, float)) and amount <= 0:
            raise BadResponseError('Amount out of range', code=-3)

        try:
            self._paytxfee = float(amount)
        except Exception:
            return False
        else:
            return True

    @Method.registry(Category.Wallet)
    async def listaccounts(self, minconf=1, include_watchonly=True):
        """listaccounts ( minconf include_watchonly)

Arguments:
1. minconf             (numeric, optional, default=1) Only include transactions with at least this many confirmations
2. include_watchonly   (bool, optional, default=false) DEPRECATED. Include balances in watch-only addresses (see 'importaddress')

Result:
{                      (json object where keys are account names, and values are numeric balances
  "account": x.xxx,  (numeric) The property name is the account name, and the value is the total balance for the account.
  ...
}

Examples:

List account balances where there at least 1 confirmation
> ethereum-cli listaccounts

List account balances including zero confirmation transactions
> ethereum-cli listaccounts 0

List account balances for 6 or more confirmations
> ethereum-cli listaccounts 6

As json rpc call
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "listaccounts", "params": [6] }'  http://127.0.0.01:9500/
        """
        # NOTE: minconf nt work curently
        addresses = await self._rpc.eth_accounts()
        accounts = {}
        for i, address in enumerate(addresses):
            # account = 'Account #{0}'.format(i)
            balance = (await self._rpc.eth_getBalance(address)) or 0
            if not isinstance(balance, (int, float)):
                balance = hex_to_dec(balance)
            accounts[address] = wei_to_ether(balance)

        return accounts

    @Method.registry(Category.Wallet)
    async def gettransaction(self, txid, include_watchonly=False):
        """gettransaction "txid" ( include_watchonly )

Get detailed information about in-wallet transaction <txid>

Arguments:
1. "txid"                  (string, required) The transaction id
2. "include_watchonly"     (bool, optional, default=false) DEPRECATED. Whether to include watch-only addresses in balance calculation and details[]

Result:
{
  "amount" : x.xxx,        (numeric) The transaction amount in BTC
  "fee": x.xxx,            (numeric) The amount of the fee in BTC. This is negative and only available for the
                              'send' category of transactions.
  "confirmations" : n,     (numeric) The number of confirmations
  "blockhash" : "hash",  (string) The block hash
  "blockindex" : xx,       (numeric) The index of the transaction in the block that includes it
  "blocktime" : ttt,       (numeric) The time in seconds since epoch (1 Jan 1970 GMT)
  "txid" : "transactionid",   (string) The transaction id.
  "time" : ttt,            (numeric) The transaction time in seconds since epoch (1 Jan 1970 GMT)
  "timereceived" : ttt,    (numeric) The time received in seconds since epoch (1 Jan 1970 GMT)
  "details" : [
    {
      "address" : "address",          (string) The ethereum address involved in the transaction
      "category" : "send|receive",    (string) The category, either 'send' or 'receive'
      "amount" : x.xxx,                 (numeric) The amount in BTC
      "label" : "label",              (string) A comment for the address/transaction, if any
      "vout" : n,                       (numeric) the vout value
      "fee": x.xxx,                     (numeric) The amount of the fee in BTC. This is negative and only available for the
                                           'send' category of transactions.
      "abandoned": xxx                  (bool) 'true' if the transaction has been abandoned (inputs are respendable). Only available for the
                                           'send' category of transactions.
    }
    ,...
  ],
  "hex" : "data"         (string) Raw data for transaction
}

Examples:
> ethereum-cli gettransaction "0xa4cb352eaff243fc962db84c1ab9e180bf97857adda51e2a417bf8015f05def3"
> ethereum-cli gettransaction "0xa4cb352eaff243fc962db84c1ab9e180bf97857adda51e2a417bf8015f05def3" true
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "gettransaction", "params": ["0xa4cb352eaff243fc962db84c1ab9e180bf97857adda51e2a417bf8015f05def3"] }'  http://127.0.0.01:9500/
        """
        # TODO: Make workable include_watchonly flag
        transaction, addresses = await asyncio.gather(
            self._rpc.eth_getTransactionByHash(txid),
            self._rpc.eth_accounts()
        )
        if transaction is None:
            raise BadResponseError('Invalid or non-wallet transaction id',
                                   code=-5)

        trans_info = {
            'amount': wei_to_ether(hex_to_dec(transaction['value'])),
            'blockhash': transaction['blockHash'],
            'blockindex': None,
            'blocktime': None,
            'confirmations': 0,
            'trusted': None,
            'walletconflicts': [],
            'txid': transaction['hash'],
            'time': None,
            'timereceived': None,
            'details': [],
            'hex': transaction['input'],
            'fee': DEFAUT_FEE,
        }
        if hex_to_dec(transaction['blockHash']) != 0:
            block = await self.getblock(transaction['blockHash'])
            trans_info['confirmations'] = block['confirmations']
        else:
            trans_info['confirmations'] = 0
        if transaction['to'] in addresses:
            trans_info['details'].append({
                'address': transaction['to'],
                'category': 'receive',
                'amount': trans_info['amount'],
                'label': '',
                'vout': 1
            })
        if transaction['from'] in addresses:
            from_ = {
                'address': transaction['to'],
                'category': 'send',
                'amount': operator.neg(trans_info['amount']),
                'vout': 1,
                'abandoned': False,
                'fee': DEFAUT_FEE,
            }
            if hex_to_dec(transaction['blockHash']):
                tr_hash, tr_receipt = await asyncio.gather(
                    self._rpc.eth_getTransactionByHash(transaction['hash']),
                    self._rpc.eth_getTransactionReceipt(transaction['hash'])
                )
                from_['fee'] = (hex_to_dec(tr_hash['gasPrice']) *
                                wei_to_ether(
                                    hex_to_dec(tr_receipt['gasUsed'])))
            trans_info['details'].append(from_)
        return trans_info

    @Method.registry(Category.Wallet)
    async def getnewaddress(self, passphrase):
        """getnewaddress ( "passphrase" )

Returns a new Ethereum address for receiving payments.

Arguments:
1. "passphrase"        (string, required) The password for new account. If not provided, the default password "" is used.

Result:
"passphrase"    (string) The passphrase for address

Examples:
> ethereum-cli getnewaddress "passphrase"
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "getnewaddress", "params": ["passphrase"] }'  http://127.0.0.01:9500/
        """
        return await self._rpc.personal_newAccount(passphrase)

    @Method.registry(Category.Wallet)
    async def sendfrom(self, fromaccount, toaddress, amount,
                       minconf=1, comment="", comment_to=""):
        """sendfrom "fromaccount" "toaddress" amount ( minconf "comment" "comment_to" )

DEPRECATED (use sendtoaddress). Sent an amount from an account to a ethereum address.
Requires wallet passphrase to be set with walletpassphrase call.

Arguments:
1. "fromaccount"       (string, required) The name of the account to send funds from. May be the default account using "".
                       Specifying an account does not influence coin selection, but it does associate the newly created
                       transaction with the account, so the account's balance computation and transaction history can reflect
                       the spend.
2. "toaddress"         (string, required) The ethereum address to send funds to.
3. amount                (numeric or string, required) The amount in BTC (transaction fee is added on top).
4. minconf               (numeric, optional, default=1) Only use funds with at least this many confirmations.
5. "comment"           (string, optional) A comment used to store what the transaction is for. 
                                     This is not part of the transaction, just kept in your wallet.
6. "comment_to"        (string, optional) An optional comment to store the name of the person or organization 
                                     to which you're sending the transaction. This is not part of the transaction, 
                                     it is just kept in your wallet.

Result:
"txid"                 (string) The transaction id.

Examples:

Send 0.01 ETH from the coinbase account to the address, must have at least 1 confirmation
> ethereum-cli sendfrom "" "0xc729d1e61e94e0029865d759327667a6abf0cdc5" 0.01

Send 0.01 from the tabby account to the given address, funds must have at least 6 confirmations
> ethereum-cli sendfrom "tabby" "0xc729d1e61e94e0029865d759327667a6abf0cdc5" 0.01 6 "donation" "seans outpost"

As a json rpc call
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "sendfrom", "params": ["0xc729d1e61e94e0029865d759327667a6abf0cdc5", 0.01, 6, "donation", "seans outpost"] }'  http://127.0.0.01:9500/
        """
        # TODO: add default fromaccount if empty as coinbase
        # TODO: Add amount and address validation
        # TODO: Add minconf logic
        gas = await self._paytxfee_to_etherfee()
        try:
            return await self._rpc.eth_sendTransaction(
                fromaccount,  # from ???
                toaddress,  # to
                gas['gas_amount'],  # gas amount
                gas['gas_price'],  # gas price
                ether_to_wei(float(amount)),  # value
            )
        except BadResponseError as e:
            if (
                e.code == -32000 and
                'gas * price + value' in e.msg
            ):
                raise BadResponseError('Insufficient funds', code=-6)
            raise

    @Method.registry(Category.Wallet)
    async def sendtoaddress(self, address, amount, comment="",
                            comment_to="", subtractfeefromamount=False):
        """sendtoaddress "address" amount ( "comment" "comment_to" subtractfeefromamount )

Send an amount to a given address from coinbase.

Arguments:
1. "address"            (string, required) The ethereum address to send to.
2. "amount"             (numeric or string, required) The amount in ETH to send. eg 0.1
3. "comment"            (string, optional) DEPRECATED. A comment used to store what the transaction is for.
                             This is not part of the transaction, just kept in your wallet.
4. "comment_to"         (string, optional) DEPRECATED. A comment to store the name of the person or organization
                             to which you're sending the transaction. This is not part of the
                             transaction, just kept in your wallet.
5. subtractfeefromamount  (boolean, optional, default=false) The fee will be deducted from the amount being sent.
                             The recipient will receive less ether than you enter in the amount field.

Result:
"txid"                  (string) The transaction id.

Examples:
> ethereum-cli sendtoaddress "0xc729d1e61e94e0029865d759327667a6abf0cdc5" 0.1
> ethereum-cli sendtoaddress "0xc729d1e61e94e0029865d759327667a6abf0cdc5" 0.1 "donation" "seans outpost"
> ethereum-cli sendtoaddress "0xc729d1e61e94e0029865d759327667a6abf0cdc5" 0.1 "" "" true
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "sendtoaddress", "params": ["0xc729d1e61e94e0029865d759327667a6abf0cdc5", 0.1, "donation", "seans outpost"] }'  http://127.0.0.01:9500/
        """
        # TODO: Add subtractfeefromamount logic
        # TODO: Add amount and address validation
        return await self.sendfrom((await self._rpc.eth_coinbase()),
                                   address, amount)

    @Method.registry(Category.Blockchain)
    async def getblockcount(self):
        """getblockcount

Returns the number of blocks in the longest blockchain.

Result:
n    (numeric) The current block count

Examples:
> ethereum-cli getblockcount
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "getblockcount", "params": [] }'  http://127.0.0.01:9500/
        """
        # TODO: What happen when no blocks in db?
        return await self._rpc.eth_blockNumber()

    @Method.registry(Category.Blockchain)
    async def getbestblockhash(self):
        """getbestblockhash

Returns the hash of the best (tip) block in the longest blockchain.

Result:
"hex"      (string) the block hash hex encoded

Examples:
> ethereum-cli getbestblockhash 
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "getbestblockhash", "params": [] }'  http://127.0.0.01:9500/
        """
        # TODO: What happen when no blocks in db?
        block = await self._rpc.eth_getBlockByNumber(tx_objects=False)
        if block is None:
            raise BadResponseError('Block not found', code=-5)

        return block['hash']

    @Method.registry(Category.Blockchain)
    async def getblock(self, blockhash, verbose=True):
        """getblock "blockhash" ( verbose )

If verbose is false, returns a string that is serialized, hex-encoded data for block 'hash'.
If verbose is true, returns an Object with information about block <hash>.

Arguments:
1. "blockhash"          (string, required) The block hash
2. verbose                (boolean, optional, default=true) true for a json object, false for the hex encoded data

Result (for verbose = true):
{
  "hash" : "hash",     (string) the block hash (same as provided)
  "confirmations" : n,   (numeric) The number of confirmations, or -1 if the block is not on the main chain
  "size" : n,            (numeric) The block size
  "strippedsize" : n,    (numeric) The block size excluding witness data
  "weight" : n           (numeric) The block weight
  "height" : n,          (numeric) The block height or index
  "version" : n,         (numeric) The block version
  "versionHex" : "00000000", (string) The block version formatted in hexadecimal
  "merkleroot" : "xxxx", (string) The merkle root
  "tx" : [               (array of string) The transaction ids
     "transactionid"     (string) The transaction id
     ,...
  ],
  "time" : ttt,          (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)
  "mediantime" : ttt,    (numeric) The median block time in seconds since epoch (Jan 1 1970 GMT)
  "nonce" : n,           (numeric) The nonce
  "bits" : "1d00ffff", (string) The bits
  "difficulty" : x.xxx,  (numeric) The difficulty
  "chainwork" : "xxxx",  (string) Expected number of hashes required to produce the chain up to this block (in hex)
  "previousblockhash" : "hash",  (string) The hash of the previous block
  "nextblockhash" : "hash"       (string) The hash of the next block
}

Result (for verbose=false):
"data"             (string) A string that is serialized, hex-encoded data for block 'hash'.

Examples:
> ethereum-cli getblock "0x8b22f9aa6c27231fb4acc587300abadd259f501ba99ef18d11e9e4dfa741eb39"
> curl -X POST -H 'Content-Type: application/json' -d '{"jsonrpc": "1.0", "id":"curltest", "method": "getblock", "params": ["0x8b22f9aa6c27231fb4acc587300abadd259f501ba99ef18d11e9e4dfa741eb39"] }'  http://127.0.0.01:9500/
        """
        block = await self._rpc.eth_getBlockByHash(blockhash, False)
        if block is None:
            raise BadResponseError('Block not found', code=-5)

        if not verbose:
            return block['hash']

        next_block, confirmations = await asyncio.gather(
            self._rpc.eth_getBlockByNumber(
                hex_to_dec(block['number']) + 1, False),
            self._get_confirmations(block),
        )

        data = {
            'hash': block['hash'],
            'confirmations': (await self._get_confirmations(block)),
            'strippedsize': None,
            'size': None,
            'weight': None,
            'height': None,
            'version': None,
            'versionHex': None,
            'merkleroot': None,
            'tx': block['transactions'],
            'time': hex_to_dec(block['timestamp']),
            'mediantime': None,
            'nonce': hex_to_dec(block['nonce']),
            'bits': None,
            'difficulty': hex_to_dec(block['totalDifficulty']),
            'chainwork': None,
            'previousblockhash': block['parentHash']
        }
        if next_block:
            data['nextblockhash'] = next_block['hash']
        return data

    # UTILS METHODS

    async def _paytxfee_to_etherfee(self):
        try:
            gas_price = ether_to_wei(self._paytxfee / GAS_AMOUNT)
        except AttributeError:
            gas_price = await self._rpc.eth_gasPrice()
        finally:
            return {
                'gas_amount': GAS_AMOUNT,
                'gas_price': gas_price,
            }

    async def _calculate_confirmations(self, response):
        return (await self._rpc.eth_blockNumber() -
                hex_to_dec(response['number']))

    async def _get_confirmations(self, block):
        last_block_number = await self._rpc.eth_blockNumber()
        if not last_block_number:
            raise RuntimeError('Blockchain not synced.')

        if not block['number']:
            return 0
        return (last_block_number - hex_to_dec(block['number']))


async def create_ethereumd_proxy(uri, timeout=60, *, loop=None):
    rpc = await create_ethereum_client(uri, timeout, loop=loop)
    return EthereumProxy(rpc)
